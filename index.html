<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>äº’å‹•å¼è¦–å·®ç¶²é </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            /* ğŸ“± ç¢ºä¿htmlåœ¨æ–¹å‘è®ŠåŒ–æ™‚æ­£ç¢ºè™•ç† */
            width: 100vw;
            height: 100vh;
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            overflow: hidden;
        }
        
        /* ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šç¢ºä¿å…ƒç´ åœ¨é«˜è§£æè¢å¹•ä¸Šæ¸…æ™°é¡¯ç¤º */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            /* é«˜è§£æè¢å¹•å„ªåŒ– */
            * {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-rendering: optimizeLegibility;
            }
            
            /* ç¢ºä¿æŒ‰éˆ•åœ¨é«˜è§£æè¢å¹•ä¸Šé‚Šç·£æ¸…æ™° */
            #back-button, #fullscreen-button, #reset-view-button {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
            
            /* ç¢ºä¿è¼‰å…¥å‹•ç•«åœ¨é«˜è§£æè¢å¹•ä¸Šæµæš¢ */
            .elegant-spinner, .spinner-ring {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
            
            /* ç¢ºä¿ç²’å­æ•ˆæœåœ¨é«˜è§£æè¢å¹•ä¸Šæ¸…æ™° */
            .particle {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a1a);
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* ğŸ“± ç¢ºä¿bodyåœ¨æ–¹å‘è®ŠåŒ–æ™‚æ­£ç¢ºè™•ç† */
            width: 100vw;
            height: 100vh;
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            /* ğŸ“± ç¢ºä¿å®¹å™¨åœ¨æ–¹å‘è®ŠåŒ–æ™‚æ­£ç¢ºè™•ç† */
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* ğŸ­ ä¸‰å±¤ç´šæ¶æ§‹ Z-Index å®šç¾© */
        /* å±¤ç´š 3: UI å±¤ (z-index: 3000+) */
        #back-button {
            position: fixed;
            top: 25px;
            left: 25px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI å±¤ï¼šæœ€ä¸Šå±¤ */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #back-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #back-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #back-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #back-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: translateX(-1px);
        }

        #back-button:active svg {
            stroke: #f4e3d4;
            transform: translateX(-1px) scale(0.95);
        }

        /* å…¨è¢å¹•æŒ‰éˆ• - åœ¨æ‰€æœ‰è£ç½®é¡¯ç¤º */
        #fullscreen-button {
            position: fixed;
            top: 25px;
            right: 25px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI å±¤ï¼šæœ€ä¸Šå±¤ */
            display: flex; /* åœ¨æ‰€æœ‰è£ç½®é¡¯ç¤º */
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #fullscreen-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #fullscreen-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #fullscreen-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #fullscreen-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: scale(1.1);
        }

        #fullscreen-button:active svg {
            stroke: #f4e3d4;
            transform: scale(0.95);
        }

        /* é‡ç½®è¦–è§’æŒ‰éˆ• - èˆ‡å…¶ä»–æŒ‰éˆ•ä¿æŒä¸€è‡´çš„é¢¨æ ¼ */
        #reset-view-button {
            position: fixed;
            top: 25px;
            right: 80px; /* åœ¨å…¨è¢å¹•æŒ‰éˆ•å·¦é‚Š */
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI å±¤ï¼šæœ€ä¸Šå±¤ */
            display: none; /* é è¨­éš±è—ï¼Œèˆ‡å…¨è¢å¹•æŒ‰éˆ•é‚è¼¯ä¸€è‡´ */
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #reset-view-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #reset-view-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #reset-view-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #reset-view-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: rotate(180deg);
        }

        #reset-view-button:active svg {
            stroke: #f4e3d4;
            transform: rotate(180deg) scale(0.95);
        }

        /* å±¤ç´š 2: è¼‰å…¥å±¤ (z-index: 2000+) */
        #loading-cover {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 2000; /* è¼‰å…¥å±¤ï¼šä¸­é–“å±¤ */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #loading-cover.fade-in {
            opacity: 1;
            transition: opacity 0.5s ease; /* æ˜ç¢ºè¨­å®šæ·¡å…¥æ™‚é–“ */
        }

        @keyframes fadeOut { 
            0% { opacity: 1; } 
            80% { opacity: 0.15; } 
            100% { opacity: 0; } 
        }
        
        #loading-cover.fade-out { 
            animation: fadeOut 0.9s ease-out forwards; 
            will-change: opacity;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2001; /* è¼‰å…¥å±¤ï¼šè¼‰å…¥å‹•ç•« */
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        #loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-container {
            position: relative;
            padding: 40px;
        }



        .elegant-spinner {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
        }

        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
        }

        .spinner-ring:nth-child(1) {
            border-top: 2px solid #dc9c3b;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .spinner-ring:nth-child(2) {
            border-right: 2px solid #d1936b;
            transform: scale(0.8);
            filter: drop-shadow(0 0 6px rgba(209, 147, 107, 0.4));
        }

        .spinner-ring:nth-child(3) {
            border-bottom: 2px solid #f4e3d4;
            transform: scale(0.6);
            filter: drop-shadow(0 0 4px rgba(244, 227, 212, 0.3));
        }

        .loading-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 20px;
        }

        .dot {
            width: 5px;
            height: 5px;
            background: #dc9c3b;
            border-radius: 50%;
            animation: dotPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(220, 156, 59, 0.5);
        }

        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.3s; }
        .dot:nth-child(3) { animation-delay: 0.6s; }

        .loading-particles {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 200px;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            opacity: 0;
            animation: particleFloat 4s linear infinite, particleGlow 2s ease-in-out infinite alternate;
            bottom: 5px; /* åˆå§‹ä½ç½®åœ¨å®¹å™¨åº•éƒ¨å¤–é¢ */
            filter: brightness(1.2);
        }

        @keyframes titleGlow {
            0% { 
                text-shadow: 0 0 20px rgba(244, 227, 212, 0.5);
                transform: scale(1) translateZ(0);
            }
            100% { 
                text-shadow: 0 0 30px rgba(244, 227, 212, 0.8), 0 0 40px rgba(220, 156, 59, 0.3);
                transform: scale(1.02) translateZ(0);
            }
        }

        @keyframes elegantSpin {
            0% { transform: rotate(0deg) translateZ(0); }
            100% { transform: rotate(360deg) translateZ(0); }
        }

        @keyframes dotPulse {
            0%, 100% { 
                transform: scale(1) translateZ(0); 
                opacity: 0.3; 
            }
            50% { 
                transform: scale(1.3) translateZ(0); 
                opacity: 1; 
                box-shadow: 0 0 15px rgba(220, 156, 59, 0.8);
            }
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(0) scale(0) translateZ(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(-20px) scale(1) translateZ(0);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-250px) scale(1) translateZ(0);
                opacity: 0;
            }
        }



        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2002; /* è¼‰å…¥å±¤ï¼šéŒ¯èª¤è¨Šæ¯ */
        }

        /* ğŸ® é™€èºå„€æˆæ¬ŠæŒ‰éˆ•æ¨£å¼ - æ¥µç°¡é¢¨æ ¼ */
        .gyro-permission {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 3001; /* åœ¨è¿”å›æŒ‰éˆ•ä¹‹ä¸Šï¼Œä½†åœ¨è¼‰å…¥å±¤ä¹‹ä¸‹ */
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            pointer-events: none; /* ä¿®æ­£ï¼šéš±è—æ™‚ä¸é˜»æ“‹äº’å‹• */
        }

        .gyro-permission.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* é¡¯ç¤ºæ™‚æ‰å¯äº’å‹• */
        }

        .gyro-permission-content {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            max-width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .gyro-permission-icon {
            font-size: 24px;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .gyro-permission-title {
            font-size: 16px;
            font-weight: bold;
            color: #f4e3d4;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(244, 227, 212, 0.3);
        }

        .gyro-permission-desc {
            font-size: 12px;
            color: rgba(244, 227, 212, 0.7);
            line-height: 1.4;
            margin-bottom: 16px;
        }

        .gyro-permission-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .gyro-permission-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #f4e3d4;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            min-width: 60px;
        }

        .gyro-permission-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(220, 156, 59, 0.4);
        }

        .gyro-permission-btn.primary {
            background: rgba(220, 156, 59, 0.2);
            border-color: rgba(220, 156, 59, 0.5);
        }

        .gyro-permission-btn.primary:hover {
            background: rgba(220, 156, 59, 0.3);
            border-color: rgba(220, 156, 59, 0.7);
            box-shadow: 0 0 20px rgba(220, 156, 59, 0.6);
        }

        /* è¡Œå‹•è£ç½®é©é… */
        @media (max-width: 768px) {
            .gyro-permission {
                bottom: 20px;
                right: 20px;
                left: 20px;
            }
            
            .gyro-permission-content {
                max-width: none;
                padding: 16px;
            }
            
            .gyro-permission-buttons {
                flex-direction: column;
                gap: 6px;
            }
            
            .gyro-permission-btn {
                padding: 10px 16px;
                font-size: 14px;
            }
        }

        #error-message {
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            max-width: 80%;
            display: none;
        }



        /* å±¤ç´š 1: å…§å®¹å±¤ (z-index: 1000+) */
        #canvas {
            display: block;
            z-index: 1000; /* å…§å®¹å±¤ï¼šæœ€ä¸‹å±¤ */
            width: 100vw;
            height: 100vh;
            /* ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šç¢ºä¿canvasåœ¨é«˜è§£æè¢å¹•ä¸Šæ¸…æ™° */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        #loading-canvas {
            display: block;
            z-index: 2000; /* è¼‰å…¥å±¤ */
            width: 100vw;
            height: 100vh;
            /* ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šç¢ºä¿è¼‰å…¥canvasåœ¨é«˜è§£æè¢å¹•ä¸Šæ¸…æ™° */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* ç´”è§¸æ§è£ç½®ï¼šç¦ç”¨hoveræ•ˆæœï¼ˆåƒ…é™æ–¼æ²’æœ‰æ»‘é¼ çš„è£ç½®ï¼‰ */
        @media (hover: none) and (pointer: coarse) and (max-width: 1024px) {
            /* è§¸æ§è£ç½®ï¼šèª¿æ•´éæ¸¡å‹•ç•«æ™‚é–“ï¼Œè®“é»æ“Šæ•ˆæœæ›´æ˜é¡¯ */
            #back-button, #fullscreen-button, #reset-view-button {
                transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            }
            
            #back-button svg, #fullscreen-button svg, #reset-view-button svg {
                transition: transform 0.15s ease, filter 0.2s ease;
            }
            

            
            /* è§¸æ§è£ç½®ï¼šåŠ å¼·activeç‹€æ…‹çš„è¦–è¦ºå›é¥‹ï¼Œæ›´æ˜é¡¯çš„æ•ˆæœ */
            #back-button:active, #fullscreen-button:active, #reset-view-button:active {
                background: rgba(255, 255, 255, 0.35);
                border-color: rgba(244, 227, 212, 0.7);
                transform: translateY(1px) scale(0.85);
                box-shadow: 
                    0 1px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 3px rgba(244, 227, 212, 0.3),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.1s ease;
            }
            
            #back-button:active svg, #fullscreen-button:active svg, #reset-view-button:active svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
                transform: scale(0.85);
                transition: all 0.1s ease;
            }
        }

        /* æ‰‹æ©Ÿè£ç½®ï¼šé¡å¤–çš„è§¸æ§å„ªåŒ– */
        @media (max-width: 480px) {
            #back-button, #fullscreen-button, #reset-view-button {
                transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            }
            
            #back-button svg, #fullscreen-button svg, #reset-view-button svg {
                transition: transform 0.15s ease, filter 0.2s ease;
            }
            
            #back-button:active, #fullscreen-button:active, #reset-view-button:active {
                background: rgba(255, 255, 255, 0.35);
                border-color: rgba(244, 227, 212, 0.7);
                transform: translateY(1px) scale(0.85);
                box-shadow: 
                    0 1px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 3px rgba(244, 227, 212, 0.3),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.1s ease;
            }
            
            #back-button:active svg, #fullscreen-button:active svg, #reset-view-button:active svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
                transform: scale(0.85);
                transition: all 0.1s ease;
            }
        }

        /* JavaScriptæª¢æ¸¬çš„è§¸æ§è£ç½®å„ªåŒ– */
        .touch-device #back-button,
        .touch-device #fullscreen-button,
        .touch-device #reset-view-button {
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
        }
        
        .touch-device #back-button svg,
        .touch-device #fullscreen-button svg,
        .touch-device #reset-view-button svg {
            transition: transform 0.15s ease, filter 0.2s ease;
        }
        
        .touch-device #back-button:hover,
        .touch-device #fullscreen-button:hover,
        .touch-device #reset-view-button:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: none;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
        }
        
        .touch-device #back-button:hover svg,
        .touch-device #fullscreen-button:hover svg,
        .touch-device #reset-view-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
            transform: none;
        }
        
        .touch-device #back-button:active,
        .touch-device #fullscreen-button:active,
        .touch-device #reset-view-button:active {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(244, 227, 212, 0.7);
            transform: translateY(1px) scale(0.85);
            box-shadow: 
                0 1px 4px rgba(0, 0, 0, 0.3),
                0 0 0 3px rgba(244, 227, 212, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.1s ease;
        }
        
        .touch-device #back-button:active svg,
        .touch-device #fullscreen-button:active svg,
        .touch-device #reset-view-button:active svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
            transform: scale(0.85);
            transition: all 0.1s ease;
        }



        @media (max-width: 768px) {
            #back-button {
                width: 40px;
                height: 40px;
                top: 20px;
                left: 20px;
                border-radius: 50%;
            }
            
            #back-button svg {
                width: 18px;
                height: 18px;
            }
            
            #reset-view-button {
                width: 40px;
                height: 40px;
                bottom: 20px;
                left: 20px;
            }
            
            #reset-view-button svg {
                width: 18px;
                height: 18px;
            }
        }

        /* è¡Œå‹•è£ç½®ï¼šèª¿æ•´å…¨è¢å¹•æŒ‰éˆ•å¤§å° */
        @media (max-width: 1024px) {
            #fullscreen-button {
                width: 44px;
                height: 44px;
                top: 25px;
                right: 25px;
            }
            
            #fullscreen-button svg {
                width: 20px;
                height: 20px;
            }
        }

        /* å°è¢å¹•è¡Œå‹•è£ç½®ï¼šèª¿æ•´å…¨è¢å¹•æŒ‰éˆ•å¤§å° */
        @media (max-width: 768px) {
            #fullscreen-button {
                width: 40px;
                height: 40px;
                top: 20px;
                right: 20px;
            }
            
            #fullscreen-button svg {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 768px) {
            .loading-container {
                padding: 20px;
            }
            
            .elegant-spinner {
                width: 60px;
                height: 60px;
                margin: 0 auto 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading-cover">
            <canvas id="loading-canvas"></canvas>
        </div>
        
        <div id="loading">
            <div class="loading-container">
                <div class="loading-particles" id="particles"></div>
                <div class="elegant-spinner">
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                </div>
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>
        
        <div id="error-message">
            <h3>âš ï¸ è¼‰å…¥éŒ¯èª¤</h3>
            <p>è«‹ä½¿ç”¨æœ¬åœ°ä¼ºæœå™¨é–‹å•Ÿæ­¤ç¶²é ä»¥é¿å… CORS å•é¡Œ</p>
            <br>
            <p><strong>å»ºè­°è§£æ±ºæ–¹æ¡ˆï¼š</strong></p>
            <p>1. ä½¿ç”¨ Python: <code>python -m http.server 8000</code></p>
            <p>2. ä½¿ç”¨ Node.js: <code>npx http-server</code></p>
            <p>3. ä½¿ç”¨ VS Code Live Server æ“´å……åŠŸèƒ½</p>
        </div>
        
        <button id="back-button" onclick="handleBackButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
        </button>

        <!-- å…¨è¢å¹•æŒ‰éˆ• - æ‰€æœ‰è£ç½®å¯ç”¨ -->
        <button id="fullscreen-button" onclick="handleFullscreenButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
        </button>

        <!-- é‡ç½®è¦–è§’æŒ‰éˆ• -->
        <button id="reset-view-button" onclick="handleResetViewButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                <path d="M21 3v5h-5"/>
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                <path d="M3 21v-5h5"/>
            </svg>
        </button>

        <!-- ğŸ® iOSé™€èºå„€æˆæ¬ŠæŒ‰éˆ• - æ¥µç°¡é¢¨æ ¼ -->
        <div id="gyro-permission" class="gyro-permission">
            <div class="gyro-permission-content">
                <div class="gyro-permission-icon">ğŸ®</div>
                <div class="gyro-permission-title">é™€èºå„€æ§åˆ¶</div>
                <div class="gyro-permission-desc">é»æ“Šå•Ÿç”¨ä»¥ç²å¾—æœ€ä½³äº’å‹•é«”é©—</div>
                <div class="gyro-permission-buttons">
                    <button id="enable-gyro-btn" class="gyro-permission-btn primary">å•Ÿç”¨</button>
                </div>
            </div>
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ParallaxViewer {
            constructor() {
                // ğŸ­ ä¸‰å±¤ç´šæ¶æ§‹ç³»çµ±
                this.uiLayer = null;           // æœ€ä¸Šå±¤ï¼šUI æ§åˆ¶å…ƒç´ 
                this.loadingLayer = null;      // ä¸­é–“å±¤ï¼šå°é¢åœ–èˆ‡è¼‰å…¥å‹•ç•«
                this.contentLayer = null;      // æœ€ä¸‹å±¤ï¼šä¸»è¦å…§å®¹åœ–å±¤çµ„
                
                // Three.js å ´æ™¯ç³»çµ±
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.loadingScene = null;
                this.loadingCamera = null;
                this.loadingRenderer = null;
                
                // åœ–å±¤ç®¡ç†
                this.layers = [];              // ä¸»è¦å…§å®¹åœ–å±¤ (7_BG~1_RabbitFornt)
                this.mainLayerGroup = null;    // ä¸»è¦åœ–å±¤çµ„å®¹å™¨
                this.dotsGroup = null;         // äº’å‹•é»é»å®¹å™¨
                this.detailGroup1 = null;      // å±€éƒ¨åœ–å®¹å™¨1
                this.detailGroup2 = null;      // å±€éƒ¨åœ–å®¹å™¨2
                this.detailGroup3 = null;      // å±€éƒ¨åœ–å®¹å™¨3
                this.detailLayers = [];        // å±€éƒ¨åœ–å±¤é™£åˆ—
                
                // ğŸ¯ è¦–è§’ç‹€æ…‹ç®¡ç†
                this.viewState = 'main';       // 'main' | 'detail'
                this.currentDetailDot = null;  // ç•¶å‰æ”¾å¤§çš„é»é»
                this.isTransitioning = false;  // æ˜¯å¦æ­£åœ¨éæ¸¡å‹•ç•«ä¸­
                
                // ğŸ¯ ç›¸æ©Ÿè®Šæ›åƒæ•¸
                this.originalCameraPosition = { x: 0, y: 0, z: 5 };
                // targetCameraPosition å°‡åœ¨éœ€è¦æ™‚å‹•æ…‹è¨ˆç®—ï¼Œä¸å†ä½¿ç”¨å›ºå®šå€¼
                this.originalScenePosition = { x: 0, y: 0, z: 0 };
                this.targetScenePosition = { x: 0, y: 0, z: 0 };
                
                // ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶åƒæ•¸
                this.DETAIL_VIEW_INTENSITY = 0.16;    // å±€éƒ¨è¦–è§’ç§»å‹•å¼·åº¦ (å»ºè­°ç¯„åœ: 0.05-0.3)
                this.DETAIL_VIEW_BOUNDARY = 0.26;      // é‚Šç•Œè¶…å‡ºç¯„åœ (ç›¸å°æ–¼åœ–ç‰‡å¤§å°)
                this.detailViewMouse = { x: 0, y: 0 }; // å±€éƒ¨è¦–è§’çš„æ»‘é¼ ä½ç½®
                this.detailViewOffset = { x: 0, y: 0 }; // å±€éƒ¨è¦–è§’çš„åç§»é‡
                
                // ğŸŒŸ å±€éƒ¨åœ–ç¾½åŒ–æ•ˆæœåƒæ•¸
                this.FEATHER_MAIN_VIEW = 5.0;          // ä¸»è¦–è§’ç¾½åŒ–å¼·åº¦ (å»ºè­°ç¯„åœ: 0.5-1.0)
                this.FEATHER_DETAIL_VIEW = 0.1;        // å±€éƒ¨è¦–è§’ç¾½åŒ–å¼·åº¦ (å»ºè­°ç¯„åœ: 0.0-0.3)
                this.FEATHER_TRANSITION_RANGE = 0.5;   // ç¾½åŒ–å½±éŸ¿ç¯„åœ (å»ºè­°ç¯„åœ: 0.2-0.5)
                
                // ğŸŒ«ï¸ éæ¸¡æ¨¡ç³Šæ•ˆæœåƒæ•¸
                this.TRANSITION_BLUR_STRENGTH = 3;      // éæ¸¡æ¨¡ç³Šå¼·åº¦ (0-20ï¼Œå»ºè­°å€¼ï¼š5-15)
                
                // ğŸ” å±€éƒ¨è¦–è§’æ”¾å¤§è¨­å®š
                this.DETAIL_ZOOM_SCALE = 4.5;           // å±€éƒ¨è¦–è§’æ”¾å¤§å€ç‡ (å»ºè­°ç¯„åœ: 2.0-10.0ï¼Œé è¨­5.0=500%)
                this.interactiveDots = [];     // äº’å‹•é»é»é™£åˆ—
                this.raycaster = null;         // é»æ“Šæª¢æ¸¬å™¨
                this.mouseVector = null;       // æ»‘é¼ å‘é‡
                this.mouse = { x: 0, y: 0 };
                this.targetMouse = { x: 0, y: 0 }; // ç›®æ¨™æ»‘é¼ ä½ç½®
                this.currentMouse = { x: 0, y: 0 }; // ç•¶å‰æ’å€¼å¾Œçš„æ»‘é¼ ä½ç½®
                this.mouseInsidePage = true; // æ»‘é¼ æ˜¯å¦åœ¨é é¢å…§
                this.mouseJustReentered = false; // æ»‘é¼ æ˜¯å¦å‰›é‡æ–°é€²å…¥é é¢
                this.mouseVelocity = { x: 0, y: 0 }; // æ»‘é¼ ç§»å‹•é€Ÿåº¦
                this.inertiaTarget = { x: 0, y: 0 }; // æ…£æ€§ç›®æ¨™ä½ç½®
                this.isInertiaActive = false; // æ˜¯å¦æ­£åœ¨åŸ·è¡Œæ…£æ€§ç·©è¡
                this.orientation = { x: 0, y: 0 };
                // ğŸ›ï¸ è¢å¹•æ–¹å‘è‡ªå‹•è½‰æ›æ©Ÿåˆ¶
                this.currentOrientation = this.getScreenOrientation();
                this.initialOrientation = this.currentOrientation; // å„²å­˜åˆå§‹æ–¹å‘
                this.baseX = null;           // çµ±ä¸€çš„Xè»¸åŸºæº–å€¼ï¼ˆä¿ç•™å‘å¾Œç›¸å®¹ï¼‰
                this.baseY = null;           // çµ±ä¸€çš„Yè»¸åŸºæº–å€¼ï¼ˆä¿ç•™å‘å¾Œç›¸å®¹ï¼‰
                
                // æ–°çš„é™€èºå„€åŸºæº–å€¼ï¼ˆåŸå§‹è§’åº¦ï¼‰
                this.baseAlpha = null;       // æ°´å¹³æ—‹è½‰åŸºæº–å€¼
                this.baseBeta = null;        // å‰å¾Œä¿¯ä»°åŸºæº–å€¼  
                this.baseGamma = null;       // å·¦å³å‚¾æ–œåŸºæº–å€¼
                this.smoothedDelta = { x: 0, y: 0 }; // å¹³æ»‘å¾Œçš„å·®å€¼
                this.SMOOTH_ALPHA = 0.15;    // ä½é€šæ¿¾æ³¢ä¿‚æ•¸
                
                // ğŸ® æ··åˆæ§åˆ¶ç³»çµ±
                this.currentControlMode = 'gyro';     // 'gyro' | 'pointer'
                this.gyroActive = false;              // é™€èºå„€æ˜¯å¦å·²å•Ÿç”¨
                this.lastPointerTime = 0;             // æœ€å¾Œæ»‘é¼ æ´»å‹•æ™‚é–“
                this.currentOffsetX = 0;              // ç•¶å‰Xè»¸åç§»
                this.currentOffsetY = 0;              // ç•¶å‰Yè»¸åç§»
                this.controlTransitionProgress = 0;   // æ§åˆ¶æ¨¡å¼åˆ‡æ›é€²åº¦
                this.requiresPermission = false;      // æ˜¯å¦éœ€è¦iOSæˆæ¬Š
                this.isMobile = this.detectMobile();
                this.loadingComplete = false;
                this.loadedImages = 0;
                this.totalImages = 0;
                this.errorCount = 0;
                this.loadingCoverLoaded = false;
                this.coverFadeOutComplete = false;
                this.parallaxTransitionProgress = 0; // 0 = ä¸­å¿ƒä½ç½®, 1 = æ»‘é¼ ä½ç½®
                
                // ğŸ›ï¸ çµ±ä¸€è¦–å·®å¼·åº¦æ§åˆ¶ - èª¿æ•´é€™äº›æ•¸å€¼ä¾†æ”¹è®Šæ•´é«”è¦–å·®æ•ˆæœ
                this.PARALLAX_INTENSITY = 0.27; // ä¸»è¦æ§åˆ¶åƒæ•¸ï¼šæ§åˆ¶æ»‘é¼ /å‚¾æ–œè¼¸å…¥çš„å½±éŸ¿ç¨‹åº¦ (å»ºè­°ç¯„åœ: 0.05-0.3)
                this.DEPTH_SENSITIVITY = 0.5;  // æ·±åº¦åœ–æ•æ„Ÿåº¦ï¼šæ§åˆ¶æ·±åº¦å·®ç•°çš„è¦–å·®å¹…åº¦ (å»ºè­°ç¯„åœ: 0.1-0.5)
                
                // ğŸ“± è¡Œå‹•è£ç½®é™€èºå„€æ§åˆ¶
                this.GYRO_SENSITIVITY = 5.0;    // é™€èºå„€éˆæ•åº¦ï¼šæ§åˆ¶è£ç½®æ—‹è½‰çš„æ•æ„Ÿç¨‹åº¦ (å»ºè­°ç¯„åœ: 0.5-2.0)
                // ç§»é™¤ GYRO_INVERT_Xï¼Œæ”¹ç”¨Î±æ§åˆ¶æ°´å¹³æ—‹è½‰ï¼Œè‹¥éœ€åå‘å¯åœ¨æœ€çµ‚ deltaX å–è² å€¼
                
                // ğŸ–¼ï¸ çµ±ä¸€åœ–ç‰‡å¤§å°æ§åˆ¶
                this.IMAGE_SCALE = 1.02;        // åœ–ç‰‡ç¸®æ”¾æ¯”ä¾‹ï¼šæ§åˆ¶å°é¢åœ–å’Œä¸»åœ–çš„å¤§å° (å»ºè­°ç¯„åœ: 0.5-1.5)
                
                // ğŸ« å‘¼å¸å‹•ç•«æ§åˆ¶
                this.BREATH_SPEED = 0.003;      // å‘¼å¸é€Ÿåº¦ä¿‚æ•¸ï¼šæ•¸å€¼è¶Šå¤§å‘¼å¸è¶Šå¿« (å»ºè­°ç¯„åœ: 0.001-0.005)
                
                // ğŸ¯ è·é›¢æ„Ÿæ‡‰äº’å‹•æ§åˆ¶
                this.DISTANCE_INTERACTION_ENABLED = !this.isMobile;  // æ¡Œæ©Ÿç‰ˆå•Ÿç”¨ï¼Œè¡Œå‹•ç‰ˆé—œé–‰
                this.MAX_DISTANCE = 0.3;                   // æœ€å¤§æ„Ÿæ‡‰è·é›¢ï¼ˆç›¸å°æ–¼ä¸»åœ–å¯¬åº¦ï¼‰
                this.MIN_SCALE_FACTOR = 0.6;               // æœ€é æ™‚çš„æœ€å°ç¸®æ”¾ï¼ˆ60%ï¼‰
                this.MIN_OPACITY_FACTOR = 0.5;             // æœ€é æ™‚çš„æœ€å°é€æ˜åº¦ï¼ˆ50%ï¼‰
                this.DISTANCE_LERP_SPEED = 0.5;            // è·é›¢å‹•ç•«éæ¸¡é€Ÿåº¦
                
                // ğŸ”„ é‡ç½®è¦–è§’åŠŸèƒ½
                this.isResetting = false;                  // æ˜¯å¦æ­£åœ¨é‡ç½®è¦–è§’
                this.lastRawX = 0;                         // æœ€æ–°çš„åŸå§‹Xå€¼
                this.lastRawY = 0;                         // æœ€æ–°çš„åŸå§‹Yå€¼

                /*
                 * ğŸ“– åƒæ•¸èªªæ˜ï¼š
                 * 
                 * PARALLAX_INTENSITY (parallaxOffset çš„ä¹˜æ•¸)ï¼š
                 * - æ§åˆ¶æ»‘é¼ ç§»å‹•æˆ–è£ç½®å‚¾æ–œå°è¦–å·®çš„å½±éŸ¿ç¨‹åº¦
                 * - æ•¸å€¼è¶Šå¤§ï¼Œæ»‘é¼ ç§»å‹•æ™‚è¦–å·®æ•ˆæœè¶Šæ˜é¡¯
                 * - å½±éŸ¿æ•´é«”è¦–å·®çš„"éˆæ•åº¦"
                 * 
                 * DEPTH_SENSITIVITY (parallaxStrength)ï¼š
                 * - æ§åˆ¶æ·±åº¦åœ–ä¸­ä¸åŒç°éšå€¼ä¹‹é–“çš„è¦–å·®å·®ç•°
                 * - æ•¸å€¼è¶Šå¤§ï¼Œæ·±åº¦åœ–çš„ç™½è‰²å’Œé»‘è‰²å€åŸŸè¦–å·®å·®ç•°è¶Šå¤§
                 * - å½±éŸ¿è¦–å·®çš„"æ·±åº¦æ„Ÿ"
                 * 
                 * GYRO_SENSITIVITYï¼š
                 * - æ§åˆ¶è¡Œå‹•è£ç½®é™€èºå„€çš„æ•æ„Ÿç¨‹åº¦
                 * - æ•¸å€¼è¶Šå¤§ï¼Œè£ç½®æ—‹è½‰æ™‚è¦–å·®æ•ˆæœè¶Šæ˜é¡¯
                 * - æ–°ç‰ˆä½¿ç”¨Î±(æ°´å¹³æ—‹è½‰)æ§åˆ¶Xè»¸ï¼ŒÎ²/Î³(ä¿¯ä»°)æ§åˆ¶Yè»¸
                 * 
                 * æ–°ç‰ˆé™€èºå„€æ§åˆ¶èªªæ˜ï¼š
                 * - æ°´å¹³æ—‹è½‰(Î±)ï¼šå·¦å³è½‰èº« â†’ Xè»¸è¦–å·®
                 * - å‰å¾Œä¿¯ä»°(Î²)ï¼šç›´ç«‹æ¨¡å¼ â†’ Yè»¸è¦–å·®
                 * - å·¦å³å‚¾æ–œ(Î³)ï¼šæ©«å‘æ¨¡å¼ â†’ Yè»¸è¦–å·®
                 * 
                 * ğŸ¯ èª¿æ•´å»ºè­°ï¼š
                 * - æƒ³è¦æ›´æ•æ„Ÿçš„æ»‘é¼ æ§åˆ¶ â†’ å¢åŠ  PARALLAX_INTENSITY
                 * - æƒ³è¦æ›´æ•æ„Ÿçš„é™€èºå„€æ§åˆ¶ â†’ å¢åŠ  GYRO_SENSITIVITY
                 * - æƒ³è¦æ›´å¼·çƒˆçš„æ·±åº¦æ•ˆæœ â†’ å¢åŠ  DEPTH_SENSITIVITY  
                 * - æƒ³è¦æ›´ç´°è†©çš„æ•ˆæœ â†’ åŒæ™‚é™ä½æ‰€æœ‰æ•¸å€¼
                 */
                
                // åœ–å±¤è³‡è¨Š - æŒ‰ç…§å¾å¾Œåˆ°å‰çš„é †åºï¼ˆ7æœ€å¾Œé¢ï¼Œ1æœ€å‰é¢ï¼‰
                this.layerInfo = [
                    { name: '0_7_BG' },        // æœ€åº•å±¤èƒŒæ™¯
                    { name: '0_6_RabbitBack' }, // å¾Œæ–¹å…”å­
                    { name: '0_5_Volume' },     // é«”ç©éœ§
                    { name: '0_4_RabbitMain' }, // ä¸»è¦å…”å­
                    { name: '0_3_Text' },       // æ–‡å­—
                    { name: '0_2_Dust' },       // å¡µåŸƒï¼ˆç¾åœ¨åœ¨æ–‡å­—ä¹‹ä¸Šï¼‰
                    { name: '0_1_RabbitFornt' } // æœ€å‰å±¤å…”å­
                ];
                
                // ğŸ” å±€éƒ¨åœ–é…ç½®è³‡æ–™ - èˆ‡é»é»å°æ‡‰
                this.detailLayerInfo = [
                    { name: '1_0_All', dotId: 'dot1', group: 'detailGroup1' },
                    { name: '2_0_All', dotId: 'dot2', group: 'detailGroup2' },
                    { name: '3_0_All', dotId: 'dot3', group: 'detailGroup3' }
                ];
                
                this.init();
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       window.innerWidth <= 768;
            }

            // ğŸ›ï¸ ç°¡åŒ–è¢å¹•æ–¹å‘åµæ¸¬ï¼ˆå¯¦æ™‚æ›´æ–°ï¼‰
            updateScreenOrientation() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const isPortrait = h >= w;
                this.currentOrientation = isPortrait ? 'portrait-primary' : 'landscape-primary';
            }

            // ğŸ›ï¸ è¨ˆç®—æœ€çŸ­è§’åº¦å·®ï¼ˆé¿å…0â†”360è·³å€¼ï¼‰
            shortestAngleDiff(a, b) {
                let diff = (a - b + 540) % 360 - 180; // å–æœ€çŸ­è·¯å¾‘
                return diff;
            }

            // ğŸ›ï¸ ç°¡åŒ–é™€èºå„€æ˜ å°„é‚è¼¯ï¼ˆÎ±æ§åˆ¶æ°´å¹³æ—‹è½‰ï¼‰
            transformGyroData(dAlpha, dBeta, dGamma) {
                let x, y;
                
                if (this.currentOrientation.startsWith('portrait')) {
                    // ç›´ç«‹ï¼šÎ±â†’X, Î²â†’Y
                    x = dAlpha;
                    y = dBeta;
                } else {
                    // æ©«å‘ï¼šÎ±â†’X, Î³â†’Yï¼ˆå–åè½‰é¿å…ä¸Šä¸‹ç›¸åï¼‰
                    x = dAlpha;
                    y = -dGamma;
                }
                
                return { x, y };
            }

            // ğŸ® æª¢æ¸¬æ˜¯å¦éœ€è¦iOSæˆæ¬Š
            checkPermissionRequired() {
                this.requiresPermission = typeof DeviceOrientationEvent !== 'undefined' && 
                                        typeof DeviceOrientationEvent.requestPermission === 'function';
                
                // æª¢æŸ¥æ˜¯å¦å·²ç¶“æˆæ¬Šé
                if (this.requiresPermission) {
                    const hasGranted = localStorage.getItem('gyroPermissionGranted');
                    if (hasGranted === 'true') {
                        console.log('ğŸ“± é™€èºå„€å·²æˆæ¬Šï¼Œç›´æ¥å•Ÿç”¨');
                        return false; // ä¸éœ€è¦é¡¯ç¤ºæˆæ¬Šä»‹é¢
                    }
                }
                
                return this.requiresPermission;
            }

            // ğŸ® å•Ÿå‹•é™€èºå„€æ§åˆ¶
            async startGyroControl() {
                // æª¢æŸ¥æ˜¯å¦éœ€è¦æˆæ¬Š
                if (this.checkPermissionRequired()) {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            console.log('âŒ é™€èºå„€æˆæ¬Šè¢«æ‹’çµ•ï¼Œä½¿ç”¨æ»‘é¼ æ¨¡å¼');
                            this.currentControlMode = 'pointer';
                            return false;
                        }
                        console.log('âœ… é™€èºå„€æˆæ¬ŠæˆåŠŸ');
                        // å„²å­˜æˆæ¬Šç‹€æ…‹åˆ°æœ¬åœ°
                        localStorage.setItem('gyroPermissionGranted', 'true');
                    } catch (error) {
                        console.error('âŒ é™€èºå„€æˆæ¬Šå¤±æ•—:', error);
                        this.currentControlMode = 'pointer';
                        return false;
                    }
                }

                // è¨»å†Šé™€èºå„€äº‹ä»¶
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.gyroUpdate.bind(this));
                    this.gyroActive = true;
                    console.log('ğŸ® é™€èºå„€æ§åˆ¶å·²å•Ÿç”¨');
                    return true;
                }
                
                return false;
            }

            // ğŸ® å•Ÿå‹•æ»‘é¼ æ§åˆ¶
            startPointerControl() {
                if (this.currentControlMode !== 'pointer') {
                    this.currentControlMode = 'pointer';
                    console.log('ğŸ–±ï¸ åˆ‡æ›åˆ°æ»‘é¼ æ§åˆ¶æ¨¡å¼');
                }
                this.lastPointerTime = Date.now();
            }

            // ğŸ® é™€èºå„€æ›´æ–°ï¼ˆæ–°ç‰ˆï¼šä½¿ç”¨åŸå§‹è§’åº¦åŸºæº–ï¼‰
            gyroUpdate(event) {
                if (this.currentControlMode !== 'gyro') return;
                if (this.isResetting) return;   // å‹•ç•«æœŸé–“å®Œå…¨å¿½ç•¥ gyro
                
                // ç²å–åŸå§‹é™€èºå„€æ•¸å€¼
                const alpha = event.alpha || 0;
                const beta = event.beta || 0;
                const gamma = event.gamma || 0;

                // ç¬¬ä¸€æ¬¡é€²ä¾†æ™‚æˆ–æ–¹å‘è®ŠåŒ–å¾Œå»ºç«‹åŸºæº–å€¼
                if (this.baseAlpha === null) {
                    this.baseAlpha = alpha;
                    this.baseBeta = beta;
                    this.baseGamma = gamma;
                    console.log('ğŸ›ï¸ å»ºç«‹åŸå§‹è§’åº¦åŸºæº–å€¼:', {
                        orientation: this.currentOrientation,
                        baseAlpha: this.baseAlpha.toFixed(2),
                        baseBeta: this.baseBeta.toFixed(2),
                        baseGamma: this.baseGamma.toFixed(2)
                    });
                    return; // å»ºåŸºæº–ä¸è¼¸å‡º
                }

                // è¨ˆç®—è§’åº¦å·®å€¼ï¼ˆä½¿ç”¨æœ€çŸ­è·¯å¾‘é¿å…è·³å€¼ï¼‰
                const dAlpha = this.shortestAngleDiff(alpha, this.baseAlpha);
                const dBeta = beta - this.baseBeta;
                const dGamma = gamma - this.baseGamma;

                // æ ¹æ“šè¢å¹•æ–¹å‘è½‰æ›ç‚ºçµ±ä¸€çš„X/Yè»¸
                const { x, y } = this.transformGyroData(dAlpha, dBeta, dGamma);

                // è¨­å®šéˆæ•åº¦èˆ‡ clamp
                let deltaX = THREE.MathUtils.clamp(x / 45 * this.GYRO_SENSITIVITY, -1, 1);
                let deltaY = THREE.MathUtils.clamp(y / 45 * this.GYRO_SENSITIVITY, -1, 1);

                // ä½é€šæ¿¾æ³¢å¹³æ»‘è™•ç†
                this.smoothedDelta.x = this.smoothedDelta.x * (1 - this.SMOOTH_ALPHA) + deltaX * this.SMOOTH_ALPHA;
                this.smoothedDelta.y = this.smoothedDelta.y * (1 - this.SMOOTH_ALPHA) + deltaY * this.SMOOTH_ALPHA;

                // æ›´æ–°ç•¶å‰åç§»å€¼
                this.currentOffsetX = this.smoothedDelta.x;
                this.currentOffsetY = this.smoothedDelta.y;
                
                // ğŸ” èª¿è©¦è³‡è¨Šï¼šæ¯100æ¬¡è¼¸å‡ºä¸€æ¬¡ï¼Œé¿å…éå¤šæ—¥èªŒ
                if (!this.debugCounter) this.debugCounter = 0;
                this.debugCounter++;
                if (this.debugCounter % 100 === 0) {
                    console.log('ğŸ›ï¸ é™€èºå„€èª¿è©¦ (æ–°ç‰ˆ):', {
                        orientation: this.currentOrientation,
                        raw: { alpha: alpha.toFixed(1), beta: beta.toFixed(1), gamma: gamma.toFixed(1) },
                        diff: { dAlpha: dAlpha.toFixed(1), dBeta: dBeta.toFixed(1), dGamma: dGamma.toFixed(1) },
                        transformed: { x: x.toFixed(1), y: y.toFixed(1) },
                        delta: { deltaX: deltaX.toFixed(3), deltaY: deltaY.toFixed(3) },
                        smoothed: { x: this.smoothedDelta.x.toFixed(3), y: this.smoothedDelta.y.toFixed(3) }
                    });
                }
            }

            // ğŸ® æ»‘é¼ æ›´æ–°
            pointerUpdate(x, y) {
                if (this.currentControlMode !== 'pointer') return;
                if (this.isResetting) return; // ğŸ”„ é‡ç½®æœŸé–“ä¸è™•ç†æ»‘é¼ è¼¸å…¥

                // ä½¿ç”¨åŸæœ¬çš„æ»‘é¼ ä½ç½®è¨ˆç®—å…¬å¼ï¼šç”¢ç”Ÿ -1 åˆ° +1 çš„ç¯„åœ
                const newX = (x / window.innerWidth) * 2 - 1;
                const newY = -(y / window.innerHeight) * 2 + 1; // Yè»¸åè½‰

                // æ›´æ–°ç›®æ¨™æ»‘é¼ ä½ç½®ï¼ˆç”¨æ–¼æ’å€¼ç³»çµ±ï¼‰
                this.targetMouse.x = newX;
                this.targetMouse.y = newY;
                
                // ğŸ”§ ä¿®æ­£ï¼šä¸è¦ç›´æ¥æ›´æ–°currentOffsetX/Yï¼Œè®“updateMousePositionè™•ç†æ’å€¼
                // this.currentOffsetX = newX;
                // this.currentOffsetY = newY;
            }

            // ğŸ® æ§åˆ¶æ¨¡å¼ç›£æ§
            monitorControlMode() {
                // ğŸ”„ é‡ç½®æœŸé–“ç¦æ­¢å¼·åˆ¶åˆ‡æ›æ¨¡å¼
                if (this.isResetting) return;
                
                const now = Date.now();
                
                // å¦‚æœæ˜¯æŒ‡é‡æ¨¡å¼ä¸”è¶…é300msç„¡æ´»å‹•ï¼Œåˆ‡å›é™€èºå„€
                if (this.currentControlMode === 'pointer' && 
                    now - this.lastPointerTime > 300 && 
                    this.gyroActive) {
                    this.currentControlMode = 'gyro';
                    console.log('ğŸ”„ è‡ªå‹•åˆ‡æ›å›é™€èºå„€æ§åˆ¶');
                }
                
                // ğŸ“± è¡Œå‹•è£ç½®æŒ‰éˆ•é¡¯ç¤ºé‚è¼¯
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // å…¨è¢å¹•æŒ‰éˆ•åœ¨æ‰€æœ‰è£ç½®éƒ½é¡¯ç¤º
                document.getElementById('fullscreen-button').style.display = 'flex';
                
                // é‡ç½®è¦–è§’æŒ‰éˆ•åªåœ¨è¡Œå‹•è£ç½®ä¸”æ©«å‘æ™‚é¡¯ç¤º
                if (isMobile && isLandscape) {
                    document.getElementById('reset-view-button').style.display = 'flex';
                } else {
                    document.getElementById('reset-view-button').style.display = 'none';
                }
            }

            // çµ±ä¸€çš„åœ–ç‰‡å°ºå¯¸è¨ˆç®—å‡½æ•¸
            calculateImageSize(texture = null) {
                // å¦‚æœæœ‰å‚³å…¥ textureï¼Œä½¿ç”¨å…¶åŸå§‹æ¯”ä¾‹ï¼›å¦å‰‡ä½¿ç”¨é è¨­æ¯”ä¾‹
                let aspectRatio;
                if (texture && texture.image) {
                    aspectRatio = texture.image.width / texture.image.height;
                    // console.log(`ä½¿ç”¨åœ–ç‰‡åŸå§‹æ¯”ä¾‹: ${texture.image.width}x${texture.image.height} (æ¯”ä¾‹: ${aspectRatio.toFixed(3)})`);
                } else {
                    aspectRatio = 1920 / 1080; // æ–°çš„é è¨­æ¯”ä¾‹
                    // console.log(`ä½¿ç”¨é è¨­æ¯”ä¾‹: 1920x1080 (æ¯”ä¾‹: ${aspectRatio.toFixed(3)})`);
                }
                
                const distance = 5;
                const fov = 75 * Math.PI / 180;
                const worldHeight = 2 * Math.tan(fov / 2) * distance;
                const worldWidth = worldHeight * (window.innerWidth / window.innerHeight);
                
                // è¨ˆç®—è¦–çª—é•·å¯¬æ¯”
                const windowAspectRatio = window.innerWidth / window.innerHeight;
                
                let width, height;
                
                // è‡ªå‹•æ¯”è¼ƒè¦–çª—é•·å¯¬æ¯”èˆ‡åœ–ç‰‡é•·å¯¬æ¯”ï¼Œæ±ºå®šä»¥å¯¬åº¦æˆ–é«˜åº¦ç‚ºä¸»
                if (windowAspectRatio >= aspectRatio) {
                    // è¦–çª—æ¯”åœ–ç‰‡å¯¬ï¼ˆæˆ–ç›¸ç­‰ï¼‰ï¼Œä»¥å¯¬åº¦ç‚ºä¸»
                    width = worldWidth * this.IMAGE_SCALE;
                    height = width / aspectRatio;
                } else {
                    // è¦–çª—æ¯”åœ–ç‰‡çª„ï¼Œä»¥é«˜åº¦ç‚ºä¸»
                    height = worldHeight * this.IMAGE_SCALE;
                    width = height * aspectRatio;
                }
                
                return { width, height };
            }

            setupLoadingScene() {
                // å»ºç«‹è¼‰å…¥å ´æ™¯
                this.loadingScene = new THREE.Scene();
                
                // å»ºç«‹è¼‰å…¥ç›¸æ©Ÿ
                this.loadingCamera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.loadingCamera.position.z = 5;
                
                // å»ºç«‹è¼‰å…¥æ¸²æŸ“å™¨
                this.loadingRenderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('loading-canvas'),
                    antialias: true,
                    alpha: true
                });
                
                // ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šè¨­å®šåƒç´ æ¯”ä¾‹
                const maxRatio = 2; // å…¼é¡§æ•ˆèƒ½çš„ä¸Šé™
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.loadingRenderer.setPixelRatio(pixelRatio);
                
                this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // ğŸ“± ç¢ºä¿è¼‰å…¥canvaså…ƒç´ åœ¨DOMä¸­çš„é¡¯ç¤ºå°ºå¯¸æ­£ç¢º
                const loadingCanvas = document.getElementById('loading-canvas');
                if (loadingCanvas) {
                    loadingCanvas.style.width = window.innerWidth + 'px';
                    loadingCanvas.style.height = window.innerHeight + 'px';
                }
                this.loadingRenderer.setClearColor(0x000000, 1);
            }

            loadLoadingCover() {
                console.log('é–‹å§‹è¼‰å…¥å°é¢åœ–ç‰‡...');
                const loader = new THREE.TextureLoader();
                loader.load(
                    'images/Loading.png',
                    (texture) => {
                        console.log('å°é¢åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼Œé–‹å§‹æ·¡å…¥å‹•ç•«');
                        this.createLoadingMesh(texture);
                        this.loadingCoverLoaded = true;
                        
                        // å°é¢åœ–è¼‰å…¥å®Œæˆå¾Œæ‰é–‹å§‹æ·¡å…¥å‹•ç•«
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            // æ·¡å…¥å‹•ç•«å®Œæˆå¾Œé–‹å§‹è¼‰å…¥å…¶ä»–åœ–ç‰‡
                            setTimeout(() => {
                                console.log('å°é¢åœ–æ·¡å…¥å®Œæˆï¼Œé–‹å§‹è¼‰å…¥å…¶ä»–åœ–ç‰‡');
                                this.loadLayers();
                            }, 500); // ç­‰å¾…0.5ç§’æ·¡å…¥å®Œæˆ
                        }, 50); // çŸ­æš«å»¶é²ç¢ºä¿æ¸²æŸ“å®Œæˆ
                    },
                    undefined,
                    (error) => {
                        console.warn('å°é¢åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é»‘è‰²èƒŒæ™¯ä¸¦é–‹å§‹è¼‰å…¥å…¶ä»–åœ–ç‰‡');
                        this.loadingCoverLoaded = true;
                        
                        // å³ä½¿è¼‰å…¥å¤±æ•—ä¹Ÿè¦é–‹å§‹æ·¡å…¥å’Œè¼‰å…¥å…¶ä»–åœ–ç‰‡
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            setTimeout(() => {
                                this.loadLayers();
                            }, 500);
                        }, 50);
                    }
                );
            }

            createLoadingMesh(texture) {
                // ä½¿ç”¨çµ±ä¸€çš„å°ºå¯¸è¨ˆç®—å‡½æ•¸ï¼Œå‚³å…¥ texture ä»¥ç²å–åŸå§‹æ¯”ä¾‹
                const { width, height } = this.calculateImageSize(texture);

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                // å­˜å„² texture å¼•ç”¨ä»¥ä¾¿ resize æ™‚é‡æ–°è¨ˆç®—
                mesh.userData.texture = texture;
                this.loadingScene.add(mesh);
            }

            init() {
                this.setupLoadingScene();
                this.setupScene();
                this.setupEventListeners();
                this.createLoadingParticles(); // å‰µå»ºè¼‰å…¥ç²’å­æ•ˆæœ
                this.randomizeSpinnerRings(); // è¨­å®šéš¨æ©Ÿæ—‹è½‰æ•ˆæœ
                
                // ğŸ›ï¸ åˆå§‹åŒ–è¢å¹•æ–¹å‘åµæ¸¬
                this.updateScreenOrientation();
                
                // ğŸ­ è¨­å®šå±¤ç´šå¼•ç”¨
                this.loadingLayer = this.loadingScene; // è¼‰å…¥å±¤ï¼šThree.js å ´æ™¯
                this.uiLayer = document.getElementById('back-button'); // UIå±¤ï¼šDOM å…ƒç´ 
                
                // ğŸ® åˆå§‹åŒ–æ··åˆæ§åˆ¶ç³»çµ±
                this.initControlSystem();
                
                // ğŸ”„ é‡ç½®è¦–è§’æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
                document.getElementById('reset-view-button').addEventListener('click', this.resetView.bind(this));
                
                this.loadLoadingCover(); // å„ªå…ˆè¼‰å…¥å°é¢åœ–
                this.animate();
            }

            // ğŸ® åˆå§‹åŒ–æ§åˆ¶ç³»çµ±
            async initControlSystem() {
                if (this.isMobile) {
                    // è¡Œå‹•è£ç½®ï¼šæª¢æŸ¥æ˜¯å¦éœ€è¦iOSæˆæ¬Š
                    if (this.checkPermissionRequired()) {
                        console.log('ğŸ“± æª¢æ¸¬åˆ°iOSè£ç½®ï¼Œéœ€è¦é™€èºå„€æˆæ¬Š');
                        // å»¶é²é¡¯ç¤ºï¼Œé¿å…æ“‹ä½è¼‰å…¥å‹•ç•«
                        setTimeout(() => {
                            const gyroPermission = document.getElementById('gyro-permission');
                            gyroPermission.classList.add('show');
                        }, 2000); // 2ç§’å¾Œé¡¯ç¤º
                    } else {
                        // Androidæˆ–å…¶ä»–è£ç½®ï¼šç›´æ¥å•Ÿç”¨é™€èºå„€
                        console.log('ğŸ“± ç›´æ¥å•Ÿç”¨é™€èºå„€æ§åˆ¶');
                        await this.startGyroControl();
                    }
                } else {
                    // æ¡Œé¢è£ç½®ï¼šä½¿ç”¨æ»‘é¼ æ§åˆ¶
                    console.log('ğŸ–¥ï¸ æ¡Œé¢è£ç½®ï¼Œä½¿ç”¨æ»‘é¼ æ§åˆ¶');
                    this.currentControlMode = 'pointer';
                }
            }

            createLoadingParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;

                // å®šç¾©è¼‰å…¥å‹•ç•«çš„é¡è‰²èª¿è‰²æ¿
                const colorPalette = [
                    {
                        bg: '#dc9c3b',
                        rgba: '220, 156, 59'
                    },
                    {
                        bg: '#d1936b', 
                        rgba: '209, 147, 107'
                    },
                    {
                        bg: '#f4e3d4',
                        rgba: '244, 227, 212'
                    }
                ];

                // å‰µå»º 10 å€‹ç²’å­
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // éš¨æ©Ÿé¸æ“‡é¡è‰²
                    const colorIndex = Math.floor(Math.random() * colorPalette.length);
                    const selectedColor = colorPalette[colorIndex];
                    
                    // éš¨æ©Ÿå¤§å° (1-2px)
                    const size = Math.random() * 1.6 + 0.8;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // è¨­å®šèƒŒæ™¯é¡è‰²
                    particle.style.background = selectedColor.bg;
                    
                    // è¨­å®šåŸºç¤ç™¼å…‰æ•ˆæœ
                    particle.style.boxShadow = `
                        0 0 6px rgba(${selectedColor.rgba}, 0.8),
                        0 0 12px rgba(${selectedColor.rgba}, 0.6),
                        0 0 18px rgba(${selectedColor.rgba}, 0.4),
                        0 0 24px rgba(${selectedColor.rgba}, 0.2)
                    `;
                    
                    // éš¨æ©Ÿæ°´å¹³ä½ç½® (10%-90%)ï¼Œé¿å…è²¼é‚Š
                    particle.style.left = (Math.random() * 80 + 10) + '%';
                    
                    // éš¨æ©Ÿé£„æµ®å‹•ç•«å»¶é²å’ŒæŒçºŒæ™‚é–“
                    const floatDelay = Math.random() * 1.5;
                    const floatDuration = Math.random() * 3 + 2.5;
                    
                    // éš¨æ©Ÿç™¼å…‰å‹•ç•«å»¶é²
                    const glowDelay = Math.random() * 0.5;
                    
                    // å‰µå»ºå”¯ä¸€çš„ç™¼å…‰å‹•ç•«åç¨±
                    const glowAnimationName = `particleGlow${i}`;
                    
                    // å‹•æ…‹å‰µå»ºç™¼å…‰å‹•ç•«çš„CSSè¦å‰‡
                    const glowKeyframes = `
                        @keyframes ${glowAnimationName} {
                            0% {
                                box-shadow: 
                                    0 0 6px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 12px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 18px rgba(${selectedColor.rgba}, 0.4),
                                    0 0 24px rgba(${selectedColor.rgba}, 0.2);
                                filter: brightness(1.2);
                            }
                            100% {
                                box-shadow: 
                                    0 0 10px rgba(${selectedColor.rgba}, 1),
                                    0 0 20px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 30px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 40px rgba(${selectedColor.rgba}, 0.3);
                                filter: brightness(1.5);
                            }
                        }
                    `;
                    
                    // å°‡å‹•ç•«è¦å‰‡æ·»åŠ åˆ°é é¢
                    const style = document.createElement('style');
                    style.textContent = glowKeyframes;
                    document.head.appendChild(style);
                    
                    // è¨­å®šè¤‡åˆå‹•ç•«ï¼šé£„æµ® + å€‹åˆ¥ç™¼å…‰
                    particle.style.animation = `
                        particleFloat ${floatDuration}s linear infinite ${floatDelay}s,
                        ${glowAnimationName} 2s ease-in-out infinite alternate ${glowDelay}s
                    `;
                    
                    particlesContainer.appendChild(particle);
                }
            }

            randomizeSpinnerRings() {
                const spinnerRings = document.querySelectorAll('.spinner-ring');
                
                spinnerRings.forEach((ring, index) => {
                    // éš¨æ©Ÿæ—‹è½‰é€Ÿåº¦ (1.5s - 4s)
                    const duration = Math.random() * 2 + 1.5;
                    
                    // éš¨æ©Ÿèµ·å§‹è§’åº¦ (0Â° - 360Â°)
                    const startAngle = Math.random() * 360;
                    
                    // éš¨æ©Ÿæ–¹å‘ (é †æ™‚é‡æˆ–é€†æ™‚é‡)
                    const direction = Math.random() > 0.5 ? 'normal' : 'reverse';
                    
                    // å‰µå»ºå”¯ä¸€çš„æ—‹è½‰å‹•ç•«åç¨±
                    const spinAnimationName = `spinnerSpin${index}`;
                    
                    // å‹•æ…‹å‰µå»ºæ—‹è½‰å‹•ç•«çš„CSSè¦å‰‡
                    const spinKeyframes = `
                        @keyframes ${spinAnimationName} {
                            0% { transform: rotate(${startAngle}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                            100% { transform: rotate(${startAngle + 360}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                        }
                    `;
                    
                    // å°‡å‹•ç•«è¦å‰‡æ·»åŠ åˆ°é é¢
                    const style = document.createElement('style');
                    style.textContent = spinKeyframes;
                    document.head.appendChild(style);
                    
                    // è¨­å®šå‹•ç•«
                    ring.style.animation = `${spinAnimationName} ${duration}s linear infinite`;
                    ring.style.animationDirection = direction;
                });
            }

            // ğŸ”„ é‡ç½®è¦–è§’åŠŸèƒ½
            resetView() {
                // 1. ä¸è¦åœ¨ resetView() è¨­ parallaxFreeze = trueï¼›æ”¹ç‚ºåªå‡çµè¼¸å…¥ï¼š
                this.isResetting = true;  // ä¿ç•™
                // ä¸è¨­ this.parallaxFreeze
                
                // å–ç›®å‰ smoothedDelta ç•¶ä½œ offset èµ·é»
                const startX = this.smoothedDelta.x;
                const startY = this.smoothedDelta.y;
                const duration = 400; // ms
                const startTime = performance.now();
                
                const animate = (now) => {
                    const t = Math.min(1, (now - startTime) / duration);
                    const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // easeInOutQuad
                    const offsetX = THREE.MathUtils.lerp(startX, 0, ease);
                    const offsetY = THREE.MathUtils.lerp(startY, 0, ease);

                    // 3. åœ¨ resetView() çš„å‹•ç•«è¿´åœˆå…§ç›´æ¥å‘¼å« applyMainParallax()ï¼š
                    // å°‡å¹³æ»‘å¾Œçš„ offset ç«‹å³å¥—ä¸Šä¸»è¦–å·®
                    this.applyMainParallax(offsetX, offsetY);

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 1. åœ¨ resetView() å‹•ç•«çµæŸå€æ®µ **ä¸è¦**é‡æ–°è³¦å€¼ baseX / baseYï¼Œ
                        // è€Œæ˜¯æ¸…ç©ºä¸¦ç­‰å¾…ä¸‹ä¸€ç­† gyro äº‹ä»¶è‡ªå‹•é‡å»ºåŸºæº–ï¼š
                        this.currentOffsetX = 0;
                        this.currentOffsetY = 0;
                        this.smoothedDelta = { x: 0, y: 0 };
                        this.baseX = null;        // ä¿ç•™å‘å¾Œç›¸å®¹
                        this.baseY = null;
                        this.baseAlpha = null;    // é‡è¨­è§’åº¦åŸºæº–
                        this.baseBeta = null;
                        this.baseGamma = null;
                        this.isResetting = false;
                        console.log('ğŸ”„ è¦–è§’é‡ç½®å®Œæˆ');
                    }
                };
                
                requestAnimationFrame(animate);
            }

            // æ›´æ–°æ‰€æœ‰åœ–å±¤çš„å°ºå¯¸
            updateAllLayerSizes() {
                // æ›´æ–°è¼‰å…¥å ´æ™¯ä¸­çš„ç¶²æ ¼
                if (this.loadingScene) {
                    this.loadingScene.children.forEach(mesh => {
                        if (mesh.userData.texture) {
                            const { width, height } = this.calculateImageSize(mesh.userData.texture);
                            mesh.geometry.dispose(); // é‡‹æ”¾èˆŠçš„å¹¾ä½•é«”
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        }
                    });
                }

                // æ›´æ–°ä¸»å ´æ™¯ä¸­çš„åœ–å±¤
                this.layers.forEach(layerGroup => {
                    if (layerGroup.userData.mainTexture) {
                        const { width, height } = this.calculateImageSize(layerGroup.userData.mainTexture);
                        
                        layerGroup.children.forEach(mesh => {
                            mesh.geometry.dispose(); // é‡‹æ”¾èˆŠçš„å¹¾ä½•é«”
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        });
                    }
                });

                // ğŸ”´ æ›´æ–°äº’å‹•é»é»çš„ä½ç½®å’Œç¸®æ”¾
                this.updateInteractiveDotsLayout();
                
                // ğŸ” æ›´æ–°å±€éƒ¨åœ–å±¤çš„ä½ç½®å’Œç¸®æ”¾
                this.updateDetailLayersLayout();
            }

            setupScene() {
                // å»ºç«‹å ´æ™¯
                this.scene = new THREE.Scene();
                
                // å»ºç«‹ç›¸æ©Ÿ
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 5;
                
                // å»ºç«‹æ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                
                // ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šè¨­å®šåƒç´ æ¯”ä¾‹
                const maxRatio = 2; // å…¼é¡§æ•ˆèƒ½çš„ä¸Šé™
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.renderer.setPixelRatio(pixelRatio);
                
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // ğŸ“± ç¢ºä¿canvaså…ƒç´ åœ¨DOMä¸­çš„é¡¯ç¤ºå°ºå¯¸æ­£ç¢º
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.width = window.innerWidth + 'px';
                    canvas.style.height = window.innerHeight + 'px';
                }
                this.renderer.setClearColor(0x000000, 1);
                
                // å•Ÿç”¨æ·±åº¦æ¸¬è©¦ä»¥ç¢ºä¿æ­£ç¢ºçš„åœ–å±¤é †åº
                this.renderer.sortObjects = true;
                
                // ğŸ­ å‰µå»ºä¸»è¦åœ–å±¤çµ„å®¹å™¨ (7_BG~1_RabbitFornt)
                this.mainLayerGroup = new THREE.Group();
                this.mainLayerGroup.name = 'MainContentLayers';
                this.scene.add(this.mainLayerGroup);
                
                // ğŸ”´ å‰µå»ºäº’å‹•é»é»å®¹å™¨
                this.dotsGroup = new THREE.Group();
                this.dotsGroup.name = 'InteractiveDots';
                this.scene.add(this.dotsGroup);
                
                // ğŸ” å‰µå»ºå±€éƒ¨åœ–å®¹å™¨
                this.detailGroup1 = new THREE.Group();
                this.detailGroup1.name = 'DetailLayer1';
                this.detailGroup1.renderOrder = 0.08;
                this.scene.add(this.detailGroup1);
                
                this.detailGroup2 = new THREE.Group();
                this.detailGroup2.name = 'DetailLayer2';
                this.detailGroup2.renderOrder = 0.07;
                this.scene.add(this.detailGroup2);
                
                this.detailGroup3 = new THREE.Group();
                this.detailGroup3.name = 'DetailLayer3';
                this.detailGroup3.renderOrder = 0.06;
                this.scene.add(this.detailGroup3);
                
                // è¨­å®šåœ–å±¤çµ„å¼•ç”¨
                this.contentLayer = this.mainLayerGroup;
                console.log('âœ… å¤šå±¤ç´šæ¶æ§‹åˆå§‹åŒ–å®Œæˆ');
                console.log('ğŸ“± UIå±¤: z-index 3000+ (è¿”å›æŒ‰éˆ•ç­‰)');
                console.log('ğŸ¬ è¼‰å…¥å±¤: z-index 2000+ (å°é¢åœ–èˆ‡è¼‰å…¥å‹•ç•«)');
                console.log('ğŸ–¼ï¸ å…§å®¹å±¤: z-index 1000+ (ä¸»è¦åœ–å±¤çµ„)');
                console.log('ğŸ”´ äº’å‹•é»é»: renderOrder 1 (æœ€ä¸Šå±¤)');
                console.log('ğŸ” å±€éƒ¨åœ–å±¤: zè»¸ 0.06~0.08 (dot1:0.06, dot2:0.07, dot3:0.08), depthWrite:false');
                console.log('ğŸ–¼ï¸ ä¸»è¦åœ–å±¤: renderOrder 0 (æœ€ä¸‹å±¤)');
            }

            setupEventListeners() {
                // ğŸ® æ··åˆæ§åˆ¶ç³»çµ±äº‹ä»¶ç›£è½å™¨
                
                // 1. è¢å¹•æ–¹å‘è®ŠåŒ–ç›£è½ï¼ˆæ‰€æœ‰è£ç½®ï¼‰
                const handleOrientationChange = () => {
                    this.updateScreenOrientation(); // å¯¦æ™‚æ›´æ–°æ–¹å‘
                    // é‡è¨­åŸºæº–å€¼ï¼Œé¿å…ç¿»è½‰æ™‚è·³å‹•
                    this.baseX = null;
                    this.baseY = null;
                    this.baseAlpha = null;
                    this.baseBeta = null;
                    this.baseGamma = null;
                    this.smoothedDelta = { x: 0, y: 0 };
                    
                    // ğŸ“± ä¿®æ­£ï¼šè¢å¹•æ–¹å‘è®ŠåŒ–æ™‚å¼·åˆ¶é‡æ–°è¨ˆç®—å®¹å™¨å¤§å°
                    // å»¶é²åŸ·è¡Œï¼Œç¢ºä¿ç€è¦½å™¨å®Œæˆæ–¹å‘è®ŠåŒ–
                    setTimeout(() => {
                        console.log('ğŸ”„ æ–¹å‘è®ŠåŒ–å¾Œé‡æ–°è¨ˆç®—å®¹å™¨å¤§å°');
                        // å¼·åˆ¶è§¸ç™¼resizeäº‹ä»¶è™•ç†é‚è¼¯
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        
                        // ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šé‡æ–°è¨­å®šåƒç´ æ¯”ä¾‹å’Œå¤§å°
                        const maxRatio = 2;
                        const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                        this.renderer.setPixelRatio(pixelRatio);
                        this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // ğŸ“± ç¢ºä¿canvaså…ƒç´ åœ¨DOMä¸­çš„é¡¯ç¤ºå°ºå¯¸æ­£ç¢º
                        const canvas = document.getElementById('canvas');
                        if (canvas) {
                            canvas.style.width = window.innerWidth + 'px';
                            canvas.style.height = window.innerHeight + 'px';
                        }
                        
                        // åŒæ™‚èª¿æ•´è¼‰å…¥å ´æ™¯
                        if (this.loadingCamera && this.loadingRenderer) {
                            this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                            this.loadingCamera.updateProjectionMatrix();
                            this.loadingRenderer.setPixelRatio(pixelRatio);
                            this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                            
                            // ğŸ“± ç¢ºä¿è¼‰å…¥canvaså…ƒç´ åœ¨DOMä¸­çš„é¡¯ç¤ºå°ºå¯¸æ­£ç¢º
                            const loadingCanvas = document.getElementById('loading-canvas');
                            if (loadingCanvas) {
                                loadingCanvas.style.width = window.innerWidth + 'px';
                                loadingCanvas.style.height = window.innerHeight + 'px';
                            }
                        }
                        
                        // é‡æ–°è¨ˆç®—æ‰€æœ‰åœ–å±¤å°ºå¯¸
                        this.updateAllLayerSizes();
                    }, 100); // å»¶é²100msç¢ºä¿æ–¹å‘è®ŠåŒ–å®Œæˆ
                };

                // ç›£è½æ–¹å‘è®ŠåŒ–äº‹ä»¶
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', handleOrientationChange);
                } else {
                    window.addEventListener('orientationchange', handleOrientationChange);
                }

                // 2. æ»‘é¼ /è§¸æ§äº‹ä»¶ï¼ˆæ‰€æœ‰è£ç½®ï¼‰
                document.addEventListener('pointermove', (event) => {
                    // åªæœ‰çœŸå¯¦æ»‘é¼ ç§»å‹•æ‰åˆ‡æ›åˆ°pointeræ¨¡å¼
                    if (event.pointerType === 'mouse' || (!event.pointerType && event.type === 'mousemove')) {
                        this.startPointerControl();
                        
                        // æ›´æ–°æ»‘é¼ ä½ç½®
                        const newX = (event.clientX / window.innerWidth) * 2 - 1;
                        const newY = -(event.clientY / window.innerHeight) * 2 + 1;
                        
                        // è¨ˆç®—æ»‘é¼ ç§»å‹•é€Ÿåº¦ï¼ˆç”¨æ–¼æ…£æ€§æ•ˆæœï¼‰
                        this.mouseVelocity.x = newX - this.targetMouse.x;
                        this.mouseVelocity.y = newY - this.targetMouse.y;
                        
                        this.targetMouse.x = newX;
                        this.targetMouse.y = newY;
                        this.mouseInsidePage = true;
                        this.isInertiaActive = false;
                        
                        // æ›´æ–°pointeråç§»
                        this.pointerUpdate(event.clientX, event.clientY);
                    }
                });

                // 3. æ»‘é¼ é›¢é–‹/é€²å…¥äº‹ä»¶ï¼ˆæ¡Œé¢ç‰ˆæ…£æ€§æ•ˆæœï¼‰
                if (!this.isMobile) {
                    document.addEventListener('mouseleave', () => {
                        this.mouseInsidePage = false;
                        this.mouseJustReentered = false;
                        
                        // å•Ÿå‹•æ…£æ€§ç·©è¡æ•ˆæœ
                        const inertiaMultiplier = 1.5;
                        this.inertiaTarget.x = this.currentMouse.x + this.mouseVelocity.x * inertiaMultiplier;
                        this.inertiaTarget.y = this.currentMouse.y + this.mouseVelocity.y * inertiaMultiplier;
                        this.isInertiaActive = true;
                        
                        console.log('æ»‘é¼ é›¢é–‹é é¢ï¼Œå•Ÿå‹•æ…£æ€§ç·©è¡æ•ˆæœ');
                    });
                    
                    document.addEventListener('mouseenter', () => {
                        if (!this.mouseInsidePage) {
                            this.mouseInsidePage = true;
                            this.mouseJustReentered = true;
                            console.log('æ»‘é¼ é‡æ–°é€²å…¥é é¢ï¼Œé–‹å§‹å¹³æ»‘éæ¸¡åˆ°æ–°ä½ç½®');
                        }
                    });
                }

                // 4. é™€èºå„€äº‹ä»¶ï¼ˆè¡Œå‹•è£ç½®ï¼‰
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.gyroUpdate.bind(this));
                }

                // 5. é™€èºå„€æˆæ¬ŠæŒ‰éˆ•äº‹ä»¶
                const enableGyroBtn = document.getElementById('enable-gyro-btn');
                
                if (enableGyroBtn) {
                    enableGyroBtn.addEventListener('click', async () => {
                        const success = await this.startGyroControl();
                        // ç„¡è«–æˆåŠŸèˆ‡å¦éƒ½éš±è—ä»‹é¢
                        const gyroPermission = document.getElementById('gyro-permission');
                        gyroPermission.classList.remove('show');
                        setTimeout(() => {
                            gyroPermission.style.display = 'none';
                        }, 500); // ç­‰å¾…æ·¡å‡ºå‹•ç•«å®Œæˆ
                        
                        if (!success) {
                            // å¦‚æœæˆæ¬Šå¤±æ•—ï¼Œåˆ‡æ›åˆ°æ»‘é¼ æ¨¡å¼
                            this.currentControlMode = 'pointer';
                            console.log('é™€èºå„€æˆæ¬Šå¤±æ•—ï¼Œä½¿ç”¨æ»‘é¼ æ¨¡å¼');
                        }
                    });
                }

                // è¦–çª—å¤§å°èª¿æ•´
                window.addEventListener('resize', () => {
                    // ğŸ›ï¸ å¯¦æ™‚æ›´æ–°è¢å¹•æ–¹å‘
                    this.updateScreenOrientation();
                    
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    
                    // ğŸ“± é«˜è§£æè¢å¹•æ”¯æ´ï¼šé‡æ–°è¨­å®šåƒç´ æ¯”ä¾‹å’Œå¤§å°
                    const maxRatio = 2;
                    const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                    this.renderer.setPixelRatio(pixelRatio);
                    this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                    
                    // ğŸ“± ç¢ºä¿canvaså…ƒç´ åœ¨DOMä¸­çš„é¡¯ç¤ºå°ºå¯¸æ­£ç¢º
                    const canvas = document.getElementById('canvas');
                    if (canvas) {
                        canvas.style.width = window.innerWidth + 'px';
                        canvas.style.height = window.innerHeight + 'px';
                    }
                    
                    // åŒæ™‚èª¿æ•´è¼‰å…¥å ´æ™¯
                    if (this.loadingCamera && this.loadingRenderer) {
                        this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                        this.loadingCamera.updateProjectionMatrix();
                        this.loadingRenderer.setPixelRatio(pixelRatio);
                        this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // ğŸ“± ç¢ºä¿è¼‰å…¥canvaså…ƒç´ åœ¨DOMä¸­çš„é¡¯ç¤ºå°ºå¯¸æ­£ç¢º
                        const loadingCanvas = document.getElementById('loading-canvas');
                        if (loadingCanvas) {
                            loadingCanvas.style.width = window.innerWidth + 'px';
                            loadingCanvas.style.height = window.innerHeight + 'px';
                        }
                    }

                    // è‡ªå‹•é‡æ–°è¨ˆç®—ä¸¦èª¿æ•´æ‰€æœ‰åœ–å±¤çš„ PlaneGeometry
                    this.updateAllLayerSizes();
                    
                    // ğŸ“± æ›´æ–°æŒ‰éˆ•é¡¯ç¤ºç‹€æ…‹ï¼ˆè¢å¹•æ–¹å‘è®ŠåŒ–æ™‚ï¼‰
                    this.monitorControlMode();
                });
            }

            loadLayers() {
                // åªè¨ˆç®—ä¸»åœ–ï¼Œå› ç‚ºæ·±åº¦åœ–å’Œç™¼å…‰åœ–å¯èƒ½ä¸å­˜åœ¨ï¼ˆå°é¢åœ–ä¸è¨ˆå…¥ï¼‰
                this.totalImages = this.layerInfo.length;
                console.log(`é–‹å§‹è¼‰å…¥ ${this.totalImages} å¼µä¸»è¦åœ–ç‰‡`);
                
                this.layerInfo.forEach((layerData, index) => {
                    this.loadLayer(layerData, index);
                });
            }

            loadLayer(layerData, index) {
                const loader = new THREE.TextureLoader();
                const layerGroup = new THREE.Group();
                
                // è¼‰å…¥ä¸»åœ–
                console.log(`æ­£åœ¨è¼‰å…¥: ${layerData.name}.png`);
                loader.load(
                    `images/${layerData.name}.png`,
                    (mainTexture) => {
                        console.log(`æˆåŠŸè¼‰å…¥ä¸»åœ–: ${layerData.name}.png`);
                        // è¼‰å…¥æ·±åº¦åœ–
                        loader.load(
                            `images/${layerData.name}_depth.png`,
                            (depthTexture) => {
                                // è¼‰å…¥ç™¼å…‰åœ–
                                loader.load(
                                    `images/${layerData.name}_glow.png`,
                                    (glowTexture) => {
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index);
                                        this.onImageLoaded();
                                    },
                                    undefined,
                                    () => {
                                        // ç™¼å…‰åœ–è¼‰å…¥å¤±æ•—ï¼Œåªä½¿ç”¨ä¸»åœ–å’Œæ·±åº¦åœ–
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, null, layerData, index);
                                        this.onImageLoaded();
                                    }
                                );
                            },
                            undefined,
                            (error) => {
                                console.warn(`æ·±åº¦åœ–è¼‰å…¥å¤±æ•—: ${layerData.name}_depth.png`);
                                this.createLayerMesh(layerGroup, mainTexture, null, null, layerData, index);
                                this.onImageLoaded();
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`ä¸»åœ–è¼‰å…¥å¤±æ•—: ${layerData.name}.png`, error);
                        this.onImageLoaded(); // ä¿®æ­£ï¼šè¼‰å…¥å¤±æ•—ä¹Ÿè¦è¨ˆæ•¸
                    }
                );
            }

            createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index) {
                // ä½¿ç”¨çµ±ä¸€çš„å°ºå¯¸è¨ˆç®—å‡½æ•¸ï¼Œå‚³å…¥ mainTexture ä»¥ç²å–åŸå§‹æ¯”ä¾‹
                const { width, height } = this.calculateImageSize(mainTexture);

                // å¦‚æœæœ‰æ·±åº¦åœ–ï¼Œä½¿ç”¨è‡ªå®šç¾© Shader ä¾†å¯¦ç¾åŸºæ–¼æ·±åº¦åœ–çš„è¦–å·®
                if (depthTexture) {
                    const vertexShader = `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;
                    
                    const fragmentShader = `
                        uniform sampler2D mainTexture;
                        uniform sampler2D depthTexture;
                        uniform vec2 parallaxOffset;
                        uniform float parallaxStrength;
                        varying vec2 vUv;
                        
                        void main() {
                            // è®€å–æ·±åº¦åœ–çš„ç°éšå€¼
                            float depth = texture2D(depthTexture, vUv).r;
                            
                            // æ ¹æ“šæ·±åº¦å€¼è¨ˆç®—è¦–å·®åç§» - ä¿®æ­£è¨ˆç®—æ–¹å¼
                            vec2 offset = parallaxOffset * (depth - 0.625) * parallaxStrength;
                            vec2 parallaxUV = vUv + offset;
                            
                            // æª¢æŸ¥æ˜¯å¦è¶…å‡ºé‚Šç•Œ
                            if (parallaxUV.x < 0.0 || parallaxUV.x > 1.0 || parallaxUV.y < 0.0 || parallaxUV.y > 1.0) {
                                // è¶…å‡ºé‚Šç•Œæ™‚ï¼Œä½¿ç”¨åŸå§‹UVå–æ¨£
                                parallaxUV = vUv;
                            }
                            
                            // å–æ¨£ä¸»ç´‹ç†
                            vec4 color = texture2D(mainTexture, parallaxUV);
                            gl_FragColor = color;
                        }
                    `;

                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                    // å»ºç«‹ç™¼å…‰åœ–å±¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰- å¿…é ˆåœ¨ä¸»åœ–å±¤ä¹‹å‰åŠ å…¥
                    if (glowTexture) {
                        console.log(`è¼‰å…¥ç™¼å…‰åœ–å±¤: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                mainTexture: { value: glowTexture },
                                depthTexture: { value: depthTexture },
                                parallaxOffset: { value: new THREE.Vector2(0, 0) },
                                parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                            },
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // é‡è¦ï¼šé¿å…æ·±åº¦è¡çª
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // ç¨å¾®å¾€å¾Œæ”¾ï¼Œåœ¨ä¸»åœ–ä¸‹å±¤
                        layerGroup.add(glowMesh);
                    }

                    // å»ºç«‹ä¸»åœ–å±¤
                    const mainMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            mainTexture: { value: mainTexture },
                            depthTexture: { value: depthTexture },
                            parallaxOffset: { value: new THREE.Vector2(0, 0) },
                            parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                } else {
                    // æ²’æœ‰æ·±åº¦åœ–ï¼Œä½¿ç”¨åŸºæœ¬æè³ª
                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                                                                if (glowTexture) {
                        console.log(`è¼‰å…¥ç™¼å…‰åœ–å±¤ï¼ˆç„¡æ·±åº¦åœ–ï¼‰: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            map: glowTexture,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // é¿å…æ·±åº¦è¡çª
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // åœ¨ä¸»åœ–ä¸‹å±¤
                        layerGroup.add(glowMesh);
                    }

                    const mainMaterial = new THREE.MeshBasicMaterial({
                        map: mainTexture,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                }

                // æ ¹æ“šåœ–å±¤ç·¨è™Ÿè¨­å®šZä½ç½® - ç·¨è™Ÿè¶Šå°è¶Šåœ¨å‰é¢
                const layerNumber = parseInt(layerData.name.split('_')[1]); // å– Main_7_BG ä¸­çš„ "7"
                layerGroup.position.z = (7 - layerNumber) * 0.01; // 1è™Ÿæœ€å‰é¢(z=0.06)ï¼Œ7è™Ÿæœ€å¾Œé¢(z=0)
                layerGroup.userData = {
                    depthTexture: depthTexture,
                    hasDepth: !!depthTexture,
                    mainTexture: mainTexture // å­˜å„²ä¸»ç´‹ç†å¼•ç”¨ä»¥ä¾¿ resize æ™‚é‡æ–°è¨ˆç®—
                };

                this.layers.push(layerGroup);
                this.mainLayerGroup.add(layerGroup); // æ·»åŠ åˆ°ä¸»è¦åœ–å±¤çµ„å®¹å™¨
            }

            onImageLoaded() {
                this.loadedImages++;
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // ğŸŒ«ï¸ ç¢ºä¿åˆå§‹ç‹€æ…‹æ²’æœ‰æ¨¡ç³Šæ•ˆæœ
                    this.resetTransitionBlur();
                    
                    // ğŸ”´ è¼‰å…¥å®Œæˆå¾Œå‰µå»ºäº’å‹•é»é»
                    this.createInteractiveDots();
                    
                    // ğŸ” è¼‰å…¥å±€éƒ¨åœ–å±¤
                    this.loadDetailLayers();
                    
                    // ğŸ“± ç¢ºä¿æ‰€æœ‰åœ–å±¤å°ºå¯¸æ­£ç¢ºï¼ˆè§£æ±ºæ‰‹æ©Ÿåˆå§‹è¼‰å…¥å¤§å°ç•°å¸¸å•é¡Œï¼‰
                    this.updateAllLayerSizes();
                    
                    // è¼‰å…¥å®Œæˆå¾Œï¼Œé–‹å§‹æ·¡å‡ºå°é¢
                    setTimeout(() => {
                        this.startFadeOut();
                    }, 1000); // å»¶é²1ç§’é–‹å§‹æ·¡å‡º
                }
            }

            startFadeOut() {
                const cover = document.getElementById('loading-cover');
                console.log('é–‹å§‹å°é¢æ·¡å‡ºå‹•ç•«');
                
                // ç§»é™¤æ·¡å…¥ class
                cover.classList.remove('fade-in');
                
                // ä½¿ç”¨å…©æ¬¡ requestAnimationFrame ç¢ºä¿æµæš¢æ·¡å‡º
                requestAnimationFrame(() => {       // è®“ç¬¬ä¸€å¹€å‘ˆç¾ opacity:1
                    requestAnimationFrame(() => {     // ç¬¬äºŒå¹€å†åŠ å‹•ç•« class
                        cover.classList.add('fade-out');
                    });
                });
                
                // ç›£è½å‹•ç•«çµæŸäº‹ä»¶
                cover.addEventListener('animationend', () => {
                    cover.style.display = 'none';
                    this.coverFadeOutComplete = true;
                    console.log('å°é¢æ·¡å‡ºå®Œæˆ');
                }, { once: true });
                
                // å°é¢é–‹å§‹æ·¡å‡ºå¾Œ0.5ç§’ï¼Œé–‹å§‹è¼‰å…¥ä¸­å‹•ç•«æ·¡å‡ºå’Œè¦–å·®éæ¸¡
                setTimeout(() => {
                    console.log('é–‹å§‹è¼‰å…¥ä¸­æ·¡å‡ºå’Œè¦–å·®éæ¸¡å‹•ç•«');
                    this.startLoadingFadeOutAndParallaxTransition();
                }, 100); // å°é¢é–‹å§‹æ·¡å‡ºå¾Œ0.5ç§’è§¸ç™¼
                
                // ğŸ”´ å°é¢é–‹å§‹æ·¡å‡ºå¾Œ1ç§’ï¼Œäº’å‹•é»é»æ·¡å…¥
                setTimeout(() => {
                    console.log('ğŸ”´ é–‹å§‹äº’å‹•é»é»æ·¡å…¥å‹•ç•«');
                    this.fadeInInteractiveDots();
                }, 1000); // å°é¢é–‹å§‹æ·¡å‡ºå¾Œ1ç§’è§¸ç™¼
            }

            onImageError() {
                this.errorCount++;
                this.loadedImages++;
                
                // å¦‚æœéŒ¯èª¤å¤ªå¤šï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
                if (this.errorCount >= 3) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error-message').style.display = 'block';
                }
                
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // ğŸŒ«ï¸ ç¢ºä¿åˆå§‹ç‹€æ…‹æ²’æœ‰æ¨¡ç³Šæ•ˆæœ
                    this.resetTransitionBlur();
                    
                    // ğŸ“± ç¢ºä¿æ‰€æœ‰åœ–å±¤å°ºå¯¸æ­£ç¢ºï¼ˆè§£æ±ºæ‰‹æ©Ÿåˆå§‹è¼‰å…¥å¤§å°ç•°å¸¸å•é¡Œï¼‰
                    this.updateAllLayerSizes();
                    
                    document.getElementById('loading').style.display = 'none';
                }
            }

            startLoadingFadeOutAndParallaxTransition() {
                // åˆ†åˆ¥è™•ç†è¼‰å…¥ä¸­å‹•ç•«æ·¡å‡ºå’Œè¦–å·®éæ¸¡
                const loadingFadeDuration = 1000; // è¼‰å…¥ä¸­æ·¡å‡ºï¼š1ç§’
                const parallaxTransitionDuration = 1500; // è¦–å·®éæ¸¡ï¼š1.5ç§’
                
                // é–‹å§‹è¼‰å…¥ä¸­å‹•ç•«çš„æ·¡å‡º
                const loadingElement = document.getElementById('loading');
                loadingElement.classList.add('fade-out');
                
                // 1ç§’å¾Œå®Œå…¨éš±è—è¼‰å…¥ä¸­å…ƒç´ 
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, loadingFadeDuration);
                
                // åŒæ™‚é–‹å§‹è¦–å·®éæ¸¡å‹•ç•«ï¼ˆ1.5ç§’ï¼‰
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / parallaxTransitionDuration, 1);
                    
                    // è‡ªå®šç¾©ç·©å‹•å‡½æ•¸ï¼š70%ç·©é€² + 30%ç·©å‡º
                    let easedProgress;
                    if (progress <= 0.7) {
                        // å‰70%ä½¿ç”¨ç·©é€² (ease-in)
                        const t = progress / 0.7; // å°‡0-0.7æ˜ å°„åˆ°0-1
                        easedProgress = Math.pow(t, 3) * 0.7; // cubic ease-inï¼Œçµæœæ˜ å°„åˆ°0-0.7
                    } else {
                        // å¾Œ30%ä½¿ç”¨ç·©å‡º (ease-out)
                        const t = (progress - 0.7) / 0.3; // å°‡0.7-1æ˜ å°„åˆ°0-1
                        easedProgress = 0.7 + (1 - Math.pow(1 - t, 3)) * 0.3; // cubic ease-outï¼Œçµæœæ˜ å°„åˆ°0.7-1
                    }
                    
                    this.parallaxTransitionProgress = easedProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.parallaxTransitionProgress = 1; // ç¢ºä¿å®Œå…¨éæ¸¡åˆ°æ»‘é¼ ä½ç½®
                    }
                };
                
                animate();
            }

            updateMousePosition() {
                if (this.isMobile) return; // è¡Œå‹•è£ç½®ä¸éœ€è¦æ»‘é¼ æ’å€¼
                
                if (this.mouseInsidePage) {
                    // æ»‘é¼ åœ¨é é¢å…§çš„æ­£å¸¸è·Ÿéš¨é‚è¼¯
                    const deltaX = this.targetMouse.x - this.currentMouse.x;
                    const deltaY = this.targetMouse.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    let dynamicLerpFactor;
                    
                    if (this.mouseJustReentered) {
                        // æ»‘é¼ å‰›é‡æ–°é€²å…¥é é¢ï¼šä½¿ç”¨æ…¢é€Ÿéæ¸¡ï¼ˆ60%ç·©å…¥ï¼Œ40%ç·©å‡ºï¼‰
                        const maxLerpFactor = 0.12;
                        const minLerpFactor = 0.02;
                        dynamicLerpFactor = Math.max(minLerpFactor, maxLerpFactor / (1 + distance * 3.5));
                        
                        // ç•¶è·é›¢è¶³å¤ å°æ™‚ï¼Œåˆ‡æ›åˆ°æ­£å¸¸è·Ÿéš¨æ¨¡å¼
                        if (distance < 0.1) {
                            this.mouseJustReentered = false;
                            console.log('éæ¸¡å®Œæˆï¼Œåˆ‡æ›åˆ°æ­£å¸¸è·Ÿéš¨æ¨¡å¼');
                        }
                    } else {
                        // æ»‘é¼ æ­£å¸¸åœ¨é é¢å…§ç§»å‹•ï¼šä½¿ç”¨å¿«é€Ÿè·Ÿéš¨
                        dynamicLerpFactor = 0.25; // å¿«é€ŸéŸ¿æ‡‰çš„å›ºå®šä¿‚æ•¸
                    }
                    
                    this.currentMouse.x += deltaX * dynamicLerpFactor;
                    this.currentMouse.y += deltaY * dynamicLerpFactor;
                    
                } else if (this.isInertiaActive) {
                    // æ»‘é¼ é›¢é–‹é é¢æ™‚çš„æ…£æ€§ç·©è¡é‚è¼¯
                    const deltaX = this.inertiaTarget.x - this.currentMouse.x;
                    const deltaY = this.inertiaTarget.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // æ…£æ€§ç·©è¡çš„å„ªé›…æ¸›é€Ÿä¿‚æ•¸ï¼ˆåŸºæ–¼è·é›¢çš„å‹•æ…‹æ¸›é€Ÿï¼‰
                    const baseInertiaFactor = 0.025; // åŸºç¤æ¸›é€Ÿä¿‚æ•¸ï¼ˆæ›´æ…¢ï¼‰
                    const distanceBoost = Math.min(distance * 0.8, 0.06); // è·é›¢è¶Šé ï¼Œæ¸›é€Ÿè¶Šæ…¢
                    const inertiaLerpFactor = baseInertiaFactor + distanceBoost;
                    
                    this.currentMouse.x += deltaX * inertiaLerpFactor;
                    this.currentMouse.y += deltaY * inertiaLerpFactor;
                    
                    // æ›´å¯¬é¬†çš„åœæ­¢æ¢ä»¶ï¼Œè®“å‹•ç•«æ›´å„ªé›…åœ°çµæŸ
                    if (distance < 0.005) {
                        this.isInertiaActive = false;
                        console.log('æ…£æ€§ç·©è¡å®Œæˆ');
                    }
                }
                // å…¶ä»–æƒ…æ³ï¼šæ»‘é¼ é›¢é–‹é é¢ä¸”ç„¡æ…£æ€§æ™‚ï¼ŒcurrentMouse ä¿æŒä¸è®Š
                
                // æ›´æ–° mouse ç‚ºç•¶å‰æ’å€¼å¾Œçš„ä½ç½®
                this.mouse.x = this.currentMouse.x;
                this.mouse.y = this.currentMouse.y;
                
                // ğŸ”§ ä¿®æ­£ï¼šåŒæ™‚æ›´æ–°currentOffsetX/Yä»¥ä¾›æ··åˆæ§åˆ¶ç³»çµ±ä½¿ç”¨
                this.currentOffsetX = this.currentMouse.x;
                this.currentOffsetY = this.currentMouse.y;
            }

            updateParallax() {
                if (!this.loadingComplete) return;
                
                // é‡ç½®æœŸé–“ä¸æ›´æ–°è¦–å·®ï¼Œè®“å‹•ç•«è¿´åœˆè™•ç†
                if (this.isResetting) return;

                // æ›´æ–°æ»‘é¼ ä½ç½®æ’å€¼
                this.updateMousePosition();

                // ğŸ® çµ±ä¸€è¼¸å…¥æºï¼šä½¿ç”¨currentOffsetX/Yï¼Œç¢ºä¿è¡Œå‹•è£ç½®å’Œæ»‘é¼ çš„é‚è¼¯ä¸€è‡´
                const inputX = this.currentOffsetX * this.parallaxTransitionProgress;
                const inputY = this.currentOffsetY * this.parallaxTransitionProgress;
                
                // ğŸ”§ ä¿®æ­£ï¼šåœ¨éæ¸¡æœŸé–“å’Œä¸åŒè¦–è§’ä¸‹éƒ½è¦è™•ç†æ»‘é¼ è¼¸å…¥
                if (this.viewState === 'detail' && !this.isTransitioning) {
                    // ğŸ•¹ï¸ ç´”å±€éƒ¨è¦–è§’ï¼šåªæ‡‰ç”¨å±€éƒ¨è¦–è§’æ§åˆ¶
                    this.updateDetailViewControl(inputX, inputY);
                } else if (this.viewState === 'main' && !this.isTransitioning) {
                    // ğŸ–¼ï¸ ç´”ä¸»è¦–è§’ï¼šåªæ‡‰ç”¨ä¸»è¦–å·®æ•ˆæœ
                    this.applyMainParallax(inputX, inputY);
                } else if (this.isTransitioning) {
                    // ğŸ”„ éæ¸¡æœŸé–“ï¼šåŒæ™‚æ‡‰ç”¨å…©ç¨®æ•ˆæœï¼Œä½†æ¬Šé‡ä¸åŒ
                    // é€™å€‹é‚è¼¯æœƒåœ¨å‹•ç•«å‡½æ•¸ä¸­è™•ç†
                    return;
                }
            }

            // ğŸŒ«ï¸ éæ¸¡æ¨¡ç³Šæ•ˆæœæ§åˆ¶æ–¹æ³•
            applyTransitionBlur(progress) {
                // ğŸ”§ ä¸‰æ®µå¼éå°ç¨±æ¨¡ç³Šæ›²ç·šï¼š
                // é€²åº¦ 0.0 â†’ æ¨¡ç³Š 0%
                // é€²åº¦ 0.33 â†’ æ¨¡ç³Š 100%
                // é€²åº¦ 0.66 â†’ æ¨¡ç³Š 25%
                // é€²åº¦ 1.0 â†’ æ¨¡ç³Š 0%
                
                let blurFactor;
                
                if (progress <= 0.33) {
                    // å‰33%ï¼šå¾0%ç·©é€²åˆ°100% (ä½¿ç”¨ease-inæ›²ç·š)
                    const t = progress / 0.33; // æ˜ å°„åˆ°0-1
                    blurFactor = t * t; // quadratic ease-in
                } else if (progress <= 0.66) {
                    // 33%-66%ï¼šå¾100%å¿«é€Ÿä¸‹é™åˆ°25% (ç·šæ€§)
                    const t = (progress - 0.33) / 0.33; // æ˜ å°„åˆ°0-1
                    blurFactor = 1.0 - (t * 0.75); // å¾1.0ä¸‹é™åˆ°0.25
                } else {
                    // 66%-100%ï¼šå¾25%ç·©å‡ºåˆ°0% (ä½¿ç”¨ease-outæ›²ç·š)
                    const t = (progress - 0.66) / 0.34; // æ˜ å°„åˆ°0-1 (0.34 = 1.0 - 0.66)
                    const easeOutT = 1 - Math.pow(1 - t, 2); // quadratic ease-out
                    blurFactor = 0.25 * (1 - easeOutT); // å¾0.25ä¸‹é™åˆ°0
                }
                
                const blurIntensity = blurFactor * this.TRANSITION_BLUR_STRENGTH;
                
                // æ‡‰ç”¨æ¨¡ç³Šåˆ°canvaså…ƒç´ 
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = `blur(${blurIntensity}px)`;
                }
                
                // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                console.log(`ğŸŒ«ï¸ éæ¸¡æ¨¡ç³Š: progress=${progress.toFixed(3)}, factor=${(blurFactor*100).toFixed(1)}%, blur=${blurIntensity.toFixed(2)}px`);
            }
            
            // ğŸŒ«ï¸ é‡ç½®æ¨¡ç³Šæ•ˆæœ
            resetTransitionBlur() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = 'none';
                }
            }
            
            // ğŸ” å‹•æ…‹è¨­å®šå±€éƒ¨è¦–è§’æ”¾å¤§å€ç‡
            setDetailZoomScale(scale) {
                if (scale < 1.0) {
                    console.warn('âš ï¸ æ”¾å¤§å€ç‡ä¸èƒ½å°æ–¼1.0ï¼Œå·²è¨­å®šç‚º1.0');
                    scale = 1.0;
                } else if (scale > 20.0) {
                    console.warn('âš ï¸ æ”¾å¤§å€ç‡ä¸èƒ½å¤§æ–¼20.0ï¼Œå·²è¨­å®šç‚º20.0');
                    scale = 20.0;
                }
                
                this.DETAIL_ZOOM_SCALE = scale;
                console.log(`ğŸ” å±€éƒ¨è¦–è§’æ”¾å¤§å€ç‡å·²è¨­å®šç‚º: ${scale}x (${(scale*100).toFixed(0)}%)`);
            }
            
            // ğŸ” å‹•æ…‹ç²å–ç›®æ¨™ç›¸æ©Ÿä½ç½®
            getTargetCameraPosition() {
                return {
                    x: 0,
                    y: 0,
                    z: this.originalCameraPosition.z / this.DETAIL_ZOOM_SCALE
                };
            }

            // ğŸ”§ æ–°å¢ï¼šç¨ç«‹çš„ä¸»è¦–å·®æ‡‰ç”¨æ–¹æ³•
            applyMainParallax(inputX, inputY) {
                
                this.layers.forEach((layer) => {
                    const userData = layer.userData;
                    
                    if (userData.hasDepth) {
                        // å°æ–¼æœ‰æ·±åº¦åœ–çš„åœ–å±¤ï¼Œæ›´æ–° Shader çš„ parallaxOffset åƒæ•¸
                        layer.children.forEach((mesh) => {
                            if (mesh.material && mesh.material.uniforms) {
                                mesh.material.uniforms.parallaxOffset.value.set(
                                    inputX * this.PARALLAX_INTENSITY, 
                                    inputY * this.PARALLAX_INTENSITY
                                );
                            }
                        });
                    }
                    // æ²’æœ‰æ·±åº¦åœ–çš„åœ–å±¤ä¿æŒéœæ­¢ï¼Œä½ç½®ä¸è®Š
                });

                // ğŸ”´ æ›´æ–°äº’å‹•é»é»çš„è¦–å·®æ•ˆæœ
                this.updateInteractiveDotsParallax(inputX, inputY);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // ğŸ® æ§åˆ¶æ¨¡å¼ç›£æ§
                this.monitorControlMode();
                
                // å¦‚æœè¼‰å…¥å°é¢é‚„åœ¨é¡¯ç¤ºï¼Œæ¸²æŸ“è¼‰å…¥å ´æ™¯
                if (!this.loadingComplete && this.loadingCoverLoaded && this.loadingRenderer) {
                    this.loadingRenderer.render(this.loadingScene, this.loadingCamera);
                }
                
                // æ¸²æŸ“ä¸»å ´æ™¯
                if (this.loadingComplete) {
                    this.updateParallax();
                }
                this.renderer.render(this.scene, this.camera);
            }

            // ğŸ” ================== å±€éƒ¨åœ–ç³»çµ± ==================

            zoomToDetailView(clickedDot) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                this.viewState = 'detail';
                this.currentDetailDot = clickedDot;
                
                // ğŸ•¹ï¸ é‡ç½®å±€éƒ¨è¦–è§’æ§åˆ¶
                this.resetDetailViewControl();
                
                // æ‰¾åˆ°å°æ‡‰çš„å±€éƒ¨åœ–
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === clickedDot.config.id
                );
                
                if (!detailLayer) {
                    console.error(`ğŸ” æ‰¾ä¸åˆ°å°æ‡‰çš„å±€éƒ¨åœ–: ${clickedDot.config.id}`);
                    this.isTransitioning = false;
                    return;
                }
                
                console.log(`ğŸ¯ é–‹å§‹æ”¾å¤§å‹•ç•«åˆ° ${clickedDot.config.id}ï¼Œæ”¾å¤§å€ç‡: ${this.DETAIL_ZOOM_SCALE}x (${(this.DETAIL_ZOOM_SCALE*100).toFixed(0)}%)`);
                
                // è¨ˆç®—ç›®æ¨™ä½ç½® - å°‡å±€éƒ¨åœ–çš„ä¸­å¿ƒç§»å‹•åˆ°ç•«é¢ä¸­å¿ƒ
                const detailMesh = detailLayer.mesh;
                const targetSceneX = -detailMesh.position.x;  // åå‘ç§»å‹•å ´æ™¯
                const targetSceneY = -detailMesh.position.y;
                
                // è¨­å®šå‹•ç•«åƒæ•¸
                const duration = 1500; // 1.5ç§’
                const startTime = Date.now();
                
                // è¨˜éŒ„èµ·å§‹ç‹€æ…‹
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // ç›®æ¨™ç‹€æ…‹ - æ ¹æ“šè¨­å®šçš„æ”¾å¤§å€ç‡è¨ˆç®—ç›¸æ©Ÿä½ç½®
                // æ”¾å¤§å€ç‡ = åˆå§‹è·é›¢ / ç›®æ¨™è·é›¢ï¼Œæ‰€ä»¥ç›®æ¨™è·é›¢ = åˆå§‹è·é›¢ / æ”¾å¤§å€ç‡
                const targetCameraZ = startCameraZ / this.DETAIL_ZOOM_SCALE; // å¯é…ç½®æ”¾å¤§å€ç‡
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ç·©å‹•å‡½æ•¸ï¼šease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // ğŸ”§ éæ¸¡æœŸé–“çš„æ»‘é¼ æ§åˆ¶ï¼šåŒæ™‚æ‡‰ç”¨ä¸»è¦–å·®å’Œå±€éƒ¨è¦–è§’æ§åˆ¶
                    // çµ±ä¸€ä½¿ç”¨currentOffsetX/Yï¼Œç¢ºä¿è¡Œå‹•è£ç½®å’Œæ»‘é¼ çš„é‚è¼¯ä¸€è‡´
                    const rawInputX = this.currentOffsetX;
                    const rawInputY = this.currentOffsetY;
                    
                    // ä¸»è¦–å·®æ¬Šé‡ï¼šå¾1éæ¸¡åˆ°0
                    const mainParallaxWeight = 1.0 - easeProgress;
                    // å±€éƒ¨è¦–è§’æ¬Šé‡ï¼šå¾0éæ¸¡åˆ°1  
                    const detailViewWeight = easeProgress;
                    
                    // è¨ˆç®—æ··åˆçš„å ´æ™¯ä½ç½®
                    let finalSceneX = startSceneX + (targetSceneX - startSceneX) * easeProgress;
                    let finalSceneY = startSceneY + (targetSceneY - startSceneY) * easeProgress;
                    
                    // æ‡‰ç”¨ä¸»è¦–å·®æ•ˆæœï¼ˆæ¬Šé‡éæ¸›ï¼‰
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // æ‡‰ç”¨å±€éƒ¨è¦–è§’æ§åˆ¶ï¼ˆæ¬Šé‡éå¢ï¼‰
                    if (detailViewWeight > 0) {
                        const detailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        const detailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        
                        // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedOffsetX = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetX));
                        const limitedOffsetY = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetY));
                        
                        // ç–ŠåŠ å±€éƒ¨è¦–è§’åç§»
                        finalSceneX += limitedOffsetX;
                        finalSceneY += limitedOffsetY;
                    }
                    
                    // æ›´æ–°ç›¸æ©Ÿä½ç½® (æ”¾å¤§æ•ˆæœ)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // æ›´æ–°å ´æ™¯ä½ç½® (ç§»å‹•åˆ°å±€éƒ¨åœ–ä¸­å¿ƒ + æ»‘é¼ åç§»)
                    this.scene.position.x = finalSceneX;
                    this.scene.position.y = finalSceneY;
                    
                    // ğŸŒŸ å±€éƒ¨åœ–æ·¡å…¥ - åœ¨æ”¾å¤§éç¨‹ä¸­é€æ¼¸é¡¯ç¤ºï¼ŒåŒæ™‚èª¿æ•´ç¾½åŒ–å¼·åº¦
                    if (detailMesh.material.uniforms) {
                        // é€æ˜åº¦éæ¸¡ï¼šä½¿ç”¨ç¨å¿«çš„é€Ÿåº¦ä½†ä¸è¦å¤ªå¿«
                        const targetOpacity = Math.min(1.0, easeProgress * 1.1);
                        detailMesh.material.uniforms.opacity.value = targetOpacity;
                        
                        // ğŸ”§ ä¿®æ­£ç¾½åŒ–éæ¸¡ï¼šä½¿ç”¨ç·šæ€§é€²åº¦è€Œéç·©å‹•é€²åº¦ï¼Œç¢ºä¿å¹³æ»‘éæ¸¡
                        const linearProgress = progress; // ä½¿ç”¨ç·šæ€§é€²åº¦è€ŒéeaseProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_MAIN_VIEW - (linearProgress * featherRange);
                        detailMesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                        // console.log(`ğŸŒŸ ç¾½åŒ–éæ¸¡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // ğŸ”´ é»é»æ·¡å‡ºæ•ˆæœ - æ”¾å¤§æ™‚
                    this.updateDotsTransitionOpacity('zoomIn', progress);
                    
                    // ğŸŒ«ï¸ æ‡‰ç”¨éæ¸¡æ¨¡ç³Šæ•ˆæœ
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // å‹•ç•«å®Œæˆ
                        this.camera.position.z = targetCameraZ;
                        // ğŸ”§ æœ€çµ‚ä½ç½®éœ€è¦åŒ…å«ç•¶å‰çš„å±€éƒ¨è¦–è§’åç§»
                        const finalDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const finalDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        const finalLimitedOffsetX = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetX));
                        const finalLimitedOffsetY = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetY));
                        
                        this.scene.position.x = targetSceneX + finalLimitedOffsetX;
                        this.scene.position.y = targetSceneY + finalLimitedOffsetY;
                        
                        // ğŸŒŸ è¨­å®šæœ€çµ‚ç‹€æ…‹ï¼šå®Œå…¨ä¸é€æ˜ï¼Œç¾½åŒ–æœ€å¼±
                        if (detailMesh.material.uniforms) {
                            detailMesh.material.uniforms.opacity.value = 1.0;
                            detailMesh.material.uniforms.featherStrength.value = this.FEATHER_DETAIL_VIEW;  // å±€éƒ¨è¦–è§’ç¾½åŒ–æœ€å¼±
                        }
                        
                        // ğŸŒ«ï¸ é‡ç½®æ¨¡ç³Šæ•ˆæœ
                        this.resetTransitionBlur();
                        
                        // ğŸ”´ é‡ç½®é»é»é€æ˜åº¦ç‚º0%ï¼ˆå±€éƒ¨è¦–è§’æ™‚å®Œå…¨éš±è—ï¼‰
                        this.resetDotsTransitionOpacity(0.0);
                        
                        this.isTransitioning = false;
                        
                        console.log(`ğŸ¯ æ”¾å¤§å‹•ç•«å®Œæˆï¼Œé€²å…¥å±€éƒ¨è¦–è§’: ${clickedDot.config.id}`);
                    }
                };
                
                animate();
            }

            returnToMainView() {
                if (this.isTransitioning || this.viewState === 'main') return;
                
                this.isTransitioning = true;
                
                // ğŸ•¹ï¸ é‡ç½®å±€éƒ¨è¦–è§’æ§åˆ¶
                this.resetDetailViewControl();
                
                console.log('ğŸ”„ é–‹å§‹è¿”å›ä¸»è¦–è§’å‹•ç•«');
                
                // æ‰¾åˆ°ç•¶å‰çš„å±€éƒ¨åœ–
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === this.currentDetailDot.config.id
                );
                
                // è¨­å®šå‹•ç•«åƒæ•¸
                const duration = 1500; // 1.5ç§’
                const startTime = Date.now();
                
                // è¨˜éŒ„èµ·å§‹ç‹€æ…‹
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // ğŸ”§ åˆ†é›¢èµ·å§‹ä½ç½®çš„åŸºç¤ä½ç½®å’Œæ»‘é¼ åç§»
                const detailMesh = detailLayer.mesh;
                const baseSceneX = -detailMesh.position.x;  // å±€éƒ¨åœ–ä¸­å¿ƒå°æ‡‰çš„åŸºç¤å ´æ™¯ä½ç½®
                const baseSceneY = -detailMesh.position.y;
                const startOffsetX = startSceneX - baseSceneX;  // èµ·å§‹æ™‚çš„æ»‘é¼ åç§»
                const startOffsetY = startSceneY - baseSceneY;
                
                // ç›®æ¨™ç‹€æ…‹ (å›åˆ°åŸå§‹ä½ç½®) - ä½¿ç”¨åˆå§‹ç›¸æ©Ÿä½ç½®
                const targetCameraZ = 5; // å›ºå®šå›åˆ°åˆå§‹ä½ç½®
                const targetSceneX = 0;
                const targetSceneY = 0;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ç·©å‹•å‡½æ•¸ï¼šease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // ğŸ”§ éæ¸¡æœŸé–“çš„æ»‘é¼ æ§åˆ¶ï¼šåŒæ™‚æ‡‰ç”¨å±€éƒ¨è¦–è§’å’Œä¸»è¦–å·®æ§åˆ¶
                    // çµ±ä¸€ä½¿ç”¨currentOffsetX/Yï¼Œç¢ºä¿è¡Œå‹•è£ç½®å’Œæ»‘é¼ çš„é‚è¼¯ä¸€è‡´
                    const rawInputX = this.currentOffsetX;
                    const rawInputY = this.currentOffsetY;
                    
                    // å±€éƒ¨è¦–è§’æ¬Šé‡ï¼šå¾1éæ¸¡åˆ°0
                    const detailViewWeight = 1.0 - easeProgress;
                    // ä¸»è¦–å·®æ¬Šé‡ï¼šå¾0éæ¸¡åˆ°1
                    const mainParallaxWeight = easeProgress;
                    
                    // ğŸ”§ ä¿®æ­£ï¼šè¨ˆç®—åŸºç¤å ´æ™¯ä½ç½®çš„éæ¸¡
                    const baseTransitionX = baseSceneX + (targetSceneX - baseSceneX) * easeProgress;
                    const baseTransitionY = baseSceneY + (targetSceneY - baseSceneY) * easeProgress;
                    
                    // è¨ˆç®—æ··åˆçš„æ»‘é¼ åç§»
                    let finalOffsetX = 0;
                    let finalOffsetY = 0;
                    
                    // æ‡‰ç”¨å±€éƒ¨è¦–è§’æ§åˆ¶ï¼ˆæ¬Šé‡éæ¸›ï¼‰
                    if (detailViewWeight > 0) {
                        const currentDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const currentDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        
                        // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedCurrentOffsetX = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetX));
                        const limitedCurrentOffsetY = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetY));
                        
                        // ğŸ”§ ä¿®æ­£ï¼šå¾èµ·å§‹åç§»å¹³æ»‘éæ¸¡åˆ°0ï¼ˆå›åˆ°ä¸»è¦–è§’ä¸­å¿ƒï¼‰
                        // èµ·å§‹åç§»éš¨è‘—æ¬Šé‡æ¸›å°‘è€Œæ¸›å°‘ï¼Œæœ€çµ‚è®Šç‚º0
                        const transitionOffsetX = startOffsetX * detailViewWeight;
                        const transitionOffsetY = startOffsetY * detailViewWeight;
                        
                        // ç•¶å‰æ»‘é¼ åç§»ä¹Ÿéš¨è‘—æ¬Šé‡æ¸›å°‘è€Œæ¸›å°‘
                        const currentOffsetX = limitedCurrentOffsetX * detailViewWeight;
                        const currentOffsetY = limitedCurrentOffsetY * detailViewWeight;
                        
                        // æ··åˆå…©ç¨®åç§»ï¼Œä½†éƒ½æœƒéš¨è‘—æ¬Šé‡æ¸›å°‘
                        finalOffsetX = transitionOffsetX * 0.3 + currentOffsetX * 0.7;
                        finalOffsetY = transitionOffsetY * 0.3 + currentOffsetY * 0.7;
                    } else {
                        // ğŸ”§ æ¬Šé‡ç‚º0æ™‚ï¼Œåç§»ä¹Ÿæ‡‰è©²ç‚º0ï¼ˆå®Œå…¨å›åˆ°ä¸»è¦–è§’ï¼‰
                        finalOffsetX = 0;
                        finalOffsetY = 0;
                    }
                    
                    // ğŸ”§ ä¿®æ­£ï¼šå ´æ™¯åŸºç¤ä½ç½®å¹³æ»‘éæ¸¡åˆ°(0,0)
                    const sceneBaseX = baseTransitionX + finalOffsetX;
                    const sceneBaseY = baseTransitionY + finalOffsetY;
                    
                    // æ›´æ–°ç›¸æ©Ÿä½ç½® (ç¸®å°æ•ˆæœ)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // ğŸ”§ è¨­å®šå ´æ™¯åŸºç¤ä½ç½®
                    this.scene.position.x = sceneBaseX;
                    this.scene.position.y = sceneBaseY;
                    
                    // ğŸ”§ åœ¨å ´æ™¯åŸºç¤ä½ç½®ä¹‹ä¸Šæ‡‰ç”¨ä¸»è¦–å·®æ•ˆæœï¼ˆæ¬Šé‡éå¢ï¼‰
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // ğŸŒŸ å±€éƒ¨åœ–æ·¡å‡º - åŒæ™‚èª¿æ•´ç¾½åŒ–å¼·åº¦
                    if (detailLayer && detailLayer.mesh.material.uniforms) {
                        detailLayer.mesh.material.uniforms.opacity.value = 1.0 - easeProgress;
                        
                        // ğŸ”§ ä¿®æ­£ç¾½åŒ–éæ¸¡ï¼šä½¿ç”¨ç·šæ€§é€²åº¦ç¢ºä¿å¹³æ»‘éæ¸¡
                        const linearProgress = progress; // ä½¿ç”¨ç·šæ€§é€²åº¦è€ŒéeaseProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_DETAIL_VIEW + (linearProgress * featherRange);
                        detailLayer.mesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                        // console.log(`ğŸŒŸ ç¾½åŒ–éæ¸¡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // ğŸ”´ é»é»æ·¡å…¥æ•ˆæœ - ç¸®å°æ™‚
                    this.updateDotsTransitionOpacity('zoomOut', progress);
                    
                    // ğŸŒ«ï¸ æ‡‰ç”¨éæ¸¡æ¨¡ç³Šæ•ˆæœ
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // å‹•ç•«å®Œæˆ
                        this.camera.position.z = targetCameraZ;
                        
                        // ğŸ”§ å ´æ™¯ä½ç½®å·²ç¶“åœ¨å‹•ç•«éç¨‹ä¸­å¹³æ»‘éæ¸¡åˆ°ç›®æ¨™ä½ç½®(0,0)
                        // ä¸éœ€è¦å†æ¬¡è¨­å®šï¼Œé¿å…çªè·³
                        // this.scene.position.x = targetSceneX;
                        // this.scene.position.y = targetSceneY;
                        
                        // ğŸ”§ ç¢ºä¿æœ€çµ‚ç‹€æ…‹ï¼šå ´æ™¯ä½ç½®ç‚º(0,0)ï¼Œä¸»è¦–å·®æ•ˆæœç–ŠåŠ 
                        this.scene.position.x = 0;
                        this.scene.position.y = 0;
                        const finalMainInputX = rawInputX * this.parallaxTransitionProgress;
                        const finalMainInputY = rawInputY * this.parallaxTransitionProgress;
                        this.applyMainParallax(finalMainInputX, finalMainInputY);
                        
                        // ğŸŒŸ é‡ç½®å±€éƒ¨åœ–ç‹€æ…‹ï¼šé€æ˜åº¦ç‚º0ï¼Œç¾½åŒ–å¼·åº¦æœ€å¼·
                        if (detailLayer && detailLayer.mesh.material.uniforms) {
                            detailLayer.mesh.material.uniforms.opacity.value = 0.0;
                            detailLayer.mesh.material.uniforms.featherStrength.value = this.FEATHER_MAIN_VIEW;  // ä¸»è¦–è§’ç¾½åŒ–æœ€å¼·
                        }
                        
                        // ğŸŒ«ï¸ é‡ç½®æ¨¡ç³Šæ•ˆæœ
                        this.resetTransitionBlur();
                        
                        // ğŸ”´ é‡ç½®é»é»é€æ˜åº¦ç‚º100%ï¼ˆä¸»è¦–è§’æ™‚å®Œå…¨é¡¯ç¤ºï¼‰
                        this.resetDotsTransitionOpacity(1.0);
                        
                        // é‡ç½®ç‹€æ…‹
                        this.viewState = 'main';
                        this.currentDetailDot = null;
                        this.isTransitioning = false;
                        
                        console.log('ğŸ”„ è¿”å›ä¸»è¦–è§’å‹•ç•«å®Œæˆ');
                    }
                };
                
                animate();
            }

            loadDetailLayers() {
                console.log('ğŸ” é–‹å§‹è¼‰å…¥å±€éƒ¨åœ–å±¤');
                
                this.detailLayerInfo.forEach((detailInfo, index) => {
                    this.loadDetailLayer(detailInfo, index);
                });
            }

            loadDetailLayer(detailInfo, index) {
                const loader = new THREE.TextureLoader();
                
                console.log(`ğŸ” æ­£åœ¨è¼‰å…¥å±€éƒ¨åœ–: ${detailInfo.name}.png`);
                loader.load(
                    `images/${detailInfo.name}.png`,
                    (texture) => {
                        console.log(`ğŸ” æˆåŠŸè¼‰å…¥å±€éƒ¨åœ–: ${detailInfo.name}.png`);
                        this.createDetailLayerMesh(texture, detailInfo, index);
                    },
                    undefined,
                    (error) => {
                        console.error(`ğŸ” å±€éƒ¨åœ–è¼‰å…¥å¤±æ•—: ${detailInfo.name}.png`, error);
                    }
                );
            }

            createDetailLayerMesh(texture, detailInfo, index) {
                // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨ä¸»åœ–å±¤çš„å°ºå¯¸ä½œç‚ºåŸºæº–ï¼Œè€Œä¸æ˜¯å±€éƒ¨åœ–è‡ªå·±çš„å°ºå¯¸
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) {
                    console.error('ğŸ” ç„¡æ³•ç²å–ä¸»åœ–å±¤å°ºå¯¸ï¼Œå±€éƒ¨åœ–å»ºç«‹å¤±æ•—');
                    return;
                }
                
                const { width: mainWidth, height: mainHeight } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // ğŸ”§ å»ºç«‹èˆ‡ä¸»åœ–å±¤ç›¸åŒå¤§å°çš„å¹¾ä½•é«”ï¼Œç¨å¾Œç”¨ç¸®æ”¾æ§åˆ¶å¯¦éš›å¤§å°
                const geometry = new THREE.PlaneGeometry(mainWidth, mainHeight);
                
                // ğŸŒŸ å»ºç«‹å…·æœ‰é‚Šç·£ç¾½åŒ–æ•ˆæœçš„è‡ªå®šç¾©Shaderæè³ª
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform sampler2D mainTexture;
                    uniform float opacity;
                    uniform float featherStrength;  // ç¾½åŒ–å¼·åº¦ (0.0-1.0)
                    uniform float featherRange;     // ç¾½åŒ–å½±éŸ¿ç¯„åœ (0.0-1.0)
                    varying vec2 vUv;
                    
                    void main() {
                        // å–æ¨£ä¸»ç´‹ç†
                        vec4 color = texture2D(mainTexture, vUv);
                        
                        // è¨ˆç®—åˆ°é‚Šç·£çš„è·é›¢
                        vec2 center = vec2(0.5, 0.5);
                        vec2 edgeDistance = abs(vUv - center) * 2.0;  // è½‰æ›ç‚º0-1ç¯„åœ
                        float maxEdgeDistance = max(edgeDistance.x, edgeDistance.y);
                        
                        // ç¾½åŒ–è¨ˆç®—ï¼šå¾é‚Šç·£é–‹å§‹æ·¡åŒ–
                        float actualFeatherRange = featherStrength * featherRange;  // å¯¦éš›ç¾½åŒ–ç¯„åœ
                        float featherStart = 1.0 - actualFeatherRange;              // ç¾½åŒ–é–‹å§‹ä½ç½®
                        float featherEnd = 1.0;                                     // ç¾½åŒ–çµæŸä½ç½®ï¼ˆé‚Šç·£ï¼‰
                        
                        float edgeAlpha = 1.0;
                        if (maxEdgeDistance > featherStart && actualFeatherRange > 0.0) {
                            // åœ¨ç¾½åŒ–å€åŸŸå…§ï¼Œè¨ˆç®—é€æ˜åº¦æ¼¸è®Š
                            float featherProgress = (maxEdgeDistance - featherStart) / (featherEnd - featherStart);
                            // ä½¿ç”¨æ›´å¹³æ»‘çš„æ›²ç·š
                            edgeAlpha = 1.0 - smoothstep(0.0, 1.0, featherProgress * featherProgress);
                        }
                        
                        // æœ€çµ‚é€æ˜åº¦ = æè³ªé€æ˜åº¦ Ã— é‚Šç·£é€æ˜åº¦
                        color.a *= opacity * edgeAlpha;
                        
                        gl_FragColor = color;
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        mainTexture: { value: texture },
                        opacity: { value: 0.0 },  // åˆå§‹é€æ˜åº¦ç‚º0
                        featherStrength: { value: this.FEATHER_MAIN_VIEW },  // åˆå§‹ç¾½åŒ–å¼·åº¦ï¼šä¸»è¦–è§’æ™‚æœ€å¼·
                        featherRange: { value: this.FEATHER_TRANSITION_RANGE }  // ç¾½åŒ–å½±éŸ¿ç¯„åœ
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false  // ğŸ”§ é—œéµä¿®æ­£ï¼šé¿å…é€æ˜ç‰©ä»¶å¯«å…¥æ·±åº¦ç·©è¡å€é€ æˆé®æ“‹
                });
                
                // å»ºç«‹ç¶²æ ¼
                const mesh = new THREE.Mesh(geometry, material);
                
                // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨é»é»é…ç½®ç›´æ¥è¨ˆç®—ä½ç½®ï¼Œç¢ºä¿åæ¨™ç³»çµ±å®Œå…¨ä¸€è‡´
                const correspondingDot = this.interactiveDots.find(dot => 
                    dot.config.id === detailInfo.dotId
                );
                
                if (correspondingDot) {
                    // ğŸ”§ ä¿®æ­£ï¼šèˆ‡é»é»ç›¸åŒçš„åæ¨™è¨ˆç®—é‚è¼¯
                    const x = (correspondingDot.config.x - 0.5) * mainWidth;
                    const y = (0.5 - correspondingDot.config.y) * mainHeight; // Yè»¸ç¿»è½‰
                    
                    mesh.position.x = x;
                    mesh.position.y = y;
                    // ğŸ”§ Zè»¸ä½ç½®ï¼šç¾åœ¨æœ‰äº†depthWrite: falseï¼Œé †åºä¸å†é‡è¦
                    mesh.position.z = 0.06 + index * 0.01; // Zè»¸ä½ç½® 0.06~0.08 (index 0,1,2 å°æ‡‰ 0.06,0.07,0.08)
                    
                    console.log(`ğŸ” å±€éƒ¨åœ– ${detailInfo.name} ä½ç½®è¨­å®šç‚ºèˆ‡é»é» ${detailInfo.dotId} ç›¸åŒçš„è¨ˆç®—çµæœ:`, 
                               `(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
                } else {
                    console.warn(`ğŸ” æ‰¾ä¸åˆ°å°æ‡‰çš„é»é»: ${detailInfo.dotId}`);
                    mesh.position.z = 0.06 + index * 0.01;
                }
                
                // è¨­å®šåˆå§‹ç¸®æ”¾25%
                mesh.scale.setScalar(0.25);
                
                // å„²å­˜ç›¸é—œè³‡è¨Š
                mesh.userData = {
                    isDetailLayer: true,
                    detailInfo: detailInfo,
                    originalTexture: texture,  // å±€éƒ¨åœ–æœ¬èº«çš„ç´‹ç†
                    mainTexture: firstLayer.userData.mainTexture,  // ğŸ”§ æ–°å¢ï¼šä¸»åœ–å±¤ç´‹ç†å¼•ç”¨ï¼Œç”¨æ–¼å°ºå¯¸è¨ˆç®—
                    baseScale: 0.25,
                    dotId: detailInfo.dotId
                };
                
                // æ·»åŠ åˆ°å°æ‡‰çš„åœ–å±¤çµ„
                const targetGroup = this[detailInfo.group];
                if (targetGroup) {
                    targetGroup.add(mesh);
                    console.log(`ğŸ” å±€éƒ¨åœ– ${detailInfo.name} å·²æ·»åŠ åˆ° ${detailInfo.group}`);
                } else {
                    console.error(`ğŸ” æ‰¾ä¸åˆ°ç›®æ¨™åœ–å±¤çµ„: ${detailInfo.group}`);
                }
                
                // æ·»åŠ åˆ°å±€éƒ¨åœ–å±¤é™£åˆ—
                this.detailLayers.push({
                    mesh: mesh,
                    group: targetGroup,
                    detailInfo: detailInfo,
                    isVisible: true,
                    basePosition: {
                        x: mesh.position.x,
                        y: mesh.position.y,
                        z: mesh.position.z
                    }
                });
            }

            updateDetailLayersLayout() {
                // ç•¶è¦–çª—å¤§å°æ”¹è®Šæ™‚ï¼Œæ›´æ–°å±€éƒ¨åœ–å±¤ä½ç½®å’Œå°ºå¯¸
                if (!this.detailLayers.length || !this.interactiveDots.length) return;
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸ç”¨æ–¼è¨ˆç®—
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                this.detailLayers.forEach(detailLayer => {
                    const correspondingDot = this.interactiveDots.find(dot => 
                        dot.config.id === detailLayer.detailInfo.dotId
                    );
                    
                    if (correspondingDot) {
                        // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨èˆ‡é»é»ç›¸åŒçš„åæ¨™è¨ˆç®—é‚è¼¯ï¼Œç¢ºä¿å®Œå…¨ä¸€è‡´
                        const x = (correspondingDot.config.x - 0.5) * width;
                        const y = (0.5 - correspondingDot.config.y) * height; // Yè»¸ç¿»è½‰
                        
                        detailLayer.mesh.position.x = x;
                        detailLayer.mesh.position.y = y;
                        
                        // ğŸ”§ ä¿®æ­£ï¼šæ›´æ–°å¹¾ä½•é«”å°ºå¯¸ä»¥åŒ¹é…ä¸»åœ–å±¤
                        detailLayer.mesh.geometry.dispose(); // é‡‹æ”¾èˆŠçš„å¹¾ä½•é«”
                        detailLayer.mesh.geometry = new THREE.PlaneGeometry(width, height);
                        
                        // æ›´æ–°åŸºç¤ä½ç½®è¨˜éŒ„
                        detailLayer.basePosition.x = x;
                        detailLayer.basePosition.y = y;
                        
                        console.log(`ğŸ” æ›´æ–°å±€éƒ¨åœ– ${detailLayer.detailInfo.name} ä½ç½®åˆ° (${x.toFixed(2)}, ${y.toFixed(2)})ï¼Œå°ºå¯¸: ${width.toFixed(1)}x${height.toFixed(1)}`);
                    }
                });
            }

            // ğŸ”´ ================== äº’å‹•é»é»ç³»çµ± ==================

            createInteractiveDots() {
                console.log('ğŸ”´ é–‹å§‹å‰µå»ºäº’å‹•é»é»');
                
                // é»é»é…ç½®è³‡æ–™ - ä½ç½®ä»¥ç™¾åˆ†æ¯”è¡¨ç¤º (0-1)
                const dotsConfig = [
                    { id: 'dot1', x: 0.6385, y: 0.394, depth: 0.56 },
                    { id: 'dot2', x: 0.486, y: 0.647, depth: 0.57 },
                    { id: 'dot3', x: 0.71, y: 0.628, depth: 0.65 }
                ];

                // ç‚ºæ¯å€‹é»å‰µå»ºç¶²æ ¼
                dotsConfig.forEach((config, index) => {
                    const dot = this.createDotMesh(config);
                    this.interactiveDots.push({
                        mesh: dot,
                        config: config,
                        originalPosition: { x: config.x, y: config.y },
                        basePosition: { x: 0, y: 0 }, // åŸºç¤ä½ç½®ï¼ˆä¸å«è¦–å·®ï¼‰
                        isHovered: false,
                        hoverMultiplier: 1.0,         // hoveré€æ˜åº¦ä¹˜æ•¸
                        isPressed: false,             // æ˜¯å¦è¢«æŒ‰ä¸‹
                        pressedScale: 1.0,            // æŒ‰ä¸‹ç‹€æ…‹çš„ç¸®æ”¾
                        // è·é›¢äº’å‹•ç›¸é—œ
                        mouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // æ»‘é¼ è·é›¢ä¿‚æ•¸ (0=æœ€è¿‘, 1=æœ€é /è¶…å‡ºç¯„åœ)
                        targetMouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // ç›®æ¨™è·é›¢ä¿‚æ•¸
                        distanceScale: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_SCALE_FACTOR : 1.0,      // åŸºæ–¼è·é›¢çš„ç¸®æ”¾ä¿‚æ•¸
                        distanceOpacity: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_OPACITY_FACTOR : 1.0,   // åŸºæ–¼è·é›¢çš„é€æ˜åº¦ä¿‚æ•¸
                        // ğŸŒ«ï¸ éæ¸¡å‹•ç•«ç›¸é—œ
                        transitionOpacity: 1.0  // éæ¸¡å‹•ç•«é€æ˜åº¦ä¹˜æ•¸ (æ”¾å¤§ç¸®å°æ™‚çš„æ·¡å‡ºæ·¡å…¥)
                    });
                    this.dotsGroup.add(dot);
                });

                // è¨­å®šé»é»å®¹å™¨çš„æ¸²æŸ“é †åº
                this.dotsGroup.renderOrder = 1; // æ¯”ä¸»åœ–å±¤çµ„(0)é«˜ï¼Œæ¯”è¼‰å…¥å±¤ä½
                
                // åˆå§‹åŒ–é»é»å¸ƒå±€
                this.updateInteractiveDotsLayout();
                
                // è¨­å®šé»æ“Šäº‹ä»¶
                this.setupDotInteractions();
                
                console.log(`âœ… æˆåŠŸå‰µå»º ${this.interactiveDots.length} å€‹äº’å‹•é»é»`);
            }

            createDotMesh(config) {
                // å‰µå»ºå…·æœ‰é™°å½±æ•ˆæœçš„äº’å‹•é»é»æè³ª
                const canvas = document.createElement('canvas');
                const size = 128; // å¢åŠ ç•«å¸ƒå¤§å°ä»¥å®¹ç´æ›´å¤§çš„é™°å½±
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                const outerRadius = size * 0.2; // èª¿æ•´é»é»å¤§å°æ¯”ä¾‹
                const innerRadius = size * 0.1;  
                const shadowRadius = size * 0.32;  // é™°å½±ç¯„åœ
                
                // æ¸…é™¤ç•«å¸ƒ
                ctx.clearRect(0, 0, size, size);
                
                // ç¹ªè£½å¤§ç¯„åœæ“´æ•£é™°å½± - å¾ä¸­å¿ƒå‘å¤–æ¨¡ç³Š
                const shadowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, shadowRadius);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');     // ä¸­å¿ƒè¼ƒæ·±
                shadowGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.25)');  // æ¼¸è®Š
                shadowGradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');   // æ›´æ·¡
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');       // é‚Šç·£é€æ˜
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, shadowRadius, 0, Math.PI * 2);
                ctx.fillStyle = shadowGradient;
                ctx.fill();
                
                // è¨­å®šé»é»æœ¬èº«çš„é™°å½±æ•ˆæœ
                ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 2;
                
                // ç¹ªè£½å¤–åœˆ - åŠé€æ˜é‚Šæ¡†
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // é‡ç½®é™°å½±
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // ç¹ªè£½å…§åœˆ - å¯¦å¿ƒä¸­å¿ƒ
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                
                // å…§åœˆæ¼¸è®Šå¡«å……
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                innerGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)');
                
                ctx.fillStyle = innerGradient;
                ctx.fill();
                
                // æ·»åŠ ç²¾ç´°çš„ç™½è‰²å…‰æšˆæ•ˆæœ
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius + 3, 0, Math.PI * 2);
                const glowGradient = ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, outerRadius + 3);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // å‰µå»ºç´‹ç†
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // å‰µå»ºæè³ª
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,  // åˆå§‹ç‚ºé€æ˜ï¼Œç­‰å¾…æ·¡å…¥
                    blending: THREE.NormalBlending
                });
                
                // è¨ˆç®—é»é»å¤§å° - ä½¿ç”¨èˆ‡ä¸»åœ–ç›¸åŒçš„ç¸®æ”¾é‚è¼¯
                let dotSize;
                if (this.layers.length > 0 && this.layers[0].userData.mainTexture) {
                    // ç²å–ä¸»åœ–çš„å°ºå¯¸
                    const { width, height } = this.calculateImageSize(this.layers[0].userData.mainTexture);
                    // é»é»å¤§å°è¨­ç‚ºä¸»åœ–è¼ƒå°é‚Šçš„ 1/35ï¼Œä¿æŒèˆ‡ä¸»åœ–çš„è¦–è¦ºæ¯”ä¾‹
                    dotSize = Math.min(width, height) * 0.05;
                } else {
                    // å¦‚æœä¸»åœ–é‚„æ²’è¼‰å…¥ï¼Œä½¿ç”¨é è¨­å¤§å°
                    dotSize = 0.32;
                }
                
                // å‰µå»ºå¹¾ä½•é«” - ä½¿ç”¨è¨ˆç®—å‡ºçš„å¤§å°
                const geometry = new THREE.PlaneGeometry(dotSize, dotSize);
                
                // å‰µå»ºç¶²æ ¼
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    isDot: true,
                    dotId: config.id,
                    depthValue: config.depth,
                    baseOpacity: 0.85, // ç¨é«˜çš„åŸºç¤é€æ˜åº¦ç¢ºä¿å¯è¦‹æ€§
                    isVisible: false,
                    baseSize: dotSize // å­˜å„²åŸºç¤å¤§å°ä»¥ä¾¿å¾ŒçºŒèª¿æ•´
                };
                
                return mesh;
            }

            updateInteractiveDotsLayout() {
                if (!this.layers.length || !this.interactiveDots.length) return;
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸ï¼ˆä½¿ç”¨ç¬¬ä¸€å€‹åœ–å±¤çš„ä¸»ç´‹ç†ï¼‰
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // æ›´æ–°æ¯å€‹é»çš„åŸºç¤ä½ç½®å’Œå¤§å°
                this.interactiveDots.forEach(dotData => {
                    const { config } = dotData;
                    
                    // è¨ˆç®—åœ¨ä¸»åœ–ç¯„åœå…§çš„ä½ç½®
                    // relativeX/Y å¾ 0~1 è½‰æ›ç‚º -width/2 ~ +width/2 çš„åº§æ¨™
                    const x = (config.x - 0.5) * width;
                    const y = (0.5 - config.y) * height; // Yè»¸ç¿»è½‰
                    
                    dotData.basePosition.x = x;
                    dotData.basePosition.y = y;
                    dotData.mesh.position.x = x;
                    dotData.mesh.position.y = y;
                    dotData.mesh.position.z = 0.1; // ç¢ºä¿åœ¨ä¸»åœ–å±¤ä¹‹ä¸Š
                    
                    // é‡æ–°è¨ˆç®—é»é»å¤§å°
                    const dotSize = Math.min(width, height) * 0.028;
                    dotData.mesh.userData.baseSize = dotSize;
                    
                    // æ›´æ–°å¹¾ä½•é«”å¤§å°
                    dotData.mesh.geometry.dispose();
                    dotData.mesh.geometry = new THREE.PlaneGeometry(dotSize, dotSize);
                });
                
                console.log('ğŸ”´ äº’å‹•é»é»å¸ƒå±€å·²æ›´æ–°');
            }

            updateInteractiveDotsParallax(inputX, inputY) {
                if (!this.interactiveDots.length) return;
                
                this.interactiveDots.forEach(dotData => {
                    const { mesh, basePosition, config } = dotData;
                    
                    // æ ¹æ“šé»çš„æ·±åº¦å€¼è¨ˆç®—è¦–å·®åç§»
                    const depthOffset = (config.depth - 0.625); // èˆ‡ shader ä¸­ç›¸åŒçš„åŸºæº–é»
                    const parallaxX = inputX * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    const parallaxY = inputY * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    
                    // æ‡‰ç”¨è¦–å·®åç§»åˆ°åŸºç¤ä½ç½®
                    mesh.position.x = basePosition.x + parallaxX;
                    mesh.position.y = basePosition.y + parallaxY;
                });
            }

            setupDotInteractions() {
                // å»ºç«‹raycasterç”¨æ–¼é»æ“Šæª¢æ¸¬
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // æ»‘é¼ æŒ‰ä¸‹äº‹ä»¶
                this.renderer.domElement.addEventListener('pointerdown', (event) => {
                    this.handleDotPointerDown(event);
                });
                
                // æ»‘é¼ æ”¾é–‹äº‹ä»¶
                this.renderer.domElement.addEventListener('pointerup', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // æ»‘é¼ é›¢é–‹æ™‚ä¹Ÿè¦æ”¾é–‹ï¼ˆé¿å…æ‹–æ‹½é›¢é–‹å¾Œå¡ä½ï¼‰
                this.renderer.domElement.addEventListener('pointerleave', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // æ¡Œæ©Ÿç‰ˆï¼šæ»‘é¼ hoveræ•ˆæœå’Œè·é›¢äº’å‹•
                if (!this.isMobile) {
                    this.renderer.domElement.addEventListener('pointermove', (event) => {
                        this.handleDotHover(event);
                        // åŒæ™‚æ›´æ–°è·é›¢äº’å‹•
                        if (this.DISTANCE_INTERACTION_ENABLED) {
                            this.updateDistanceInteraction(event);
                        }
                    });
                    
                    // è¨­å®šæ»‘é¼ æ¨£å¼
                    this.renderer.domElement.style.cursor = 'default';
                } else {
                    // è¡Œå‹•ç‰ˆï¼šè·é›¢äº’å‹•å·²åœ¨å»ºæ§‹å‡½æ•¸ä¸­é—œé–‰ï¼Œç„¡éœ€é¡å¤–äº‹ä»¶ç›£è½å™¨
                    console.log('è¡Œå‹•ç‰ˆï¼šè·é›¢æ„Ÿæ‡‰äº’å‹•å·²é—œé–‰');
                }
                // æ³¨æ„ï¼šè¡Œå‹•ç‰ˆçš„å‹•ç•«ç¾åœ¨çµ±ä¸€åœ¨ fadeInInteractiveDots å®Œæˆå¾Œå•Ÿå‹•
            }

            handleDotPointerDown(event) {
                // å¦‚æœæ­£åœ¨éæ¸¡å‹•ç•«ä¸­ï¼Œå¿½ç•¥é»æ“Š
                if (this.isTransitioning) return;
                
                // è½‰æ›æ»‘é¼ åº§æ¨™
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // è¨­å®šraycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                if (this.viewState === 'main') {
                    // ä¸»è¦–è§’ï¼šæª¢æŸ¥é»é»é»æ“Š
                    const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                    let intersects = this.raycaster.intersectObjects(dotMeshes);
                    
                    // å¦‚æœæ˜¯è¡Œå‹•è£ç½®ä¸”æ²’æœ‰ç²¾ç¢ºå‘½ä¸­ï¼Œä½¿ç”¨æ“´å±•çš„ç¢°æ’æª¢æ¸¬
                    if (this.isMobile && intersects.length === 0) {
                        intersects = this.checkExtendedDotCollision(event.clientX, event.clientY);
                    }
                    
                    if (intersects.length > 0) {
                        const pressedDot = intersects[0].object;
                        const dotData = this.interactiveDots.find(d => d.mesh === pressedDot);
                        const dotId = pressedDot.userData.dotId;
                        console.log(`ğŸ”´ ${dotId} pressed down`);
                        
                        if (dotData) {
                            // è¨­å®šæŒ‰ä¸‹ç‹€æ…‹
                            dotData.isPressed = true;
                            this.animateDotPress(dotData, true);
                        }
                    }
                } else if (this.viewState === 'detail') {
                    // å±€éƒ¨è¦–è§’ï¼šé»æ“Šä»»æ„ä½ç½®è¿”å›ä¸»è¦–è§’
                    console.log('ğŸ”„ é»æ“Šç•«é¢è¿”å›ä¸»è¦–è§’');
                    this.returnToMainView();
                }
            }

            handleDotPointerUp(event) {
                // å¦‚æœæ­£åœ¨éæ¸¡å‹•ç•«ä¸­ï¼Œå¿½ç•¥é»æ“Š
                if (this.isTransitioning) return;
                
                if (this.viewState === 'main') {
                    // ä¸»è¦–è§’ï¼šæª¢æŸ¥æ˜¯å¦æœ‰é»é»è¢«æŒ‰ä¸‹ä¸¦è§¸ç™¼æ”¾å¤§
                    let clickedDot = null;
                    this.interactiveDots.forEach(dotData => {
                        if (dotData.isPressed) {
                            console.log(`ğŸ”´ ${dotData.mesh.userData.dotId} released`);
                            clickedDot = dotData;
                            dotData.isPressed = false;
                            this.animateDotPress(dotData, false);
                        }
                    });
                    
                    // å¦‚æœæœ‰é»é»è¢«é»æ“Šï¼Œæ”¾å¤§åˆ°å±€éƒ¨è¦–è§’
                    if (clickedDot) {
                        console.log(`ğŸ¯ æ”¾å¤§åˆ°å±€éƒ¨è¦–è§’: ${clickedDot.config.id}`);
                        this.zoomToDetailView(clickedDot);
                    }
                }
            }

            // æª¢æŸ¥æ“´å±•çš„é»é»ç¢°æ’ï¼ˆè¡Œå‹•è£ç½®å°ˆç”¨ï¼‰
            checkExtendedDotCollision(clientX, clientY) {
                if (!this.layers.length) return [];
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return [];
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // è¨ˆç®—è¢å¹•ä¸­å¿ƒé»
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // è¨ˆç®—é»é»åœ¨è¢å¹•ä¸Šçš„å¯¦éš›ä½ç½®
                const dotScreenPositions = this.interactiveDots.map(dotData => {
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    return {
                        dotData: dotData,
                        screenX: dotScreenX,
                        screenY: dotScreenY
                    };
                });
                
                // è¨ˆç®—æ“´å±•çš„ç¢°æ’ç¯„åœï¼ˆé»é»å¤§å°çš„2å€ï¼‰
                const baseDotSize = Math.min(width, height) * 0.05; // ä½¿ç”¨èˆ‡createDotMeshç›¸åŒçš„è¨ˆç®—
                const extendedRadius = baseDotSize * (window.innerWidth / (width * this.IMAGE_SCALE)) * 2; // 2å€å¤§å°
                
                // æª¢æŸ¥è§¸æ§é»æ˜¯å¦åœ¨ä»»ä½•é»é»çš„æ“´å±•ç¯„åœå…§
                for (let i = 0; i < dotScreenPositions.length; i++) {
                    const pos = dotScreenPositions[i];
                    const deltaX = clientX - pos.screenX;
                    const deltaY = clientY - pos.screenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance <= extendedRadius) {
                        // è¿”å›æ¨¡æ“¬çš„intersectçµæœ
                        return [{
                            object: pos.dotData.mesh,
                            distance: distance
                        }];
                    }
                }
                
                return [];
            }

            handleDotHover(event) {
                if (this.isMobile) return;
                
                // è½‰æ›æ»‘é¼ åº§æ¨™
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // è¨­å®šraycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                // æª¢æŸ¥èˆ‡é»é»çš„äº¤é›†
                const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                const intersects = this.raycaster.intersectObjects(dotMeshes);
                
                let currentHoveredDot = null;
                
                if (intersects.length > 0) {
                    currentHoveredDot = intersects[0].object;
                }
                
                // æ›´æ–°hoverç‹€æ…‹ - åªè™•ç†ç‹€æ…‹æ”¹è®Šçš„é»
                this.interactiveDots.forEach(dotData => {
                    const shouldBeHovered = dotData.mesh === currentHoveredDot;
                    
                    if (shouldBeHovered && !dotData.isHovered) {
                        // é–‹å§‹hover
                        dotData.isHovered = true;
                        this.animateDotHover(dotData.mesh, true);
                    } else if (!shouldBeHovered && dotData.isHovered) {
                        // çµæŸhover
                        dotData.isHovered = false;
                        this.animateDotHover(dotData.mesh, false);
                    }
                });
                
                // æ›´æ–°æ»‘é¼ æ¨£å¼
                this.renderer.domElement.style.cursor = currentHoveredDot ? 'pointer' : 'default';
            }

            animateDotPress(dotData, isPressed) {
                // æŒ‰ä¸‹/æ”¾é–‹å‹•ç•«
                const duration = isPressed ? 80 : 200; // æŒ‰ä¸‹å¿«ï¼Œæ”¾é–‹æ…¢
                const targetScale = isPressed ? 0.8 : 1.0; // æŒ‰ä¸‹ç¸®å°30%
                const targetOpacityBoost = isPressed ? 1.6 : 1.0; // æŒ‰ä¸‹æ™‚æ›´äº®
                
                const startScale = dotData.pressedScale;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ç·©å‹•å‡½æ•¸ï¼šæŒ‰ä¸‹æ™‚å¿«é€Ÿï¼Œæ”¾é–‹æ™‚å½ˆæ€§
                    const easeProgress = isPressed ? 
                        Math.pow(progress, 1.5) : // æŒ‰ä¸‹ï¼šease-in å¿«é€Ÿ
                        1 - Math.pow(1 - progress, 1.8); // æ”¾é–‹ï¼šease-out å½ˆæ€§
                    
                    // æ›´æ–°ç¸®æ”¾ä¿‚æ•¸
                    dotData.pressedScale = startScale + (targetScale - startScale) * easeProgress;
                    
                    // æ›´æ–°é€æ˜åº¦ï¼ˆæŒ‰ä¸‹æ™‚è®Šäº®ï¼‰
                    const targetMultiplier = dotData.isHovered ? 1.4 * targetOpacityBoost : targetOpacityBoost;
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            animateDotHover(dotMesh, isHovering) {
                // æ‰¾åˆ°å°æ‡‰çš„é»è³‡æ–™
                const dotData = this.interactiveDots.find(d => d.mesh === dotMesh);
                if (!dotData) return;
                
                // é¿å…é‡è¤‡å‹•ç•«
                if (dotMesh.userData.isAnimating) return;
                dotMesh.userData.isAnimating = true;
                
                // è¨­å®šç›®æ¨™é€æ˜åº¦ä¹˜æ•¸
                const targetOpacityMultiplier = isHovering ? 1.4 : 1.0;
                const duration = 200;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨æ›´å¿«çš„ç·©å‹•å‡½æ•¸ï¼Œè®“hoveråæ‡‰æ›´å³æ™‚
                    const easeProgress = 1 - Math.pow(1 - progress, 2); // ease-out quad
                    
                    // æ›´æ–°é€æ˜åº¦ä¹˜æ•¸
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetOpacityMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        dotMesh.userData.isAnimating = false;
                    }
                };
                animate();
            }

            // ğŸ¯ ================== è·é›¢æ„Ÿæ‡‰äº’å‹•ç³»çµ± ==================

            updateDistanceInteraction(event) {
                if (!this.loadingComplete || !this.layers.length) return;
                
                // ç²å–æ»‘é¼ åœ¨ç•«é¢ä¸­çš„ä½ç½®
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸å’Œä½ç½®ä¿¡æ¯
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // è¨ˆç®—è¢å¹•ä¸­å¿ƒé»
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // è¨ˆç®—æœ€å¤§æ„Ÿæ‡‰è·é›¢ï¼ˆåŸºæ–¼ä¸»åœ–å¯¬åº¦ï¼‰
                const maxDistancePixels = width * this.MAX_DISTANCE * (window.innerWidth / (width * this.IMAGE_SCALE));
                
                this.interactiveDots.forEach(dotData => {
                    // è¨ˆç®—é»é»åœ¨è¢å¹•ä¸Šçš„å¯¦éš›ä½ç½®
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    
                    // è¨ˆç®—æ»‘é¼ èˆ‡é»é»çš„è·é›¢
                    const deltaX = mouseX - dotScreenX;
                    const deltaY = mouseY - dotScreenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // è¨ˆç®—è·é›¢ä¿‚æ•¸ (0 = æœ€è¿‘, 1 = æœ€é /è¶…å‡ºç¯„åœ)
                    let distanceFactor = Math.min(distance / maxDistancePixels, 1.0);
                    
                    // ä½¿ç”¨ç·©å‹•æ›²ç·šè®“è·é›¢è®ŠåŒ–æ›´è‡ªç„¶
                    distanceFactor = this.easeOutQuad(distanceFactor);
                    
                    // è¨­å®šç›®æ¨™è·é›¢ä¿‚æ•¸
                    dotData.targetMouseDistance = distanceFactor;
                });
            }

            updateDistanceInteractionAnimation() {
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // è·é›¢äº’å‹•å•Ÿç”¨ï¼šå¹³æ»‘éæ¸¡åˆ°ç›®æ¨™è·é›¢ä¿‚æ•¸
                        const delta = dotData.targetMouseDistance - dotData.mouseDistance;
                        dotData.mouseDistance += delta * this.DISTANCE_LERP_SPEED;
                        
                        // è¨ˆç®—åŸºæ–¼è·é›¢çš„ç¸®æ”¾å’Œé€æ˜åº¦
                        // ä½¿ç”¨åè½‰çš„è·é›¢ä¿‚æ•¸ï¼šè·é›¢è¿‘æ™‚ä¿‚æ•¸å¤§ï¼Œè·é›¢é æ™‚ä¿‚æ•¸å°
                        const proximityFactor = 1.0 - dotData.mouseDistance;
                        
                        // ç¸®æ”¾ä¿‚æ•¸ï¼šå¾æœ€å°ç¸®æ”¾åˆ°1.0
                        dotData.distanceScale = this.MIN_SCALE_FACTOR + (1.0 - this.MIN_SCALE_FACTOR) * proximityFactor;
                        
                        // é€æ˜åº¦ä¿‚æ•¸ï¼šå¾æœ€å°é€æ˜åº¦åˆ°1.0
                        dotData.distanceOpacity = this.MIN_OPACITY_FACTOR + (1.0 - this.MIN_OPACITY_FACTOR) * proximityFactor;
                    } else {
                        // è·é›¢äº’å‹•é—œé–‰ï¼šä¿æŒæ­£å¸¸å¤§å°å’Œé€æ˜åº¦
                        dotData.mouseDistance = 0.0;
                        dotData.targetMouseDistance = 0.0;
                        dotData.distanceScale = 1.0;
                        dotData.distanceOpacity = 1.0;
                    }
                });
            }

            resetDistanceInteraction() {
                // é‡ç½®æ‰€æœ‰é»é»çš„è·é›¢ä¿‚æ•¸
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // è·é›¢äº’å‹•å•Ÿç”¨ï¼šé‡ç½®åˆ°æœ€é ç‹€æ…‹
                        dotData.targetMouseDistance = 1.0;
                    } else {
                        // è·é›¢äº’å‹•é—œé–‰ï¼šé‡ç½®åˆ°æ­£å¸¸ç‹€æ…‹
                        dotData.targetMouseDistance = 0.0;
                    }
                });
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            // ğŸ¯ ================== è·é›¢æ„Ÿæ‡‰äº’å‹•ç³»çµ±çµæŸ ==================

            fadeInInteractiveDots() {
                // äº’å‹•é»é»çš„æ·¡å…¥å‹•ç•«
                const fadeInDuration = 1500; // 1.5ç§’æ·¡å…¥
                const startTime = Date.now();
                
                this.interactiveDots.forEach((dotData, index) => {
                    const delay = index * 300; // æ¯å€‹é»éŒ¯é–‹0.3ç§’
                    
                    setTimeout(() => {
                        dotData.mesh.userData.isVisible = true;
                        // ç‚ºæ¯å€‹é»è¨­å®šç¨ç«‹çš„å‹•ç•«é–‹å§‹æ™‚é–“
                        dotData.mesh.userData.animationStartTime = Date.now();
                        
                        const animate = () => {
                            const elapsed = Date.now() - startTime - delay;
                            const progress = Math.max(0, Math.min(elapsed / fadeInDuration, 1));
                            
                            if (progress > 0) {
                                // ç·©å‹•å‡½æ•¸ï¼šease-out
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                
                                // åœ¨æ·¡å…¥éç¨‹ä¸­å°±é–‹å§‹è¨ˆç®—å‘¼å¸å‹•ç•«ï¼Œç¢ºä¿çµ²æ»‘éŠœæ¥
                                const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                                const phase = index * Math.PI * 0.8;
                                const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                                
                                // ğŸ¯ æ›´æ–°è·é›¢äº’å‹•å‹•ç•«ï¼ˆæ·¡å…¥æœŸé–“ä¹Ÿéœ€è¦ï¼‰
                                this.updateDistanceInteractionAnimation();
                                
                                // æ·¡å…¥æœŸé–“ï¼šé€æ˜åº¦ = æ·¡å…¥é€²åº¦ Ã— åŸºç¤é€æ˜åº¦ Ã— å‘¼å¸ä¿‚æ•¸ Ã— hoverä¹˜æ•¸ Ã— è·é›¢é€æ˜åº¦ Ã— éæ¸¡é€æ˜åº¦
                                const targetOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                                const opacity = targetOpacity * easeProgress;
                                dotData.mesh.material.opacity = opacity;
                                
                                // å¤§å°å‘¼å¸æ•ˆæœï¼Œåœ¨æ·¡å…¥æœŸé–“ä¹ŸåŒæ­¥é–‹å§‹ï¼Œä¸¦è€ƒæ…®æ‰€æœ‰ç¸®æ”¾æ•ˆæœ
                                const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                                // çµ„åˆæ‰€æœ‰ç¸®æ”¾æ•ˆæœï¼šå‘¼å¸ Ã— hover Ã— æŒ‰ä¸‹ Ã— è·é›¢
                                const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                                const finalScale = hoverScale * dotData.pressedScale * dotData.distanceScale;
                                const scaleFactor = finalScale * easeProgress + (1 - easeProgress);
                                dotData.mesh.scale.setScalar(scaleFactor);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else {
                                // æ·¡å…¥å®Œæˆï¼Œåˆ‡æ›åˆ°ç´”å‘¼å¸å‹•ç•«
                                this.startBreathingAnimation(dotData, index);
                            }
                        };
                        animate();
                    }, delay);
                });
            }

            startBreathingAnimation(dotData, index) {
                // æ¡Œæ©Ÿç‰ˆå’Œè¡Œå‹•ç‰ˆçš„çµ±ä¸€å‘¼å¸å‹•ç•«ï¼Œä½¿ç”¨æ¯å€‹é»ç¨ç«‹çš„æ™‚é–“åŸºæº–
                const breathAnimate = () => {
                    if (!dotData.mesh.userData.isVisible) return;
                    
                    // ğŸ¯ æ›´æ–°è·é›¢äº’å‹•å‹•ç•«
                    this.updateDistanceInteractionAnimation();
                    
                    // ä½¿ç”¨æ¯å€‹é»ç¨ç«‹çš„å‹•ç•«é–‹å§‹æ™‚é–“ï¼Œç¢ºä¿çµ²æ»‘éŠœæ¥
                    const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                    const phase = index * Math.PI * 0.8; // æ¯å€‹é»æœ‰ä¸åŒçš„ç›¸ä½
                    
                    // é€æ˜åº¦å‘¼å¸æ•ˆæœï¼šåŸºç¤å‘¼å¸ Ã— hoverä¹˜æ•¸ Ã— è·é›¢é€æ˜åº¦ Ã— éæ¸¡é€æ˜åº¦
                    const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                    const currentOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                    dotData.mesh.material.opacity = currentOpacity;
                    
                    // å¤§å°å‘¼å¸æ•ˆæœï¼šçµ„åˆå‘¼å¸ã€hoverã€æŒ‰ä¸‹å’Œè·é›¢æ•ˆæœ
                    const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                    const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                    const scaleFactor = hoverScale * dotData.pressedScale * dotData.distanceScale;
                    dotData.mesh.scale.setScalar(scaleFactor);
                    
                    requestAnimationFrame(breathAnimate);
                };
                breathAnimate();
            }

            // ğŸ”´ ================== äº’å‹•é»é»ç³»çµ±çµæŸ ==================

            // ğŸ” ================== å±€éƒ¨åœ–ç³»çµ± ==================

            // ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶æ–¹æ³•
            updateDetailViewControl(inputX, inputY) {
                
                // æ›´æ–°å±€éƒ¨è¦–è§’çš„æ»‘é¼ ä½ç½®
                this.detailViewMouse.x = inputX;
                this.detailViewMouse.y = inputY;
                
                // è¨ˆç®—é‚Šç•Œè¶…å‡ºæ•ˆæœçš„åç§»é‡ - ç›¸åæ–¹å‘
                const offsetX = -inputX * this.DETAIL_VIEW_INTENSITY;  // Xè»¸ç›¸å
                const offsetY = -inputY * this.DETAIL_VIEW_INTENSITY;  // Yè»¸ç›¸å
                
                // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
                const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                this.detailViewOffset.x = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
                this.detailViewOffset.y = Math.max(-maxOffset, Math.min(maxOffset, offsetY));
                
                // æ›´æ–°å ´æ™¯ä½ç½®ä»¥å¯¦ç¾é‚Šç•Œè¶…å‡ºæ•ˆæœ
                if (this.currentDetailDot) {
                    const detailLayer = this.detailLayers.find(layer => 
                        layer.detailInfo.dotId === this.currentDetailDot.config.id
                    );
                    
                    if (detailLayer) {
                        const detailMesh = detailLayer.mesh;
                        
                        // è¨ˆç®—åŸºç¤å ´æ™¯ä½ç½®ï¼ˆå±€éƒ¨åœ–ä¸­å¿ƒå°é½Šç•«é¢ä¸­å¿ƒï¼‰
                        const baseSceneX = -detailMesh.position.x;
                        const baseSceneY = -detailMesh.position.y;
                        
                        // æ‡‰ç”¨é‚Šç•Œè¶…å‡ºåç§»
                        this.scene.position.x = baseSceneX + this.detailViewOffset.x;
                        this.scene.position.y = baseSceneY + this.detailViewOffset.y;
                        
                        // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                        // console.log(`ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶: offset(${this.detailViewOffset.x.toFixed(3)}, ${this.detailViewOffset.y.toFixed(3)})`);
                    }
                }
            }

            resetDetailViewControl() {
                // é‡ç½®å±€éƒ¨è¦–è§’æ§åˆ¶
                this.detailViewMouse.x = 0;
                this.detailViewMouse.y = 0;
                this.detailViewOffset.x = 0;
                this.detailViewOffset.y = 0;
            }

            // ğŸ”´ ================== é»é»éæ¸¡é€æ˜åº¦æ§åˆ¶ç³»çµ± ==================

            updateDotsTransitionOpacity(animationType, progress) {
                // æ›´æ–°é»é»åœ¨æ”¾å¤§ç¸®å°éç¨‹ä¸­çš„é€æ˜åº¦
                if (!this.interactiveDots.length) return;

                let transitionOpacity = 1.0;

                if (animationType === 'zoomIn') {
                    // æ”¾å¤§æ™‚æ·¡å‡ºï¼šé€²åº¦ 0.0â†’0.5 é€æ˜åº¦ 100%â†’0%ï¼Œé€²åº¦ 0.5â†’1.0 é€æ˜åº¦ä¿æŒ 0%
                    if (progress <= 0.5) {
                        transitionOpacity = 1.0 - (progress / 0.5); // å¾1.0éæ¸¡åˆ°0.0
                    } else {
                        transitionOpacity = 0.0; // ä¿æŒé€æ˜
                    }
                } else if (animationType === 'zoomOut') {
                    // ç¸®å°æ™‚æ·¡å…¥ï¼šé€²åº¦ 0.0â†’0.5 é€æ˜åº¦ä¿æŒ 0%ï¼Œé€²åº¦ 0.5â†’1.0 é€æ˜åº¦ 0%â†’100%
                    if (progress <= 0.5) {
                        transitionOpacity = 0.0; // ä¿æŒé€æ˜
                    } else {
                        transitionOpacity = (progress - 0.5) / 0.5; // å¾0.0éæ¸¡åˆ°1.0
                    }
                }

                // æ‡‰ç”¨åˆ°æ‰€æœ‰é»é»
                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = transitionOpacity;
                });

                // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                // console.log(`ğŸ”´ é»é»éæ¸¡é€æ˜åº¦: ${animationType}, progress=${progress.toFixed(3)}, opacity=${transitionOpacity.toFixed(3)}`);
            }

            resetDotsTransitionOpacity(opacity) {
                // é‡ç½®æ‰€æœ‰é»é»çš„éæ¸¡é€æ˜åº¦
                if (!this.interactiveDots.length) return;

                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = opacity;
                });

                console.log(`ğŸ”´ é‡ç½®é»é»é€æ˜åº¦: ${(opacity * 100).toFixed(0)}%`);
            }

            // ğŸ”´ ================== é»é»éæ¸¡é€æ˜åº¦æ§åˆ¶ç³»çµ±çµæŸ ==================
        }

        // å…¨åŸŸè®Šæ•¸ç”¨æ–¼å­˜å–ParallaxViewerå¯¦ä¾‹
        let parallaxViewerInstance = null;

        // è¿”å›æŒ‰éˆ•è™•ç†å‡½æ•¸
        function handleBackButton() {
            if (parallaxViewerInstance) {
                if (parallaxViewerInstance.viewState === 'detail') {
                    // å±€éƒ¨è¦–è§’ï¼šè¿”å›ä¸»è¦–è§’
                    parallaxViewerInstance.returnToMainView();
                } else {
                    // ä¸»è¦–è§’ï¼šè¿”å›é¦–é 
                    window.location.href = '#';
                }
            } else {
                // é è¨­è¡Œç‚º
                window.location.href = '#';
            }
        }

        // å…¨è¢å¹•æŒ‰éˆ•è™•ç†å‡½æ•¸
        function handleFullscreenButton() {
            if (!document.fullscreenElement) {
                // é€²å…¥å…¨è¢å¹•
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // é€€å‡ºå…¨è¢å¹•
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // é‡ç½®è¦–è§’æŒ‰éˆ•è™•ç†å‡½æ•¸
        function handleResetViewButton() {
            if (parallaxViewerInstance) {
                parallaxViewerInstance.resetView();
            }
        }

        // åˆå§‹åŒ–æ‡‰ç”¨ç¨‹å¼
        document.addEventListener('DOMContentLoaded', () => {
            parallaxViewerInstance = new ParallaxViewer();
            
            // å…¨è¢å¹•ç‹€æ…‹ç›£è½
            const fullscreenButton = document.getElementById('fullscreen-button');
            const fullscreenIcon = fullscreenButton.querySelector('svg');
            
            function updateFullscreenIcon() {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                    // å…¨è¢å¹•ç‹€æ…‹ï¼šé¡¯ç¤ºé€€å‡ºåœ–ç¤º
                    fullscreenIcon.innerHTML = '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>';
                } else {
                    // éå…¨è¢å¹•ç‹€æ…‹ï¼šé¡¯ç¤ºé€²å…¥åœ–ç¤º
                    fullscreenIcon.innerHTML = '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>';
                }
            }
            
            // ç›£è½å…¨è¢å¹•ç‹€æ…‹è®ŠåŒ–
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
            document.addEventListener('msfullscreenchange', updateFullscreenIcon);
            
            // åˆå§‹åŒ–åœ–ç¤º
            updateFullscreenIcon();
            
            // è§¸æ§è£ç½®æª¢æ¸¬å’Œå„ªåŒ–
            function detectTouchDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (isMobile) {
                    document.body.classList.add('touch-device');
                    console.log('ğŸ“± æª¢æ¸¬åˆ°è¡Œå‹•è£ç½®ï¼Œå•Ÿç”¨è§¸æ§å„ªåŒ–');
                } else {
                    document.body.classList.add('desktop-device');
                    console.log('ğŸ–¥ï¸ æª¢æ¸¬åˆ°æ¡Œé¢è£ç½®');
                }
            }
            
            // è¡Œå‹•è£ç½®æŒ‰éˆ•é¡¯ç¤ºæ§åˆ¶
            function controlMobileButtons() {
                const fullscreenButton = document.getElementById('fullscreen-button');
                const resetViewButton = document.getElementById('reset-view-button');
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // å…¨è¢å¹•æŒ‰éˆ•åœ¨æ‰€æœ‰è£ç½®éƒ½é¡¯ç¤º
                fullscreenButton.style.display = 'flex';
                
                // é‡ç½®è¦–è§’æŒ‰éˆ•åªåœ¨è¡Œå‹•è£ç½®ä¸”æ©«å‘æ™‚é¡¯ç¤º
                if (isMobile && isLandscape) {
                    resetViewButton.style.display = 'flex';
                    console.log('ğŸ“± è¡Œå‹•è£ç½®æ©«å‘ï¼šé¡¯ç¤ºé‡ç½®è¦–è§’æŒ‰éˆ•');
                } else {
                    resetViewButton.style.display = 'none';
                    console.log('ğŸ–¥ï¸ æ¡Œé¢è£ç½®æˆ–ç›´å‘ï¼šéš±è—é‡ç½®è¦–è§’æŒ‰éˆ•');
                }
            }
            
            // åŸ·è¡Œè§¸æ§è£ç½®æª¢æ¸¬
            detectTouchDevice();
            
            // åŸ·è¡Œè¡Œå‹•è£ç½®æŒ‰éˆ•æ§åˆ¶
            controlMobileButtons();
            
            // ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
            window.addEventListener('resize', controlMobileButtons);
        });

        // é–‹ç™¼æ¨¡å¼ï¼šé‡ç½®é™€èºå„€æˆæ¬Šç‹€æ…‹ï¼ˆæŒ‰å…©ä¸‹è¿”å›æŒ‰éˆ•ï¼‰
        let backButtonClickCount = 0;
        let backButtonClickTimer = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            const backButton = document.getElementById('back-button');
            if (backButton) {
                backButton.addEventListener('click', () => {
                    backButtonClickCount++;
                    
                    if (backButtonClickTimer) {
                        clearTimeout(backButtonClickTimer);
                    }
                    
                    backButtonClickTimer = setTimeout(() => {
                        if (backButtonClickCount === 2) {
                            // é›™æ“Šé‡ç½®æˆæ¬Šç‹€æ…‹
                            localStorage.removeItem('gyroPermissionGranted');
                            console.log('ğŸ”„ é™€èºå„€æˆæ¬Šç‹€æ…‹å·²é‡ç½®');
                            location.reload(); // é‡æ–°è¼‰å…¥é é¢
                        }
                        backButtonClickCount = 0;
                    }, 300);
                });
            }
        });
    </script>
</body>
</html>