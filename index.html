<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº’å‹•å¼è¦–å·®ç¶²é </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a1a);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* ğŸ­ ä¸‰å±¤ç´šæ¶æ§‹ Z-Index å®šç¾© */
        /* å±¤ç´š 3: UI å±¤ (z-index: 3000+) */
        #back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI å±¤ï¼šæœ€ä¸Šå±¤ */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #back-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        #back-button svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        /* ğŸ® é™€èºå„€æ¬Šé™æŒ‰éˆ•æ¨£å¼ */
        #gyro-permission-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            font-family: Arial, sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 3000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #gyro-permission-button:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        #gyro-permission-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* ğŸ® é‡ç½®é™€èºå„€æŒ‰éˆ•æ¨£å¼ */
        #reset-gyro-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            font-family: Arial, sans-serif;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 3000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #reset-gyro-button:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        #reset-gyro-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* å±¤ç´š 2: è¼‰å…¥å±¤ (z-index: 2000+) */
        #loading-cover {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 2000; /* è¼‰å…¥å±¤ï¼šä¸­é–“å±¤ */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #loading-cover.fade-in {
            opacity: 1;
            transition: opacity 0.5s ease; /* æ˜ç¢ºè¨­å®šæ·¡å…¥æ™‚é–“ */
        }

        @keyframes fadeOut { 
            0% { opacity: 1; } 
            80% { opacity: 0.15; } 
            100% { opacity: 0; } 
        }
        
        #loading-cover.fade-out { 
            animation: fadeOut 0.9s ease-out forwards; 
            will-change: opacity;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2001; /* è¼‰å…¥å±¤ï¼šè¼‰å…¥å‹•ç•« */
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        #loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-container {
            position: relative;
            padding: 40px;
        }



        .elegant-spinner {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
        }

        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
        }

        .spinner-ring:nth-child(1) {
            border-top: 2px solid #dc9c3b;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .spinner-ring:nth-child(2) {
            border-right: 2px solid #d1936b;
            transform: scale(0.8);
            filter: drop-shadow(0 0 6px rgba(209, 147, 107, 0.4));
        }

        .spinner-ring:nth-child(3) {
            border-bottom: 2px solid #f4e3d4;
            transform: scale(0.6);
            filter: drop-shadow(0 0 4px rgba(244, 227, 212, 0.3));
        }

        .loading-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 20px;
        }

        .dot {
            width: 5px;
            height: 5px;
            background: #dc9c3b;
            border-radius: 50%;
            animation: dotPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(220, 156, 59, 0.5);
        }

        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.3s; }
        .dot:nth-child(3) { animation-delay: 0.6s; }

        .loading-particles {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 200px;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            opacity: 0;
            animation: particleFloat 4s linear infinite, particleGlow 2s ease-in-out infinite alternate;
            bottom: 5px; /* åˆå§‹ä½ç½®åœ¨å®¹å™¨åº•éƒ¨å¤–é¢ */
            filter: brightness(1.2);
        }

        @keyframes titleGlow {
            0% { 
                text-shadow: 0 0 20px rgba(244, 227, 212, 0.5);
                transform: scale(1);
            }
            100% { 
                text-shadow: 0 0 30px rgba(244, 227, 212, 0.8), 0 0 40px rgba(220, 156, 59, 0.3);
                transform: scale(1.02);
            }
        }

        @keyframes elegantSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes dotPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 0.3; 
            }
            50% { 
                transform: scale(1.3); 
                opacity: 1; 
                box-shadow: 0 0 15px rgba(220, 156, 59, 0.8);
            }
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(0) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(-20px) scale(1);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-250px) scale(1);
                opacity: 0;
            }
        }



        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2002; /* è¼‰å…¥å±¤ï¼šéŒ¯èª¤è¨Šæ¯ */
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            max-width: 80%;
            display: none;
        }



        /* å±¤ç´š 1: å…§å®¹å±¤ (z-index: 1000+) */
        #canvas {
            display: block;
            z-index: 1000; /* å…§å®¹å±¤ï¼šæœ€ä¸‹å±¤ */
        }

        @media (max-width: 768px) {
            #back-button {
                width: 45px;
                height: 45px;
                top: 15px;
                left: 15px;
            }
            
            .loading-container {
                padding: 20px;
            }
            
            .elegant-spinner {
                width: 60px;
                height: 60px;
                margin: 0 auto 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading-cover">
            <canvas id="loading-canvas"></canvas>
        </div>
        
        <div id="loading">
            <div class="loading-container">
                <div class="loading-particles" id="particles"></div>
                <div class="elegant-spinner">
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                </div>
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>
        
        <div id="error-message">
            <h3>âš ï¸ è¼‰å…¥éŒ¯èª¤</h3>
            <p>è«‹ä½¿ç”¨æœ¬åœ°ä¼ºæœå™¨é–‹å•Ÿæ­¤ç¶²é ä»¥é¿å… CORS å•é¡Œ</p>
            <br>
            <p><strong>å»ºè­°è§£æ±ºæ–¹æ¡ˆï¼š</strong></p>
            <p>1. ä½¿ç”¨ Python: <code>python -m http.server 8000</code></p>
            <p>2. ä½¿ç”¨ Node.js: <code>npx http-server</code></p>
            <p>3. ä½¿ç”¨ VS Code Live Server æ“´å……åŠŸèƒ½</p>
        </div>
        
        <button id="back-button" onclick="handleBackButton()">
            <svg viewBox="0 0 24 24">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.42-1.41L7.83 13H20v-2z"/>
            </svg>
        </button>
        
        <!-- ğŸ® é™€èºå„€æ¬Šé™å¼•å°æŒ‰éˆ• -->
        <button id="gyro-permission-button" onclick="handleGyroPermission()" style="display: none;">
            <svg viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
            </svg>
            <span>å•Ÿç”¨é™€èºå„€</span>
        </button>

        <!-- ğŸ® é‡ç½®é™€èºå„€æŒ‰éˆ• -->
        <button id="reset-gyro-button" onclick="handleResetGyro()" style="display: none;">
            <svg viewBox="0 0 24 24">
                <path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/>
            </svg>
            <span>é‡ç½®è¦–è§’</span>
        </button>
        
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ParallaxViewer {
            constructor() {
                // ğŸ­ ä¸‰å±¤ç´šæ¶æ§‹ç³»çµ±
                this.uiLayer = null;           // æœ€ä¸Šå±¤ï¼šUI æ§åˆ¶å…ƒç´ 
                this.loadingLayer = null;      // ä¸­é–“å±¤ï¼šå°é¢åœ–èˆ‡è¼‰å…¥å‹•ç•«
                this.contentLayer = null;      // æœ€ä¸‹å±¤ï¼šä¸»è¦å…§å®¹åœ–å±¤çµ„
                
                // Three.js å ´æ™¯ç³»çµ±
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.loadingScene = null;
                this.loadingCamera = null;
                this.loadingRenderer = null;
                
                // åœ–å±¤ç®¡ç†
                this.layers = [];              // ä¸»è¦å…§å®¹åœ–å±¤ (7_BG~1_RabbitFornt)
                this.mainLayerGroup = null;    // ä¸»è¦åœ–å±¤çµ„å®¹å™¨
                this.dotsGroup = null;         // äº’å‹•é»é»å®¹å™¨
                this.detailGroup1 = null;      // å±€éƒ¨åœ–å®¹å™¨1
                this.detailGroup2 = null;      // å±€éƒ¨åœ–å®¹å™¨2
                this.detailGroup3 = null;      // å±€éƒ¨åœ–å®¹å™¨3
                this.detailLayers = [];        // å±€éƒ¨åœ–å±¤é™£åˆ—
                
                // ğŸ¯ è¦–è§’ç‹€æ…‹ç®¡ç†
                this.viewState = 'main';       // 'main' | 'detail'
                this.currentDetailDot = null;  // ç•¶å‰æ”¾å¤§çš„é»é»
                this.isTransitioning = false;  // æ˜¯å¦æ­£åœ¨éæ¸¡å‹•ç•«ä¸­
                
                // ğŸ¯ ç›¸æ©Ÿè®Šæ›åƒæ•¸
                this.originalCameraPosition = { x: 0, y: 0, z: 5 };
                // targetCameraPosition å°‡åœ¨éœ€è¦æ™‚å‹•æ…‹è¨ˆç®—ï¼Œä¸å†ä½¿ç”¨å›ºå®šå€¼
                this.originalScenePosition = { x: 0, y: 0, z: 0 };
                this.targetScenePosition = { x: 0, y: 0, z: 0 };
                
                // ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶åƒæ•¸
                this.DETAIL_VIEW_INTENSITY = 0.16;    // å±€éƒ¨è¦–è§’ç§»å‹•å¼·åº¦ (å»ºè­°ç¯„åœ: 0.05-0.3)
                this.DETAIL_VIEW_BOUNDARY = 0.26;      // é‚Šç•Œè¶…å‡ºç¯„åœ (ç›¸å°æ–¼åœ–ç‰‡å¤§å°)
                this.detailViewMouse = { x: 0, y: 0 }; // å±€éƒ¨è¦–è§’çš„æ»‘é¼ ä½ç½®
                this.detailViewOffset = { x: 0, y: 0 }; // å±€éƒ¨è¦–è§’çš„åç§»é‡
                
                // ğŸŒŸ å±€éƒ¨åœ–ç¾½åŒ–æ•ˆæœåƒæ•¸
                this.FEATHER_MAIN_VIEW = 5.0;          // ä¸»è¦–è§’ç¾½åŒ–å¼·åº¦ (å»ºè­°ç¯„åœ: 0.5-1.0)
                this.FEATHER_DETAIL_VIEW = 0.1;        // å±€éƒ¨è¦–è§’ç¾½åŒ–å¼·åº¦ (å»ºè­°ç¯„åœ: 0.0-0.3)
                this.FEATHER_TRANSITION_RANGE = 0.5;   // ç¾½åŒ–å½±éŸ¿ç¯„åœ (å»ºè­°ç¯„åœ: 0.2-0.5)
                
                // ğŸŒ«ï¸ éæ¸¡æ¨¡ç³Šæ•ˆæœåƒæ•¸
                this.TRANSITION_BLUR_STRENGTH = 3;      // éæ¸¡æ¨¡ç³Šå¼·åº¦ (0-20ï¼Œå»ºè­°å€¼ï¼š5-15)
                
                // ğŸ” å±€éƒ¨è¦–è§’æ”¾å¤§è¨­å®š
                this.DETAIL_ZOOM_SCALE = 4.5;           // å±€éƒ¨è¦–è§’æ”¾å¤§å€ç‡ (å»ºè­°ç¯„åœ: 2.0-10.0ï¼Œé è¨­5.0=500%)
                this.interactiveDots = [];     // äº’å‹•é»é»é™£åˆ—
                this.raycaster = null;         // é»æ“Šæª¢æ¸¬å™¨
                this.mouseVector = null;       // æ»‘é¼ å‘é‡
                // ğŸ® æ··åˆæ§åˆ¶ç³»çµ±
                this.currentControlMode = 'none';  // ç•¶å‰æ§åˆ¶æ¨¡å¼ï¼š'none', 'pointer', 'gyro'
                this.gyroActive = false;           // é™€èºå„€æ˜¯å¦å·²å•Ÿç”¨
                this.gyroPermissionGranted = false; // é™€èºå„€æ¬Šé™æ˜¯å¦å·²æˆæ¬Š
                this.lastPointerTime = 0;          // æœ€å¾Œä¸€æ¬¡æŒ‡é‡äº‹ä»¶æ™‚é–“
                this.POINTER_TIMEOUT = 300;        // æŒ‡é‡äº‹ä»¶è¶…æ™‚æ™‚é–“ (ms)
                this.initialOrientation = this.getInitialOrientation(); // å„²å­˜åˆå§‹è¢å¹•æ–¹å‘
                this.isResetting = false;          // æ˜¯å¦æ­£åœ¨åŸ·è¡Œé‡ç½®éæ¸¡å‹•ç•«
                
                // çµ±ä¸€è¼¸å‡ºæ§åˆ¶å€¼
                this.currentOffsetX = 0;           // ç•¶å‰Xè»¸åç§»å€¼
                this.currentOffsetY = 0;           // ç•¶å‰Yè»¸åç§»å€¼
                
                // æ»‘é¼ æ§åˆ¶ç›¸é—œ
                this.mouse = { x: 0, y: 0 };
                this.targetMouse = { x: 0, y: 0 }; // ç›®æ¨™æ»‘é¼ ä½ç½®
                this.currentMouse = { x: 0, y: 0 }; // ç•¶å‰æ’å€¼å¾Œçš„æ»‘é¼ ä½ç½®
                this.mouseInsidePage = true; // æ»‘é¼ æ˜¯å¦åœ¨é é¢å…§
                this.mouseJustReentered = false; // æ»‘é¼ æ˜¯å¦å‰›é‡æ–°é€²å…¥é é¢
                this.mouseVelocity = { x: 0, y: 0 }; // æ»‘é¼ ç§»å‹•é€Ÿåº¦
                this.inertiaTarget = { x: 0, y: 0 }; // æ…£æ€§ç›®æ¨™ä½ç½®
                this.isInertiaActive = false; // æ˜¯å¦æ­£åœ¨åŸ·è¡Œæ…£æ€§ç·©è¡
                
                // é™€èºå„€æ§åˆ¶ç›¸é—œ
                this.orientation = { x: 0, y: 0 };
                this.currentOrientation = this.getScreenOrientation();
                this.baseX = null;           // çµ±ä¸€çš„Xè»¸åŸºæº–å€¼
                this.baseY = null;           // çµ±ä¸€çš„Yè»¸åŸºæº–å€¼
                this.smoothedDelta = { x: 0, y: 0 }; // å¹³æ»‘å¾Œçš„å·®å€¼
                this.SMOOTH_ALPHA = 0.15;    // ä½é€šæ¿¾æ³¢ä¿‚æ•¸
                this.isMobile = this.detectMobile();
                this.loadingComplete = false;
                this.loadedImages = 0;
                this.totalImages = 0;
                this.errorCount = 0;
                this.loadingCoverLoaded = false;
                this.coverFadeOutComplete = false;
                this.parallaxTransitionProgress = 0; // 0 = ä¸­å¿ƒä½ç½®, 1 = æ»‘é¼ ä½ç½®
                
                // ğŸ›ï¸ çµ±ä¸€è¦–å·®å¼·åº¦æ§åˆ¶ - èª¿æ•´é€™äº›æ•¸å€¼ä¾†æ”¹è®Šæ•´é«”è¦–å·®æ•ˆæœ
                this.PARALLAX_INTENSITY = 0.27; // ä¸»è¦æ§åˆ¶åƒæ•¸ï¼šæ§åˆ¶æ»‘é¼ /å‚¾æ–œè¼¸å…¥çš„å½±éŸ¿ç¨‹åº¦ (å»ºè­°ç¯„åœ: 0.05-0.3)
                this.DEPTH_SENSITIVITY = 0.5;  // æ·±åº¦åœ–æ•æ„Ÿåº¦ï¼šæ§åˆ¶æ·±åº¦å·®ç•°çš„è¦–å·®å¹…åº¦ (å»ºè­°ç¯„åœ: 0.1-0.5)
                
                // ğŸ“± è¡Œå‹•è£ç½®é™€èºå„€æ§åˆ¶
                this.GYRO_SENSITIVITY = 5.0;    // é™€èºå„€éˆæ•åº¦ï¼šæ§åˆ¶è£ç½®å‚¾æ–œçš„æ•æ„Ÿç¨‹åº¦ (å»ºè­°ç¯„åœ: 0.5-2.0)
                this.GYRO_INVERT_X = true;       // æ˜¯å¦åè½‰Xè»¸ (å·¦å³å‚¾æ–œ)ï¼štrue=è£ç½®å·¦å‚¾æ™‚ç•«é¢å³ç§»
                
                // ğŸ–¼ï¸ çµ±ä¸€åœ–ç‰‡å¤§å°æ§åˆ¶
                this.IMAGE_SCALE = 1.02;        // åœ–ç‰‡ç¸®æ”¾æ¯”ä¾‹ï¼šæ§åˆ¶å°é¢åœ–å’Œä¸»åœ–çš„å¤§å° (å»ºè­°ç¯„åœ: 0.5-1.5)
                
                // ğŸ« å‘¼å¸å‹•ç•«æ§åˆ¶
                this.BREATH_SPEED = 0.003;      // å‘¼å¸é€Ÿåº¦ä¿‚æ•¸ï¼šæ•¸å€¼è¶Šå¤§å‘¼å¸è¶Šå¿« (å»ºè­°ç¯„åœ: 0.001-0.005)
                
                // ğŸ¯ è·é›¢æ„Ÿæ‡‰äº’å‹•æ§åˆ¶
                this.DISTANCE_INTERACTION_ENABLED = !this.isMobile;  // æ¡Œæ©Ÿç‰ˆå•Ÿç”¨ï¼Œè¡Œå‹•ç‰ˆé—œé–‰
                this.MAX_DISTANCE = 0.3;                   // æœ€å¤§æ„Ÿæ‡‰è·é›¢ï¼ˆç›¸å°æ–¼ä¸»åœ–å¯¬åº¦ï¼‰
                this.MIN_SCALE_FACTOR = 0.6;               // æœ€é æ™‚çš„æœ€å°ç¸®æ”¾ï¼ˆ60%ï¼‰
                this.MIN_OPACITY_FACTOR = 0.5;             // æœ€é æ™‚çš„æœ€å°é€æ˜åº¦ï¼ˆ50%ï¼‰
                this.DISTANCE_LERP_SPEED = 0.5;            // è·é›¢å‹•ç•«éæ¸¡é€Ÿåº¦

                /*
                 * ğŸ“– åƒæ•¸èªªæ˜ï¼š
                 * 
                 * PARALLAX_INTENSITY (parallaxOffset çš„ä¹˜æ•¸)ï¼š
                 * - æ§åˆ¶æ»‘é¼ ç§»å‹•æˆ–è£ç½®å‚¾æ–œå°è¦–å·®çš„å½±éŸ¿ç¨‹åº¦
                 * - æ•¸å€¼è¶Šå¤§ï¼Œæ»‘é¼ ç§»å‹•æ™‚è¦–å·®æ•ˆæœè¶Šæ˜é¡¯
                 * - å½±éŸ¿æ•´é«”è¦–å·®çš„"éˆæ•åº¦"
                 * 
                 * DEPTH_SENSITIVITY (parallaxStrength)ï¼š
                 * - æ§åˆ¶æ·±åº¦åœ–ä¸­ä¸åŒç°éšå€¼ä¹‹é–“çš„è¦–å·®å·®ç•°
                 * - æ•¸å€¼è¶Šå¤§ï¼Œæ·±åº¦åœ–çš„ç™½è‰²å’Œé»‘è‰²å€åŸŸè¦–å·®å·®ç•°è¶Šå¤§
                 * - å½±éŸ¿è¦–å·®çš„"æ·±åº¦æ„Ÿ"
                 * 
                 * GYRO_SENSITIVITYï¼š
                 * - æ§åˆ¶è¡Œå‹•è£ç½®é™€èºå„€çš„æ•æ„Ÿç¨‹åº¦
                 * - æ•¸å€¼è¶Šå¤§ï¼Œè£ç½®å‚¾æ–œæ™‚è¦–å·®æ•ˆæœè¶Šæ˜é¡¯
                 * - åƒ…å½±éŸ¿è¡Œå‹•è£ç½®çš„å‚¾æ–œæ§åˆ¶
                 * 
                 * GYRO_INVERT_Xï¼š
                 * - æ§åˆ¶æ˜¯å¦åè½‰å·¦å³å‚¾æ–œçš„æ–¹å‘
                 * - trueï¼šè£ç½®å·¦å‚¾æ™‚ç•«é¢å‘å³ç§»å‹•ï¼ˆæ›´ç›´è§€ï¼‰
                 * - falseï¼šè£ç½®å·¦å‚¾æ™‚ç•«é¢å‘å·¦ç§»å‹•
                 * 
                 * ğŸ¯ èª¿æ•´å»ºè­°ï¼š
                 * - æƒ³è¦æ›´æ•æ„Ÿçš„æ»‘é¼ æ§åˆ¶ â†’ å¢åŠ  PARALLAX_INTENSITY
                 * - æƒ³è¦æ›´æ•æ„Ÿçš„é™€èºå„€æ§åˆ¶ â†’ å¢åŠ  GYRO_SENSITIVITY
                 * - æƒ³è¦æ›´å¼·çƒˆçš„æ·±åº¦æ•ˆæœ â†’ å¢åŠ  DEPTH_SENSITIVITY  
                 * - æƒ³è¦æ›´ç´°è†©çš„æ•ˆæœ â†’ åŒæ™‚é™ä½æ‰€æœ‰æ•¸å€¼
                 */
                
                // åœ–å±¤è³‡è¨Š - æŒ‰ç…§å¾å¾Œåˆ°å‰çš„é †åºï¼ˆ7æœ€å¾Œé¢ï¼Œ1æœ€å‰é¢ï¼‰
                this.layerInfo = [
                    { name: '0_7_BG' },        // æœ€åº•å±¤èƒŒæ™¯
                    { name: '0_6_RabbitBack' }, // å¾Œæ–¹å…”å­
                    { name: '0_5_Volume' },     // é«”ç©éœ§
                    { name: '0_4_RabbitMain' }, // ä¸»è¦å…”å­
                    { name: '0_3_Text' },       // æ–‡å­—
                    { name: '0_2_Dust' },       // å¡µåŸƒï¼ˆç¾åœ¨åœ¨æ–‡å­—ä¹‹ä¸Šï¼‰
                    { name: '0_1_RabbitFornt' } // æœ€å‰å±¤å…”å­
                ];
                
                // ğŸ” å±€éƒ¨åœ–é…ç½®è³‡æ–™ - èˆ‡é»é»å°æ‡‰
                this.detailLayerInfo = [
                    { name: '1_0_All', dotId: 'dot1', group: 'detailGroup1' },
                    { name: '2_0_All', dotId: 'dot2', group: 'detailGroup2' },
                    { name: '3_0_All', dotId: 'dot3', group: 'detailGroup3' }
                ];
                
                this.init();
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       window.innerWidth <= 768;
            }

            // ğŸ® æª¢æ¸¬æ˜¯å¦éœ€è¦æ¬Šé™è«‹æ±‚
            needsGyroPermission() {
                return typeof DeviceOrientationEvent.requestPermission === 'function';
            }

            // ğŸ® ç²å–åˆå§‹è¢å¹•æ–¹å‘
            getInitialOrientation() {
                if (screen.orientation && screen.orientation.angle !== undefined) {
                    return screen.orientation.angle;
                }
                return window.orientation || 0;
            }

            // ğŸ›ï¸ ç²å–ç•¶å‰è¢å¹•æ–¹å‘
            getScreenOrientation() {
                // å„ªå…ˆä½¿ç”¨ Screen Orientation API
                if (screen.orientation && screen.orientation.type) {
                    return screen.orientation.type.split('-')[0] + '-' + screen.orientation.type.split('-')[1];
                }
                
                // å›é€€åˆ°è§’åº¦åˆ¤æ–·
                const angle = screen.orientation ? screen.orientation.angle : window.orientation;
                switch (angle) {
                    case 0: return 'portrait-primary';
                    case 90: return 'landscape-primary';
                    case -90:
                    case 270: return 'landscape-secondary';
                    case 180: return 'portrait-secondary';
                    default: return 'portrait-primary';
                }
            }

            // ğŸ® ================== æ··åˆæ§åˆ¶ç³»çµ±æ ¸å¿ƒæ–¹æ³• ==================

            // ğŸ›ï¸ æ ¹æ“šè¢å¹•æ–¹å‘è½‰æ›é™€èºå„€æ•¸å€¼
            transformGyroData(alpha, beta, gamma) {
                let x, y;
                
                // ç²å–è¢å¹•æ–¹å‘è§’åº¦é€²è¡Œåˆå§‹è£œå„Ÿ
                const orientationAngle = screen.orientation?.angle || window.orientation || 0;
                
                switch (this.currentOrientation) {
                    case 'portrait-primary':
                        x = gamma;
                        y = beta;
                        break;
                    case 'portrait-secondary':
                        x = -gamma;
                        y = -beta;
                        break;
                    case 'landscape-primary':
                        x = beta;
                        y = -gamma;
                        break;
                    case 'landscape-secondary':
                        x = -beta;
                        y = gamma;
                        break;
                    default:
                        x = gamma;
                        y = beta;
                }
                
                return { x, y };
            }

            // ğŸ® å•Ÿå‹•é™€èºå„€æ§åˆ¶ï¼ˆåƒ…è² è²¬æˆæ¬Šèˆ‡äº‹ä»¶è¨»å†Šï¼‰
            async startGyroControl() {
                // æª¢æŸ¥æ˜¯å¦æ”¯æ´é™€èºå„€
                if (!('DeviceOrientationEvent' in window)) {
                    console.log('âŒ è£ç½®ä¸æ”¯æ´é™€èºå„€');
                    return false;
                }
                
                // å˜—è©¦è«‹æ±‚æ¬Šé™ï¼ˆåƒ…iOS 13+ï¼‰
                if (this.needsGyroPermission()) {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.gyroPermissionGranted = true;
                            console.log('âœ… é™€èºå„€æ¬Šé™å·²æˆæ¬Š');
                        } else {
                            console.log('âŒ é™€èºå„€æ¬Šé™è¢«æ‹’çµ•');
                            return false;
                        }
                    } catch (error) {
                        console.log('âŒ é™€èºå„€æ¬Šé™è«‹æ±‚å¤±æ•—:', error);
                        return false;
                    }
                } else {
                    // å…¶ä»–è£ç½®ï¼ˆAndroid æˆ–èˆŠ iOSï¼‰ç›´æ¥å•Ÿç”¨
                    this.gyroPermissionGranted = true;
                }
                
                // è¨»å†Šé™€èºå„€äº‹ä»¶ï¼ˆå¸¸é§ï¼‰
                this.gyroActive = true;
                this.registerGyroEvents();
                console.log('ğŸ® é™€èºå„€äº‹ä»¶å·²è¨»å†Š');
                
                // é‡è¨­åŸºæº–å€¼ï¼Œç­‰å¾…ç¬¬ä¸€ç­† deviceorientation äº‹ä»¶
                this.baseX = null;
                this.baseY = null;
                
                return true;
            }

            // ğŸ® åœæ­¢é™€èºå„€æ§åˆ¶ï¼ˆåƒ…è¨­å®šç‹€æ…‹ï¼Œä¸ç§»é™¤äº‹ä»¶ï¼‰
            stopGyroControl() {
                this.gyroActive = false;
                console.log('ğŸ® é™€èºå„€æ§åˆ¶å·²åœç”¨ï¼ˆäº‹ä»¶ä¿æŒè¨»å†Šï¼‰');
            }

            // ğŸ® é‡ç½®é™€èºå„€åŸºæº–å€¼
            resetGyroBase() {
                if (!this.gyroActive || this.currentControlMode !== 'gyro') {
                    console.log('ğŸ® é™€èºå„€æœªå•Ÿç”¨æˆ–ä¸åœ¨é™€èºå„€æ¨¡å¼ï¼Œç„¡æ³•é‡ç½®');
                    return false;
                }
                
                // é–‹å§‹500msçš„éæ¸¡å‹•ç•«
                this.startResetTransition();
                
                return true;
            }

            // ğŸ® é–‹å§‹é‡ç½®éæ¸¡å‹•ç•«
            startResetTransition() {
                const transitionDuration = 500; // 500ms
                const startTime = Date.now();
                const startOffsetX = this.currentOffsetX;
                const startOffsetY = this.currentOffsetY;
                
                // è¨­å®šé‡ç½®ç‹€æ…‹ï¼Œé˜²æ­¢é™€èºå„€æ›´æ–°è¦†è“‹éæ¸¡å€¼
                this.isResetting = true;
                
                console.log('ğŸ® é–‹å§‹é‡ç½®è¦–è§’éæ¸¡å‹•ç•«');
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / transitionDuration, 1);
                    
                    // ä½¿ç”¨ç·©å‡ºå‡½æ•¸ (ease-out) è®“å‹•ç•«æ›´è‡ªç„¶
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    
                    // å¾ç•¶å‰åç§»å€¼å¹³æ»‘éæ¸¡åˆ°0
                    this.currentOffsetX = startOffsetX * (1 - easedProgress);
                    this.currentOffsetY = startOffsetY * (1 - easedProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // å‹•ç•«å®Œæˆï¼Œé‡è¨­åŸºæº–å€¼
                        this.currentOffsetX = 0;
                        this.currentOffsetY = 0;
                        this.baseX = null;
                        this.baseY = null;
                        this.smoothedDelta = { x: 0, y: 0 };
                        
                        // æ¸…é™¤é‡ç½®ç‹€æ…‹ï¼Œå…è¨±é™€èºå„€æ­£å¸¸æ›´æ–°
                        this.isResetting = false;
                        
                        console.log('ğŸ® é‡ç½®è¦–è§’éæ¸¡å‹•ç•«å®Œæˆï¼ŒåŸºæº–å€¼å·²é‡ç½®');
                    }
                };
                
                animate();
            }

            // ğŸ® å•Ÿå‹•æŒ‡é‡æ§åˆ¶ï¼ˆåƒ…åˆ‡æ›æ¨¡å¼ï¼Œä¸åœæ­¢é™€èºå„€ï¼‰
            startPointerControl() {
                if (this.currentControlMode === 'pointer') return;
                
                this.currentControlMode = 'pointer';
                this.lastPointerTime = Date.now();
                
                console.log('ğŸ® åˆ‡æ›åˆ°æŒ‡é‡æ§åˆ¶æ¨¡å¼');
            }

            // ğŸ® åœæ­¢æŒ‡é‡æ§åˆ¶
            stopPointerControl() {
                if (this.currentControlMode !== 'pointer') return;
                
                this.currentControlMode = 'none';
                console.log('ğŸ® æŒ‡é‡æ§åˆ¶å·²åœæ­¢');
            }

            // ğŸ® å¾é™€èºå„€æ›´æ–°æ§åˆ¶å€¼
            updateFromGyro(alpha, beta, gamma) {
                // æª¢æŸ¥æ§åˆ¶æ¨¡å¼ï¼Œåªæœ‰åœ¨é™€èºå„€æ¨¡å¼æ™‚æ‰æ›´æ–°
                if (this.currentControlMode !== 'gyro') return;
                
                // æ ¹æ“šè¢å¹•æ–¹å‘è½‰æ›ç‚ºçµ±ä¸€çš„X/Yè»¸
                const { x, y } = this.transformGyroData(alpha, beta, gamma);

                // ç¬¬ä¸€æ¬¡é€²ä¾†æ™‚å»ºç«‹åŸºæº–å€¼
                if (this.baseX === null) {
                    this.baseX = x;
                    this.baseY = y;
                    console.log('ğŸ›ï¸ å»ºç«‹é™€èºå„€åŸºæº–å€¼:', {
                        orientation: this.currentOrientation,
                        baseX: this.baseX.toFixed(2),
                        baseY: this.baseY.toFixed(2)
                    });
                    return; // ç›´æ¥ returnï¼Œç­‰å¾…ä¸‹ä¸€ç­†å·®å€¼
                }

                // è¨ˆç®—å·®å€¼
                let deltaX = (x - this.baseX) / 45; // æ¨™æº–åŒ–åˆ° Â±1 ç¯„åœ
                let deltaY = (y - this.baseY) / 45;

                // æ‡‰ç”¨éˆæ•åº¦åƒæ•¸
                deltaX *= this.GYRO_SENSITIVITY;
                deltaY *= this.GYRO_SENSITIVITY;

                // é™åˆ¶ç¯„åœ
                deltaX = THREE.MathUtils.clamp(deltaX, -1, 1);
                deltaY = THREE.MathUtils.clamp(deltaY, -1, 1);

                // ğŸ”„ æ‡‰ç”¨å·¦å³åè½‰è¨­å®š
                if (this.GYRO_INVERT_X) {
                    deltaX = -deltaX;
                }

                // ä½é€šæ¿¾æ³¢å¹³æ»‘è™•ç†
                this.smoothedDelta.x = this.smoothedDelta.x * (1 - this.SMOOTH_ALPHA) + deltaX * this.SMOOTH_ALPHA;
                this.smoothedDelta.y = this.smoothedDelta.y * (1 - this.SMOOTH_ALPHA) + deltaY * this.SMOOTH_ALPHA;

                // æ›´æ–°çµ±ä¸€è¼¸å‡ºå€¼ï¼ˆåªæœ‰åœ¨éé‡ç½®éæ¸¡æœŸé–“æ‰æ›´æ–°ï¼‰
                if (!this.isResetting) {
                    this.currentOffsetX = this.smoothedDelta.x;
                    this.currentOffsetY = this.smoothedDelta.y;
                }
            }

            // ğŸ® å¾æŒ‡é‡æ›´æ–°æ§åˆ¶å€¼
            updateFromPointer(x, y) {
                // è¨ˆç®—æ¨™æº–åŒ–çš„åç§»å€¼ (-1 åˆ° +1)
                const offsetX = (x / window.innerWidth) * 2 - 1;
                const offsetY = -(y / window.innerHeight) * 2 + 1; // åè½‰Yè»¸
                
                // æ›´æ–°ç›®æ¨™æ»‘é¼ ä½ç½®ï¼ˆç”¨æ–¼æ’å€¼ï¼‰
                this.targetMouse.x = offsetX;
                this.targetMouse.y = offsetY;
                
                // è¨ˆç®—æ»‘é¼ ç§»å‹•é€Ÿåº¦ï¼ˆç”¨æ–¼æ…£æ€§æ•ˆæœï¼‰
                if (!this.isMobile) {
                    this.mouseVelocity.x = offsetX - this.mouse.x;
                    this.mouseVelocity.y = offsetY - this.mouse.y;
                }
                
                // æ›´æ–°æ»‘é¼ ä½ç½®ï¼ˆç”¨æ–¼é€Ÿåº¦è¨ˆç®—ï¼‰
                this.mouse.x = offsetX;
                this.mouse.y = offsetY;
                
                // æ›´æ–°çµ±ä¸€è¼¸å‡ºå€¼
                this.currentOffsetX = offsetX;
                this.currentOffsetY = offsetY;
                
                // æ›´æ–°æœ€å¾ŒæŒ‡é‡æ™‚é–“
                this.lastPointerTime = Date.now();
            }

            // ğŸ® è¨»å†Šé™€èºå„€äº‹ä»¶ï¼ˆå¸¸é§ï¼‰
            registerGyroEvents() {
                if (!this.gyroActive) return;
                
                this.gyroHandler = (event) => {
                    // ä¿ç•™ deviceorientation äº‹ä»¶ã€Œå¸¸é§ã€ï¼›Pointer æ¨¡å¼åƒ…å¿½ç•¥å…¶è¼¸å‡ºï¼Œä¸åœæ­¢äº‹ä»¶
                    if (this.currentControlMode === 'gyro') {
                        this.updateFromGyro(event.alpha || 0, event.beta || 0, event.gamma || 0);
                    }
                };
                
                window.addEventListener('deviceorientation', this.gyroHandler);
            }

            // ğŸ® ç§»é™¤é™€èºå„€äº‹ä»¶
            removeGyroEvents() {
                if (this.gyroHandler) {
                    window.removeEventListener('deviceorientation', this.gyroHandler);
                    this.gyroHandler = null;
                }
            }

            // ğŸ® æª¢æŸ¥æ§åˆ¶æ¨¡å¼åˆ‡æ›
            checkControlModeSwitch() {
                const now = Date.now();
                
                // å¦‚æœæ˜¯æŒ‡é‡æ¨¡å¼ä¸”è¶…éè¶…æ™‚æ™‚é–“ï¼Œåˆ‡æ›å›é™€èºå„€
                // åªåœ¨è¡Œå‹•ç‰ˆä¸”æœ‰é™€èºå„€æ¬Šé™æ™‚æ‰åˆ‡æ›
                if (this.currentControlMode === 'pointer' && 
                    this.isMobile &&
                    (now - this.lastPointerTime) > this.POINTER_TIMEOUT &&
                    this.gyroPermissionGranted) {
                    
                    this.currentControlMode = 'gyro';
                    console.log('ğŸ® è‡ªå‹•åˆ‡æ›åˆ°é™€èºå„€æ§åˆ¶æ¨¡å¼');
                }
            }

            // ğŸ® é¡¯ç¤ºé‡ç½®é™€èºå„€æŒ‰éˆ•
            showResetGyroButton() {
                const resetButton = document.getElementById('reset-gyro-button');
                if (resetButton && this.isMobile && this.gyroPermissionGranted) {
                    resetButton.style.display = 'flex';
                    console.log('ğŸ® é¡¯ç¤ºé‡ç½®é™€èºå„€æŒ‰éˆ•');
                }
            }

            // ğŸ® éš±è—é‡ç½®é™€èºå„€æŒ‰éˆ•
            hideResetGyroButton() {
                const resetButton = document.getElementById('reset-gyro-button');
                if (resetButton) {
                    resetButton.style.display = 'none';
                    console.log('ğŸ® éš±è—é‡ç½®é™€èºå„€æŒ‰éˆ•');
                }
            }

            // çµ±ä¸€çš„åœ–ç‰‡å°ºå¯¸è¨ˆç®—å‡½æ•¸
            calculateImageSize(texture = null) {
                // å¦‚æœæœ‰å‚³å…¥ textureï¼Œä½¿ç”¨å…¶åŸå§‹æ¯”ä¾‹ï¼›å¦å‰‡ä½¿ç”¨é è¨­æ¯”ä¾‹
                let aspectRatio;
                if (texture && texture.image) {
                    aspectRatio = texture.image.width / texture.image.height;
                    console.log(`ä½¿ç”¨åœ–ç‰‡åŸå§‹æ¯”ä¾‹: ${texture.image.width}x${texture.image.height} (æ¯”ä¾‹: ${aspectRatio.toFixed(3)})`);
                } else {
                    aspectRatio = 1920 / 1080; // æ–°çš„é è¨­æ¯”ä¾‹
                    console.log(`ä½¿ç”¨é è¨­æ¯”ä¾‹: 1920x1080 (æ¯”ä¾‹: ${aspectRatio.toFixed(3)})`);
                }
                
                const distance = 5;
                const fov = 75 * Math.PI / 180;
                const worldHeight = 2 * Math.tan(fov / 2) * distance;
                const worldWidth = worldHeight * (window.innerWidth / window.innerHeight);
                
                // è¨ˆç®—è¦–çª—é•·å¯¬æ¯”
                const windowAspectRatio = window.innerWidth / window.innerHeight;
                
                let width, height;
                
                // è‡ªå‹•æ¯”è¼ƒè¦–çª—é•·å¯¬æ¯”èˆ‡åœ–ç‰‡é•·å¯¬æ¯”ï¼Œæ±ºå®šä»¥å¯¬åº¦æˆ–é«˜åº¦ç‚ºä¸»
                if (windowAspectRatio >= aspectRatio) {
                    // è¦–çª—æ¯”åœ–ç‰‡å¯¬ï¼ˆæˆ–ç›¸ç­‰ï¼‰ï¼Œä»¥å¯¬åº¦ç‚ºä¸»
                    width = worldWidth * this.IMAGE_SCALE;
                    height = width / aspectRatio;
                } else {
                    // è¦–çª—æ¯”åœ–ç‰‡çª„ï¼Œä»¥é«˜åº¦ç‚ºä¸»
                    height = worldHeight * this.IMAGE_SCALE;
                    width = height * aspectRatio;
                }
                
                return { width, height };
            }

            setupLoadingScene() {
                // å»ºç«‹è¼‰å…¥å ´æ™¯
                this.loadingScene = new THREE.Scene();
                
                // å»ºç«‹è¼‰å…¥ç›¸æ©Ÿ
                this.loadingCamera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.loadingCamera.position.z = 5;
                
                // å»ºç«‹è¼‰å…¥æ¸²æŸ“å™¨
                this.loadingRenderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('loading-canvas'),
                    antialias: true,
                    alpha: true
                });
                this.loadingRenderer.setSize(window.innerWidth, window.innerHeight);
                this.loadingRenderer.setClearColor(0x000000, 1);
            }

            loadLoadingCover() {
                console.log('é–‹å§‹è¼‰å…¥å°é¢åœ–ç‰‡...');
                const loader = new THREE.TextureLoader();
                loader.load(
                    'images/Loading.png',
                    (texture) => {
                        console.log('å°é¢åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼Œé–‹å§‹æ·¡å…¥å‹•ç•«');
                        this.createLoadingMesh(texture);
                        this.loadingCoverLoaded = true;
                        
                        // å°é¢åœ–è¼‰å…¥å®Œæˆå¾Œæ‰é–‹å§‹æ·¡å…¥å‹•ç•«
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            // æ·¡å…¥å‹•ç•«å®Œæˆå¾Œé–‹å§‹è¼‰å…¥å…¶ä»–åœ–ç‰‡
                            setTimeout(() => {
                                console.log('å°é¢åœ–æ·¡å…¥å®Œæˆï¼Œé–‹å§‹è¼‰å…¥å…¶ä»–åœ–ç‰‡');
                                this.loadLayers();
                            }, 500); // ç­‰å¾…0.5ç§’æ·¡å…¥å®Œæˆ
                        }, 50); // çŸ­æš«å»¶é²ç¢ºä¿æ¸²æŸ“å®Œæˆ
                    },
                    undefined,
                    (error) => {
                        console.warn('å°é¢åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é»‘è‰²èƒŒæ™¯ä¸¦é–‹å§‹è¼‰å…¥å…¶ä»–åœ–ç‰‡');
                        this.loadingCoverLoaded = true;
                        
                        // å³ä½¿è¼‰å…¥å¤±æ•—ä¹Ÿè¦é–‹å§‹æ·¡å…¥å’Œè¼‰å…¥å…¶ä»–åœ–ç‰‡
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            setTimeout(() => {
                                this.loadLayers();
                            }, 500);
                        }, 50);
                    }
                );
            }

            createLoadingMesh(texture) {
                // ä½¿ç”¨çµ±ä¸€çš„å°ºå¯¸è¨ˆç®—å‡½æ•¸ï¼Œå‚³å…¥ texture ä»¥ç²å–åŸå§‹æ¯”ä¾‹
                const { width, height } = this.calculateImageSize(texture);

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                // å­˜å„² texture å¼•ç”¨ä»¥ä¾¿ resize æ™‚é‡æ–°è¨ˆç®—
                mesh.userData.texture = texture;
                this.loadingScene.add(mesh);
            }

            init() {
                this.setupLoadingScene();
                this.setupScene();
                this.setupEventListeners();
                this.createLoadingParticles(); // å‰µå»ºè¼‰å…¥ç²’å­æ•ˆæœ
                this.randomizeSpinnerRings(); // è¨­å®šéš¨æ©Ÿæ—‹è½‰æ•ˆæœ
                
                // ğŸ­ è¨­å®šå±¤ç´šå¼•ç”¨
                this.loadingLayer = this.loadingScene; // è¼‰å…¥å±¤ï¼šThree.js å ´æ™¯
                this.uiLayer = document.getElementById('back-button'); // UIå±¤ï¼šDOM å…ƒç´ 
                
                this.loadLoadingCover(); // å„ªå…ˆè¼‰å…¥å°é¢åœ–
                this.animate();
            }

            createLoadingParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;

                // å®šç¾©è¼‰å…¥å‹•ç•«çš„é¡è‰²èª¿è‰²æ¿
                const colorPalette = [
                    {
                        bg: '#dc9c3b',
                        rgba: '220, 156, 59'
                    },
                    {
                        bg: '#d1936b', 
                        rgba: '209, 147, 107'
                    },
                    {
                        bg: '#f4e3d4',
                        rgba: '244, 227, 212'
                    }
                ];

                // å‰µå»º 10 å€‹ç²’å­
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // éš¨æ©Ÿé¸æ“‡é¡è‰²
                    const colorIndex = Math.floor(Math.random() * colorPalette.length);
                    const selectedColor = colorPalette[colorIndex];
                    
                    // éš¨æ©Ÿå¤§å° (1-2px)
                    const size = Math.random() * 1.6 + 0.8;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // è¨­å®šèƒŒæ™¯é¡è‰²
                    particle.style.background = selectedColor.bg;
                    
                    // è¨­å®šåŸºç¤ç™¼å…‰æ•ˆæœ
                    particle.style.boxShadow = `
                        0 0 6px rgba(${selectedColor.rgba}, 0.8),
                        0 0 12px rgba(${selectedColor.rgba}, 0.6),
                        0 0 18px rgba(${selectedColor.rgba}, 0.4),
                        0 0 24px rgba(${selectedColor.rgba}, 0.2)
                    `;
                    
                    // éš¨æ©Ÿæ°´å¹³ä½ç½® (10%-90%)ï¼Œé¿å…è²¼é‚Š
                    particle.style.left = (Math.random() * 80 + 10) + '%';
                    
                    // éš¨æ©Ÿé£„æµ®å‹•ç•«å»¶é²å’ŒæŒçºŒæ™‚é–“
                    const floatDelay = Math.random() * 1.5;
                    const floatDuration = Math.random() * 3 + 2.5;
                    
                    // éš¨æ©Ÿç™¼å…‰å‹•ç•«å»¶é²
                    const glowDelay = Math.random() * 0.5;
                    
                    // å‰µå»ºå”¯ä¸€çš„ç™¼å…‰å‹•ç•«åç¨±
                    const glowAnimationName = `particleGlow${i}`;
                    
                    // å‹•æ…‹å‰µå»ºç™¼å…‰å‹•ç•«çš„CSSè¦å‰‡
                    const glowKeyframes = `
                        @keyframes ${glowAnimationName} {
                            0% {
                                box-shadow: 
                                    0 0 6px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 12px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 18px rgba(${selectedColor.rgba}, 0.4),
                                    0 0 24px rgba(${selectedColor.rgba}, 0.2);
                                filter: brightness(1.2);
                            }
                            100% {
                                box-shadow: 
                                    0 0 10px rgba(${selectedColor.rgba}, 1),
                                    0 0 20px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 30px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 40px rgba(${selectedColor.rgba}, 0.3);
                                filter: brightness(1.5);
                            }
                        }
                    `;
                    
                    // å°‡å‹•ç•«è¦å‰‡æ·»åŠ åˆ°é é¢
                    const style = document.createElement('style');
                    style.textContent = glowKeyframes;
                    document.head.appendChild(style);
                    
                    // è¨­å®šè¤‡åˆå‹•ç•«ï¼šé£„æµ® + å€‹åˆ¥ç™¼å…‰
                    particle.style.animation = `
                        particleFloat ${floatDuration}s linear infinite ${floatDelay}s,
                        ${glowAnimationName} 2s ease-in-out infinite alternate ${glowDelay}s
                    `;
                    
                    particlesContainer.appendChild(particle);
                }
            }

            randomizeSpinnerRings() {
                const spinnerRings = document.querySelectorAll('.spinner-ring');
                
                spinnerRings.forEach((ring, index) => {
                    // éš¨æ©Ÿæ—‹è½‰é€Ÿåº¦ (1.5s - 4s)
                    const duration = Math.random() * 2 + 1.5;
                    
                    // éš¨æ©Ÿèµ·å§‹è§’åº¦ (0Â° - 360Â°)
                    const startAngle = Math.random() * 360;
                    
                    // éš¨æ©Ÿæ–¹å‘ (é †æ™‚é‡æˆ–é€†æ™‚é‡)
                    const direction = Math.random() > 0.5 ? 'normal' : 'reverse';
                    
                    // å‰µå»ºå”¯ä¸€çš„æ—‹è½‰å‹•ç•«åç¨±
                    const spinAnimationName = `spinnerSpin${index}`;
                    
                    // å‹•æ…‹å‰µå»ºæ—‹è½‰å‹•ç•«çš„CSSè¦å‰‡
                    const spinKeyframes = `
                        @keyframes ${spinAnimationName} {
                            0% { transform: rotate(${startAngle}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                            100% { transform: rotate(${startAngle + 360}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                        }
                    `;
                    
                    // å°‡å‹•ç•«è¦å‰‡æ·»åŠ åˆ°é é¢
                    const style = document.createElement('style');
                    style.textContent = spinKeyframes;
                    document.head.appendChild(style);
                    
                    // è¨­å®šå‹•ç•«
                    ring.style.animation = `${spinAnimationName} ${duration}s linear infinite`;
                    ring.style.animationDirection = direction;
                });
            }

            // æ›´æ–°æ‰€æœ‰åœ–å±¤çš„å°ºå¯¸
            updateAllLayerSizes() {
                // æ›´æ–°è¼‰å…¥å ´æ™¯ä¸­çš„ç¶²æ ¼
                if (this.loadingScene) {
                    this.loadingScene.children.forEach(mesh => {
                        if (mesh.userData.texture) {
                            const { width, height } = this.calculateImageSize(mesh.userData.texture);
                            mesh.geometry.dispose(); // é‡‹æ”¾èˆŠçš„å¹¾ä½•é«”
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        }
                    });
                }

                // æ›´æ–°ä¸»å ´æ™¯ä¸­çš„åœ–å±¤
                this.layers.forEach(layerGroup => {
                    if (layerGroup.userData.mainTexture) {
                        const { width, height } = this.calculateImageSize(layerGroup.userData.mainTexture);
                        
                        layerGroup.children.forEach(mesh => {
                            mesh.geometry.dispose(); // é‡‹æ”¾èˆŠçš„å¹¾ä½•é«”
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        });
                    }
                });

                // ğŸ”´ æ›´æ–°äº’å‹•é»é»çš„ä½ç½®å’Œç¸®æ”¾
                this.updateInteractiveDotsLayout();
                
                // ğŸ” æ›´æ–°å±€éƒ¨åœ–å±¤çš„ä½ç½®å’Œç¸®æ”¾
                this.updateDetailLayersLayout();
            }

            setupScene() {
                // å»ºç«‹å ´æ™¯
                this.scene = new THREE.Scene();
                
                // å»ºç«‹ç›¸æ©Ÿ
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 5;
                
                // å»ºç«‹æ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 1);
                
                // å•Ÿç”¨æ·±åº¦æ¸¬è©¦ä»¥ç¢ºä¿æ­£ç¢ºçš„åœ–å±¤é †åº
                this.renderer.sortObjects = true;
                
                // ğŸ­ å‰µå»ºä¸»è¦åœ–å±¤çµ„å®¹å™¨ (7_BG~1_RabbitFornt)
                this.mainLayerGroup = new THREE.Group();
                this.mainLayerGroup.name = 'MainContentLayers';
                this.scene.add(this.mainLayerGroup);
                
                // ğŸ”´ å‰µå»ºäº’å‹•é»é»å®¹å™¨
                this.dotsGroup = new THREE.Group();
                this.dotsGroup.name = 'InteractiveDots';
                this.scene.add(this.dotsGroup);
                
                // ğŸ” å‰µå»ºå±€éƒ¨åœ–å®¹å™¨
                this.detailGroup1 = new THREE.Group();
                this.detailGroup1.name = 'DetailLayer1';
                this.detailGroup1.renderOrder = 0.08;
                this.scene.add(this.detailGroup1);
                
                this.detailGroup2 = new THREE.Group();
                this.detailGroup2.name = 'DetailLayer2';
                this.detailGroup2.renderOrder = 0.07;
                this.scene.add(this.detailGroup2);
                
                this.detailGroup3 = new THREE.Group();
                this.detailGroup3.name = 'DetailLayer3';
                this.detailGroup3.renderOrder = 0.06;
                this.scene.add(this.detailGroup3);
                
                // è¨­å®šåœ–å±¤çµ„å¼•ç”¨
                this.contentLayer = this.mainLayerGroup;
                console.log('âœ… å¤šå±¤ç´šæ¶æ§‹åˆå§‹åŒ–å®Œæˆ');
                console.log('ğŸ“± UIå±¤: z-index 3000+ (è¿”å›æŒ‰éˆ•ç­‰)');
                console.log('ğŸ¬ è¼‰å…¥å±¤: z-index 2000+ (å°é¢åœ–èˆ‡è¼‰å…¥å‹•ç•«)');
                console.log('ğŸ–¼ï¸ å…§å®¹å±¤: z-index 1000+ (ä¸»è¦åœ–å±¤çµ„)');
                console.log('ğŸ”´ äº’å‹•é»é»: renderOrder 1 (æœ€ä¸Šå±¤)');
                console.log('ğŸ” å±€éƒ¨åœ–å±¤: zè»¸ 0.06~0.08 (dot1:0.06, dot2:0.07, dot3:0.08), depthWrite:false');
                console.log('ğŸ–¼ï¸ ä¸»è¦åœ–å±¤: renderOrder 0 (æœ€ä¸‹å±¤)');
            }

            setupEventListeners() {
                // ğŸ® ================== æ··åˆæ§åˆ¶äº‹ä»¶ç›£è½å™¨ ==================
                
                // ğŸ›ï¸ è¢å¹•æ–¹å‘è®ŠåŒ–ç›£è½
                const handleOrientationChange = () => {
                    const newOrientation = this.getScreenOrientation();
                    if (newOrientation !== this.currentOrientation) {
                        console.log(`ğŸ”„ è¢å¹•æ–¹å‘è®ŠåŒ–: ${this.currentOrientation} â†’ ${newOrientation}`);
                        this.currentOrientation = newOrientation;
                        // é‡è¨­åŸºæº–å€¼ï¼Œé¿å…ç¿»è½‰æ™‚è·³å‹•
                        this.baseX = null;
                        this.baseY = null;
                        this.smoothedDelta = { x: 0, y: 0 };
                    }
                };

                // ç›£è½æ–¹å‘è®ŠåŒ–äº‹ä»¶
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', handleOrientationChange);
                } else {
                    window.addEventListener('orientationchange', handleOrientationChange);
                }

                // ğŸ® æŒ‡é‡äº‹ä»¶è™•ç†ï¼ˆæ»‘é¼ ã€è§¸æ§ã€æ»¾è¼ªï¼‰
                const handlePointerEvent = (event) => {
                    // åªåœ¨åµæ¸¬åˆ°ã€ŒçœŸå¯¦æ»‘é¼ ã€äº‹ä»¶æ™‚æ‰å•Ÿç”¨ Pointer æ¨¡å¼
                    // æ¡Œé¢ç‰ˆæ»‘é¼ äº‹ä»¶æ²’æœ‰ pointerTypeï¼Œè¡Œå‹•ç‰ˆéœ€è¦æª¢æŸ¥
                    if (this.isMobile && event.pointerType && event.pointerType !== 'mouse') return; // å¿½ç•¥ touch / pen
                    
                    // å•Ÿå‹•æŒ‡é‡æ§åˆ¶æ¨¡å¼
                    this.startPointerControl();
                    
                    // æ›´æ–°æ§åˆ¶å€¼
                    if (event.type === 'wheel') {
                        // æ»¾è¼ªäº‹ä»¶ï¼šä½¿ç”¨æ»‘é¼ ç•¶å‰ä½ç½®
                        this.updateFromPointer(this.mouse.x, this.mouse.y);
                    } else {
                        // æ»‘é¼ äº‹ä»¶ï¼šä½¿ç”¨äº‹ä»¶ä½ç½®
                        const x = event.clientX || 0;
                        const y = event.clientY || 0;
                        this.updateFromPointer(x, y);
                    }
                    
                    // ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶ - åªåœ¨å±€éƒ¨è¦–è§’ç”Ÿæ•ˆ
                    if (this.viewState === 'detail' && !this.isTransitioning) {
                        this.updateDetailViewControl(this.currentOffsetX, this.currentOffsetY);
                    }
                };

                // ğŸ® è§¸æ§äº‹ä»¶è™•ç†ï¼ˆåƒ…ç”¨æ–¼äº’å‹•ï¼Œä¸åˆ‡æ›æ§åˆ¶æ¨¡å¼ï¼‰
                const handleTouchEvent = (event) => {
                    // è§¸æ§äº‹ä»¶ä¸åˆ‡æ›æ§åˆ¶æ¨¡å¼ï¼Œä¿æŒç•¶å‰æ¨¡å¼
                    const x = event.touches?.[0]?.clientX || 0;
                    const y = event.touches?.[0]?.clientY || 0;
                    
                    // å¦‚æœç•¶å‰æ˜¯æŒ‡é‡æ¨¡å¼ï¼Œæ›´æ–°æ§åˆ¶å€¼
                    if (this.currentControlMode === 'pointer') {
                        this.updateFromPointer(x, y);
                    }
                    
                    // ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶ - åªåœ¨å±€éƒ¨è¦–è§’ç”Ÿæ•ˆ
                    if (this.viewState === 'detail' && !this.isTransitioning) {
                        this.updateDetailViewControl(this.currentOffsetX, this.currentOffsetY);
                    }
                };

                // è¨»å†ŠæŒ‡é‡äº‹ä»¶ï¼ˆåƒ…æ»‘é¼ ï¼‰
                document.addEventListener('mousemove', handlePointerEvent);
                document.addEventListener('wheel', handlePointerEvent, { passive: true });

                // è¨»å†Šè§¸æ§äº‹ä»¶ï¼ˆåƒ…ç”¨æ–¼äº’å‹•ï¼‰
                document.addEventListener('touchmove', handleTouchEvent, { passive: true });

                // ğŸ® æ¡Œé¢ç‰ˆå°ˆç”¨äº‹ä»¶ï¼ˆæ…£æ€§æ•ˆæœç­‰ï¼‰
                if (!this.isMobile) {
                    // æ»‘é¼ é›¢é–‹é é¢äº‹ä»¶
                    document.addEventListener('mouseleave', () => {
                        this.mouseInsidePage = false;
                        this.mouseJustReentered = false;
                        
                        // å•Ÿå‹•æ…£æ€§ç·©è¡æ•ˆæœ
                        const inertiaMultiplier = 1.5;
                        this.inertiaTarget.x = this.currentMouse.x + this.mouseVelocity.x * inertiaMultiplier;
                        this.inertiaTarget.y = this.currentMouse.y + this.mouseVelocity.y * inertiaMultiplier;
                        this.isInertiaActive = true;
                        
                        console.log('æ»‘é¼ é›¢é–‹é é¢ï¼Œå•Ÿå‹•æ…£æ€§ç·©è¡æ•ˆæœ');
                    });
                    
                    // æ»‘é¼ é€²å…¥é é¢äº‹ä»¶
                    document.addEventListener('mouseenter', () => {
                        if (!this.mouseInsidePage) {
                            this.mouseInsidePage = true;
                            this.mouseJustReentered = true;
                            console.log('æ»‘é¼ é‡æ–°é€²å…¥é é¢ï¼Œé–‹å§‹å¹³æ»‘éæ¸¡åˆ°æ–°ä½ç½®');
                        }
                    });
                }

                // ğŸ® ç¬¬ä¸€æ¬¡ä½¿ç”¨è€…äº’å‹•æ™‚å˜—è©¦å•Ÿç”¨é™€èºå„€
                const handleFirstInteraction = async () => {
                    if (this.currentControlMode === 'none') {
                        if (this.isMobile) {
                            console.log('ğŸ® æª¢æ¸¬åˆ°ç¬¬ä¸€æ¬¡ä½¿ç”¨è€…äº’å‹•ï¼Œå˜—è©¦å•Ÿç”¨é™€èºå„€');
                            
                            const gyroSuccess = await this.startGyroControl();
                            if (gyroSuccess) {
                                this.currentControlMode = 'gyro';
                            } else {
                                this.currentControlMode = 'pointer';
                            }
                        } else {
                            // æ¡Œé¢ç‰ˆç›´æ¥è¨­å®šç‚ºæŒ‡é‡æ§åˆ¶æ¨¡å¼
                            console.log('ğŸ® æ¡Œé¢ç‰ˆï¼Œè¨­å®šç‚ºæŒ‡é‡æ§åˆ¶æ¨¡å¼');
                            this.currentControlMode = 'pointer';
                        }
                    }
                    
                    // ç§»é™¤ä¸€æ¬¡æ€§äº‹ä»¶ç›£è½å™¨
                    document.removeEventListener('mousedown', handleFirstInteraction);
                    document.removeEventListener('touchstart', handleFirstInteraction);
                };

                // è¨»å†Šç¬¬ä¸€æ¬¡äº’å‹•äº‹ä»¶
                document.addEventListener('mousedown', handleFirstInteraction);
                document.addEventListener('touchstart', handleFirstInteraction);

                // ğŸ® æ»‘é¼ äº‹ä»¶ç›£è½ï¼ˆç”¨æ–¼è‡ªå‹•åˆ‡æ›åˆ° Pointer æ¨¡å¼ï¼‰
                const mouseEvents = ['mousedown', 'mousemove', 'wheel'];
                mouseEvents.forEach(eventType => {
                    document.addEventListener(eventType, (event) => {
                        // åªåœ¨åµæ¸¬åˆ°ã€ŒçœŸå¯¦æ»‘é¼ ã€äº‹ä»¶æ™‚æ‰åˆ‡æ›
                        // æ¡Œé¢ç‰ˆæ»‘é¼ äº‹ä»¶æ²’æœ‰ pointerTypeï¼Œè¡Œå‹•ç‰ˆéœ€è¦æª¢æŸ¥
                        if (this.isMobile && event.pointerType && event.pointerType !== 'mouse') return;
                        
                        // è¨˜éŒ„æœ€å¾Œæ»‘é¼ äº’å‹•æ™‚é–“
                        this.lastPointerTime = Date.now();
                        
                        // å¦‚æœç•¶å‰æ˜¯é™€èºå„€æ¨¡å¼ï¼Œåˆ‡æ›åˆ°æŒ‡é‡æ¨¡å¼
                        if (this.currentControlMode === 'gyro') {
                            this.currentControlMode = 'pointer';
                            console.log('ğŸ® æª¢æ¸¬åˆ°æ»‘é¼ äº’å‹•ï¼Œåˆ‡æ›åˆ°æŒ‡é‡æ§åˆ¶æ¨¡å¼');
                        }
                    }, { passive: true });
                });

                // è¦–çª—å¤§å°èª¿æ•´
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    // åŒæ™‚èª¿æ•´è¼‰å…¥å ´æ™¯
                    if (this.loadingCamera && this.loadingRenderer) {
                        this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                        this.loadingCamera.updateProjectionMatrix();
                        this.loadingRenderer.setSize(window.innerWidth, window.innerHeight);
                    }

                    // è‡ªå‹•é‡æ–°è¨ˆç®—ä¸¦èª¿æ•´æ‰€æœ‰åœ–å±¤çš„ PlaneGeometry
                    this.updateAllLayerSizes();
                });
            }

            loadLayers() {
                // åªè¨ˆç®—ä¸»åœ–ï¼Œå› ç‚ºæ·±åº¦åœ–å’Œç™¼å…‰åœ–å¯èƒ½ä¸å­˜åœ¨ï¼ˆå°é¢åœ–ä¸è¨ˆå…¥ï¼‰
                this.totalImages = this.layerInfo.length;
                console.log(`é–‹å§‹è¼‰å…¥ ${this.totalImages} å¼µä¸»è¦åœ–ç‰‡`);
                
                this.layerInfo.forEach((layerData, index) => {
                    this.loadLayer(layerData, index);
                });
            }

            loadLayer(layerData, index) {
                const loader = new THREE.TextureLoader();
                const layerGroup = new THREE.Group();
                
                // è¼‰å…¥ä¸»åœ–
                console.log(`æ­£åœ¨è¼‰å…¥: ${layerData.name}.png`);
                loader.load(
                    `images/${layerData.name}.png`,
                    (mainTexture) => {
                        console.log(`æˆåŠŸè¼‰å…¥ä¸»åœ–: ${layerData.name}.png`);
                        // è¼‰å…¥æ·±åº¦åœ–
                        loader.load(
                            `images/${layerData.name}_depth.png`,
                            (depthTexture) => {
                                // è¼‰å…¥ç™¼å…‰åœ–
                                loader.load(
                                    `images/${layerData.name}_glow.png`,
                                    (glowTexture) => {
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index);
                                        this.onImageLoaded();
                                    },
                                    undefined,
                                    () => {
                                        // ç™¼å…‰åœ–è¼‰å…¥å¤±æ•—ï¼Œåªä½¿ç”¨ä¸»åœ–å’Œæ·±åº¦åœ–
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, null, layerData, index);
                                        this.onImageLoaded();
                                    }
                                );
                            },
                            undefined,
                            (error) => {
                                console.warn(`æ·±åº¦åœ–è¼‰å…¥å¤±æ•—: ${layerData.name}_depth.png`);
                                this.createLayerMesh(layerGroup, mainTexture, null, null, layerData, index);
                                this.onImageLoaded();
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`ä¸»åœ–è¼‰å…¥å¤±æ•—: ${layerData.name}.png`, error);
                        this.onImageLoaded(); // ä¿®æ­£ï¼šè¼‰å…¥å¤±æ•—ä¹Ÿè¦è¨ˆæ•¸
                    }
                );
            }

            createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index) {
                // ä½¿ç”¨çµ±ä¸€çš„å°ºå¯¸è¨ˆç®—å‡½æ•¸ï¼Œå‚³å…¥ mainTexture ä»¥ç²å–åŸå§‹æ¯”ä¾‹
                const { width, height } = this.calculateImageSize(mainTexture);

                // å¦‚æœæœ‰æ·±åº¦åœ–ï¼Œä½¿ç”¨è‡ªå®šç¾© Shader ä¾†å¯¦ç¾åŸºæ–¼æ·±åº¦åœ–çš„è¦–å·®
                if (depthTexture) {
                    const vertexShader = `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;
                    
                    const fragmentShader = `
                        uniform sampler2D mainTexture;
                        uniform sampler2D depthTexture;
                        uniform vec2 parallaxOffset;
                        uniform float parallaxStrength;
                        varying vec2 vUv;
                        
                        void main() {
                            // è®€å–æ·±åº¦åœ–çš„ç°éšå€¼
                            float depth = texture2D(depthTexture, vUv).r;
                            
                            // æ ¹æ“šæ·±åº¦å€¼è¨ˆç®—è¦–å·®åç§» - ä¿®æ­£è¨ˆç®—æ–¹å¼
                            vec2 offset = parallaxOffset * (depth - 0.625) * parallaxStrength;
                            vec2 parallaxUV = vUv + offset;
                            
                            // æª¢æŸ¥æ˜¯å¦è¶…å‡ºé‚Šç•Œ
                            if (parallaxUV.x < 0.0 || parallaxUV.x > 1.0 || parallaxUV.y < 0.0 || parallaxUV.y > 1.0) {
                                // è¶…å‡ºé‚Šç•Œæ™‚ï¼Œä½¿ç”¨åŸå§‹UVå–æ¨£
                                parallaxUV = vUv;
                            }
                            
                            // å–æ¨£ä¸»ç´‹ç†
                            vec4 color = texture2D(mainTexture, parallaxUV);
                            gl_FragColor = color;
                        }
                    `;

                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                    // å»ºç«‹ç™¼å…‰åœ–å±¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰- å¿…é ˆåœ¨ä¸»åœ–å±¤ä¹‹å‰åŠ å…¥
                    if (glowTexture) {
                        console.log(`è¼‰å…¥ç™¼å…‰åœ–å±¤: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                mainTexture: { value: glowTexture },
                                depthTexture: { value: depthTexture },
                                parallaxOffset: { value: new THREE.Vector2(0, 0) },
                                parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                            },
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // é‡è¦ï¼šé¿å…æ·±åº¦è¡çª
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // ç¨å¾®å¾€å¾Œæ”¾ï¼Œåœ¨ä¸»åœ–ä¸‹å±¤
                        layerGroup.add(glowMesh);
                    }

                    // å»ºç«‹ä¸»åœ–å±¤
                    const mainMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            mainTexture: { value: mainTexture },
                            depthTexture: { value: depthTexture },
                            parallaxOffset: { value: new THREE.Vector2(0, 0) },
                            parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                } else {
                    // æ²’æœ‰æ·±åº¦åœ–ï¼Œä½¿ç”¨åŸºæœ¬æè³ª
                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                                                                if (glowTexture) {
                        console.log(`è¼‰å…¥ç™¼å…‰åœ–å±¤ï¼ˆç„¡æ·±åº¦åœ–ï¼‰: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            map: glowTexture,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // é¿å…æ·±åº¦è¡çª
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // åœ¨ä¸»åœ–ä¸‹å±¤
                        layerGroup.add(glowMesh);
                    }

                    const mainMaterial = new THREE.MeshBasicMaterial({
                        map: mainTexture,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                }

                // æ ¹æ“šåœ–å±¤ç·¨è™Ÿè¨­å®šZä½ç½® - ç·¨è™Ÿè¶Šå°è¶Šåœ¨å‰é¢
                const layerNumber = parseInt(layerData.name.split('_')[1]); // å– Main_7_BG ä¸­çš„ "7"
                layerGroup.position.z = (7 - layerNumber) * 0.01; // 1è™Ÿæœ€å‰é¢(z=0.06)ï¼Œ7è™Ÿæœ€å¾Œé¢(z=0)
                layerGroup.userData = {
                    depthTexture: depthTexture,
                    hasDepth: !!depthTexture,
                    mainTexture: mainTexture // å­˜å„²ä¸»ç´‹ç†å¼•ç”¨ä»¥ä¾¿ resize æ™‚é‡æ–°è¨ˆç®—
                };

                this.layers.push(layerGroup);
                this.mainLayerGroup.add(layerGroup); // æ·»åŠ åˆ°ä¸»è¦åœ–å±¤çµ„å®¹å™¨
            }

            onImageLoaded() {
                this.loadedImages++;
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // ğŸŒ«ï¸ ç¢ºä¿åˆå§‹ç‹€æ…‹æ²’æœ‰æ¨¡ç³Šæ•ˆæœ
                    this.resetTransitionBlur();
                    
                    // ğŸ”´ è¼‰å…¥å®Œæˆå¾Œå‰µå»ºäº’å‹•é»é»
                    this.createInteractiveDots();
                    
                    // ğŸ” è¼‰å…¥å±€éƒ¨åœ–å±¤
                    this.loadDetailLayers();
                    
                    // è¼‰å…¥å®Œæˆå¾Œï¼Œé–‹å§‹æ·¡å‡ºå°é¢
                    setTimeout(() => {
                        this.startFadeOut();
                    }, 1000); // å»¶é²1ç§’é–‹å§‹æ·¡å‡º
                }
            }

            startFadeOut() {
                const cover = document.getElementById('loading-cover');
                console.log('é–‹å§‹å°é¢æ·¡å‡ºå‹•ç•«');
                
                // ç§»é™¤æ·¡å…¥ class
                cover.classList.remove('fade-in');
                
                // ä½¿ç”¨å…©æ¬¡ requestAnimationFrame ç¢ºä¿æµæš¢æ·¡å‡º
                requestAnimationFrame(() => {       // è®“ç¬¬ä¸€å¹€å‘ˆç¾ opacity:1
                    requestAnimationFrame(() => {     // ç¬¬äºŒå¹€å†åŠ å‹•ç•« class
                        cover.classList.add('fade-out');
                    });
                });
                
                // ç›£è½å‹•ç•«çµæŸäº‹ä»¶
                cover.addEventListener('animationend', () => {
                    cover.style.display = 'none';
                    this.coverFadeOutComplete = true;
                    console.log('å°é¢æ·¡å‡ºå®Œæˆ');
                }, { once: true });
                
                // å°é¢é–‹å§‹æ·¡å‡ºå¾Œ0.5ç§’ï¼Œé–‹å§‹è¼‰å…¥ä¸­å‹•ç•«æ·¡å‡ºå’Œè¦–å·®éæ¸¡
                setTimeout(() => {
                    console.log('é–‹å§‹è¼‰å…¥ä¸­æ·¡å‡ºå’Œè¦–å·®éæ¸¡å‹•ç•«');
                    this.startLoadingFadeOutAndParallaxTransition();
                }, 100); // å°é¢é–‹å§‹æ·¡å‡ºå¾Œ0.5ç§’è§¸ç™¼
                
                // ğŸ”´ å°é¢é–‹å§‹æ·¡å‡ºå¾Œ1ç§’ï¼Œäº’å‹•é»é»æ·¡å…¥
                setTimeout(() => {
                    console.log('ğŸ”´ é–‹å§‹äº’å‹•é»é»æ·¡å…¥å‹•ç•«');
                    this.fadeInInteractiveDots();
                }, 1000); // å°é¢é–‹å§‹æ·¡å‡ºå¾Œ1ç§’è§¸ç™¼
            }

            onImageError() {
                this.errorCount++;
                this.loadedImages++;
                
                // å¦‚æœéŒ¯èª¤å¤ªå¤šï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
                if (this.errorCount >= 3) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error-message').style.display = 'block';
                }
                
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // ğŸŒ«ï¸ ç¢ºä¿åˆå§‹ç‹€æ…‹æ²’æœ‰æ¨¡ç³Šæ•ˆæœ
                    this.resetTransitionBlur();
                    
                    document.getElementById('loading').style.display = 'none';
                }
            }

            startLoadingFadeOutAndParallaxTransition() {
                // åˆ†åˆ¥è™•ç†è¼‰å…¥ä¸­å‹•ç•«æ·¡å‡ºå’Œè¦–å·®éæ¸¡
                const loadingFadeDuration = 1000; // è¼‰å…¥ä¸­æ·¡å‡ºï¼š1ç§’
                const parallaxTransitionDuration = 1500; // è¦–å·®éæ¸¡ï¼š1.5ç§’
                
                // é–‹å§‹è¼‰å…¥ä¸­å‹•ç•«çš„æ·¡å‡º
                const loadingElement = document.getElementById('loading');
                loadingElement.classList.add('fade-out');
                
                // 1ç§’å¾Œå®Œå…¨éš±è—è¼‰å…¥ä¸­å…ƒç´ ï¼Œä¸¦é¡¯ç¤ºé‡ç½®é™€èºå„€æŒ‰éˆ•
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    
                    // ğŸ® åœ¨è¼‰å…¥ä¸­å‹•ç•«æ·¡å‡ºæ™‚é¡¯ç¤ºé‡ç½®é™€èºå„€æŒ‰éˆ•
                    // æª¢æŸ¥æ˜¯å¦éœ€è¦é¡¯ç¤ºé‡ç½®é™€èºå„€æŒ‰éˆ•
                    if (this.isMobile && this.gyroPermissionGranted) {
                        // å¦‚æœæœ‰é™€èºå„€æ¬Šé™æŒ‰éˆ•ï¼Œç­‰å¾…å®ƒæ¶ˆå¤±å¾Œå†é¡¯ç¤ºé‡ç½®æŒ‰éˆ•
                        const gyroButton = document.getElementById('gyro-permission-button');
                        if (gyroButton && gyroButton.style.display !== 'none') {
                            // ç›£è½é™€èºå„€æ¬Šé™æŒ‰éˆ•çš„éš±è—
                            const checkGyroButton = () => {
                                if (gyroButton.style.display === 'none') {
                                    this.showResetGyroButton();
                                } else {
                                    setTimeout(checkGyroButton, 100);
                                }
                            };
                            checkGyroButton();
                        } else {
                            // æ²’æœ‰é™€èºå„€æ¬Šé™æŒ‰éˆ•ï¼Œç›´æ¥é¡¯ç¤ºé‡ç½®æŒ‰éˆ•
                            this.showResetGyroButton();
                        }
                    }
                }, loadingFadeDuration);
                
                // åŒæ™‚é–‹å§‹è¦–å·®éæ¸¡å‹•ç•«ï¼ˆ1.5ç§’ï¼‰
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / parallaxTransitionDuration, 1);
                    
                    // è‡ªå®šç¾©ç·©å‹•å‡½æ•¸ï¼š70%ç·©é€² + 30%ç·©å‡º
                    let easedProgress;
                    if (progress <= 0.7) {
                        // å‰70%ä½¿ç”¨ç·©é€² (ease-in)
                        const t = progress / 0.7; // å°‡0-0.7æ˜ å°„åˆ°0-1
                        easedProgress = Math.pow(t, 3) * 0.7; // cubic ease-inï¼Œçµæœæ˜ å°„åˆ°0-0.7
                    } else {
                        // å¾Œ30%ä½¿ç”¨ç·©å‡º (ease-out)
                        const t = (progress - 0.7) / 0.3; // å°‡0.7-1æ˜ å°„åˆ°0-1
                        easedProgress = 0.7 + (1 - Math.pow(1 - t, 3)) * 0.3; // cubic ease-outï¼Œçµæœæ˜ å°„åˆ°0.7-1
                    }
                    
                    this.parallaxTransitionProgress = easedProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.parallaxTransitionProgress = 1; // ç¢ºä¿å®Œå…¨éæ¸¡åˆ°æ»‘é¼ ä½ç½®
                    }
                };
                
                animate();
            }

            updateMousePosition() {
                if (this.isMobile) return; // è¡Œå‹•è£ç½®ä¸éœ€è¦æ»‘é¼ æ’å€¼
                
                if (this.mouseInsidePage) {
                    // æ»‘é¼ åœ¨é é¢å…§çš„æ­£å¸¸è·Ÿéš¨é‚è¼¯
                    const deltaX = this.targetMouse.x - this.currentMouse.x;
                    const deltaY = this.targetMouse.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    let dynamicLerpFactor;
                    
                    if (this.mouseJustReentered) {
                        // æ»‘é¼ å‰›é‡æ–°é€²å…¥é é¢ï¼šä½¿ç”¨æ…¢é€Ÿéæ¸¡ï¼ˆ60%ç·©å…¥ï¼Œ40%ç·©å‡ºï¼‰
                        const maxLerpFactor = 0.12;
                        const minLerpFactor = 0.02;
                        dynamicLerpFactor = Math.max(minLerpFactor, maxLerpFactor / (1 + distance * 3.5));
                        
                        // ç•¶è·é›¢è¶³å¤ å°æ™‚ï¼Œåˆ‡æ›åˆ°æ­£å¸¸è·Ÿéš¨æ¨¡å¼
                        if (distance < 0.1) {
                            this.mouseJustReentered = false;
                            console.log('éæ¸¡å®Œæˆï¼Œåˆ‡æ›åˆ°æ­£å¸¸è·Ÿéš¨æ¨¡å¼');
                        }
                    } else {
                        // æ»‘é¼ æ­£å¸¸åœ¨é é¢å…§ç§»å‹•ï¼šä½¿ç”¨å¿«é€Ÿè·Ÿéš¨
                        dynamicLerpFactor = 0.25; // å¿«é€ŸéŸ¿æ‡‰çš„å›ºå®šä¿‚æ•¸
                    }
                    
                    this.currentMouse.x += deltaX * dynamicLerpFactor;
                    this.currentMouse.y += deltaY * dynamicLerpFactor;
                    
                } else if (this.isInertiaActive) {
                    // æ»‘é¼ é›¢é–‹é é¢æ™‚çš„æ…£æ€§ç·©è¡é‚è¼¯
                    const deltaX = this.inertiaTarget.x - this.currentMouse.x;
                    const deltaY = this.inertiaTarget.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // æ…£æ€§ç·©è¡çš„å„ªé›…æ¸›é€Ÿä¿‚æ•¸ï¼ˆåŸºæ–¼è·é›¢çš„å‹•æ…‹æ¸›é€Ÿï¼‰
                    const baseInertiaFactor = 0.025; // åŸºç¤æ¸›é€Ÿä¿‚æ•¸ï¼ˆæ›´æ…¢ï¼‰
                    const distanceBoost = Math.min(distance * 0.8, 0.06); // è·é›¢è¶Šé ï¼Œæ¸›é€Ÿè¶Šæ…¢
                    const inertiaLerpFactor = baseInertiaFactor + distanceBoost;
                    
                    this.currentMouse.x += deltaX * inertiaLerpFactor;
                    this.currentMouse.y += deltaY * inertiaLerpFactor;
                    
                    // æ›´å¯¬é¬†çš„åœæ­¢æ¢ä»¶ï¼Œè®“å‹•ç•«æ›´å„ªé›…åœ°çµæŸ
                    if (distance < 0.005) {
                        this.isInertiaActive = false;
                        console.log('æ…£æ€§ç·©è¡å®Œæˆ');
                    }
                }
                // å…¶ä»–æƒ…æ³ï¼šæ»‘é¼ é›¢é–‹é é¢ä¸”ç„¡æ…£æ€§æ™‚ï¼ŒcurrentMouse ä¿æŒä¸è®Š
                
                // æ›´æ–° mouse ç‚ºç•¶å‰æ’å€¼å¾Œçš„ä½ç½®
                this.mouse.x = this.currentMouse.x;
                this.mouse.y = this.currentMouse.y;
            }

            updateParallax() {
                if (!this.loadingComplete) return;

                let rawInputX, rawInputY;

                // æ›´æ–°æ»‘é¼ ä½ç½®æ’å€¼ï¼ˆåƒ…åœ¨æ¡Œé¢ç‰ˆï¼‰
                if (!this.isMobile) {
                    this.updateMousePosition();
                    // æ¡Œé¢ç‰ˆä½¿ç”¨æ’å€¼å¾Œçš„æ»‘é¼ ä½ç½®
                    rawInputX = this.mouse.x;
                    rawInputY = this.mouse.y;
                } else {
                    // è¡Œå‹•ç‰ˆä½¿ç”¨çµ±ä¸€æ§åˆ¶å€¼
                    rawInputX = this.currentOffsetX;
                    rawInputY = this.currentOffsetY;
                }
                
                // ğŸ”§ ä¿®æ­£ï¼šåœ¨éæ¸¡æœŸé–“å’Œä¸åŒè¦–è§’ä¸‹éƒ½è¦è™•ç†æ»‘é¼ è¼¸å…¥
                if (this.viewState === 'detail' && !this.isTransitioning) {
                    // ğŸ•¹ï¸ ç´”å±€éƒ¨è¦–è§’ï¼šåªæ‡‰ç”¨å±€éƒ¨è¦–è§’æ§åˆ¶
                    this.updateDetailViewControl(rawInputX, rawInputY);
                } else if (this.viewState === 'main' && !this.isTransitioning) {
                    // ğŸ–¼ï¸ ç´”ä¸»è¦–è§’ï¼šåªæ‡‰ç”¨ä¸»è¦–å·®æ•ˆæœ
                    const inputX = rawInputX * this.parallaxTransitionProgress;
                    const inputY = rawInputY * this.parallaxTransitionProgress;
                    this.applyMainParallax(inputX, inputY);
                } else if (this.isTransitioning) {
                    // ğŸ”„ éæ¸¡æœŸé–“ï¼šåŒæ™‚æ‡‰ç”¨å…©ç¨®æ•ˆæœï¼Œä½†æ¬Šé‡ä¸åŒ
                    // é€™å€‹é‚è¼¯æœƒåœ¨å‹•ç•«å‡½æ•¸ä¸­è™•ç†
                    return;
                }
            }

            // ğŸŒ«ï¸ éæ¸¡æ¨¡ç³Šæ•ˆæœæ§åˆ¶æ–¹æ³•
            applyTransitionBlur(progress) {
                // ğŸ”§ ä¸‰æ®µå¼éå°ç¨±æ¨¡ç³Šæ›²ç·šï¼š
                // é€²åº¦ 0.0 â†’ æ¨¡ç³Š 0%
                // é€²åº¦ 0.33 â†’ æ¨¡ç³Š 100%
                // é€²åº¦ 0.66 â†’ æ¨¡ç³Š 25%
                // é€²åº¦ 1.0 â†’ æ¨¡ç³Š 0%
                
                let blurFactor;
                
                if (progress <= 0.33) {
                    // å‰33%ï¼šå¾0%ç·©é€²åˆ°100% (ä½¿ç”¨ease-inæ›²ç·š)
                    const t = progress / 0.33; // æ˜ å°„åˆ°0-1
                    blurFactor = t * t; // quadratic ease-in
                } else if (progress <= 0.66) {
                    // 33%-66%ï¼šå¾100%å¿«é€Ÿä¸‹é™åˆ°25% (ç·šæ€§)
                    const t = (progress - 0.33) / 0.33; // æ˜ å°„åˆ°0-1
                    blurFactor = 1.0 - (t * 0.75); // å¾1.0ä¸‹é™åˆ°0.25
                } else {
                    // 66%-100%ï¼šå¾25%ç·©å‡ºåˆ°0% (ä½¿ç”¨ease-outæ›²ç·š)
                    const t = (progress - 0.66) / 0.34; // æ˜ å°„åˆ°0-1 (0.34 = 1.0 - 0.66)
                    const easeOutT = 1 - Math.pow(1 - t, 2); // quadratic ease-out
                    blurFactor = 0.25 * (1 - easeOutT); // å¾0.25ä¸‹é™åˆ°0
                }
                
                const blurIntensity = blurFactor * this.TRANSITION_BLUR_STRENGTH;
                
                // æ‡‰ç”¨æ¨¡ç³Šåˆ°canvaså…ƒç´ 
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = `blur(${blurIntensity}px)`;
                }
                
                // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                console.log(`ğŸŒ«ï¸ éæ¸¡æ¨¡ç³Š: progress=${progress.toFixed(3)}, factor=${(blurFactor*100).toFixed(1)}%, blur=${blurIntensity.toFixed(2)}px`);
            }
            
            // ğŸŒ«ï¸ é‡ç½®æ¨¡ç³Šæ•ˆæœ
            resetTransitionBlur() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = 'none';
                }
            }
            
            // ğŸ” å‹•æ…‹è¨­å®šå±€éƒ¨è¦–è§’æ”¾å¤§å€ç‡
            setDetailZoomScale(scale) {
                if (scale < 1.0) {
                    console.warn('âš ï¸ æ”¾å¤§å€ç‡ä¸èƒ½å°æ–¼1.0ï¼Œå·²è¨­å®šç‚º1.0');
                    scale = 1.0;
                } else if (scale > 20.0) {
                    console.warn('âš ï¸ æ”¾å¤§å€ç‡ä¸èƒ½å¤§æ–¼20.0ï¼Œå·²è¨­å®šç‚º20.0');
                    scale = 20.0;
                }
                
                this.DETAIL_ZOOM_SCALE = scale;
                console.log(`ğŸ” å±€éƒ¨è¦–è§’æ”¾å¤§å€ç‡å·²è¨­å®šç‚º: ${scale}x (${(scale*100).toFixed(0)}%)`);
            }
            
            // ğŸ” å‹•æ…‹ç²å–ç›®æ¨™ç›¸æ©Ÿä½ç½®
            getTargetCameraPosition() {
                return {
                    x: 0,
                    y: 0,
                    z: this.originalCameraPosition.z / this.DETAIL_ZOOM_SCALE
                };
            }

            // ğŸ”§ æ–°å¢ï¼šç¨ç«‹çš„ä¸»è¦–å·®æ‡‰ç”¨æ–¹æ³•
            applyMainParallax(inputX, inputY) {
                this.layers.forEach((layer) => {
                    const userData = layer.userData;
                    
                    if (userData.hasDepth) {
                        // å°æ–¼æœ‰æ·±åº¦åœ–çš„åœ–å±¤ï¼Œæ›´æ–° Shader çš„ parallaxOffset åƒæ•¸
                        layer.children.forEach((mesh) => {
                            if (mesh.material && mesh.material.uniforms) {
                                mesh.material.uniforms.parallaxOffset.value.set(
                                    inputX * this.PARALLAX_INTENSITY, 
                                    inputY * this.PARALLAX_INTENSITY
                                );
                            }
                        });
                    }
                    // æ²’æœ‰æ·±åº¦åœ–çš„åœ–å±¤ä¿æŒéœæ­¢ï¼Œä½ç½®ä¸è®Š
                });

                // ğŸ”´ æ›´æ–°äº’å‹•é»é»çš„è¦–å·®æ•ˆæœ
                this.updateInteractiveDotsParallax(inputX, inputY);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // ğŸ® æª¢æŸ¥æ§åˆ¶æ¨¡å¼åˆ‡æ›
                this.checkControlModeSwitch();
                
                // å¦‚æœè¼‰å…¥å°é¢é‚„åœ¨é¡¯ç¤ºï¼Œæ¸²æŸ“è¼‰å…¥å ´æ™¯
                if (!this.loadingComplete && this.loadingCoverLoaded && this.loadingRenderer) {
                    this.loadingRenderer.render(this.loadingScene, this.loadingCamera);
                }
                
                // æ¸²æŸ“ä¸»å ´æ™¯
                if (this.loadingComplete) {
                    this.updateParallax();
                }
                this.renderer.render(this.scene, this.camera);
            }

            // ğŸ” ================== å±€éƒ¨åœ–ç³»çµ± ==================

            zoomToDetailView(clickedDot) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                this.viewState = 'detail';
                this.currentDetailDot = clickedDot;
                
                // ğŸ•¹ï¸ é‡ç½®å±€éƒ¨è¦–è§’æ§åˆ¶
                this.resetDetailViewControl();
                
                // æ‰¾åˆ°å°æ‡‰çš„å±€éƒ¨åœ–
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === clickedDot.config.id
                );
                
                if (!detailLayer) {
                    console.error(`ğŸ” æ‰¾ä¸åˆ°å°æ‡‰çš„å±€éƒ¨åœ–: ${clickedDot.config.id}`);
                    this.isTransitioning = false;
                    return;
                }
                
                console.log(`ğŸ¯ é–‹å§‹æ”¾å¤§å‹•ç•«åˆ° ${clickedDot.config.id}ï¼Œæ”¾å¤§å€ç‡: ${this.DETAIL_ZOOM_SCALE}x (${(this.DETAIL_ZOOM_SCALE*100).toFixed(0)}%)`);
                
                // è¨ˆç®—ç›®æ¨™ä½ç½® - å°‡å±€éƒ¨åœ–çš„ä¸­å¿ƒç§»å‹•åˆ°ç•«é¢ä¸­å¿ƒ
                const detailMesh = detailLayer.mesh;
                const targetSceneX = -detailMesh.position.x;  // åå‘ç§»å‹•å ´æ™¯
                const targetSceneY = -detailMesh.position.y;
                
                // è¨­å®šå‹•ç•«åƒæ•¸
                const duration = 1500; // 1.5ç§’
                const startTime = Date.now();
                
                // è¨˜éŒ„èµ·å§‹ç‹€æ…‹
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // ç›®æ¨™ç‹€æ…‹ - æ ¹æ“šè¨­å®šçš„æ”¾å¤§å€ç‡è¨ˆç®—ç›¸æ©Ÿä½ç½®
                // æ”¾å¤§å€ç‡ = åˆå§‹è·é›¢ / ç›®æ¨™è·é›¢ï¼Œæ‰€ä»¥ç›®æ¨™è·é›¢ = åˆå§‹è·é›¢ / æ”¾å¤§å€ç‡
                const targetCameraZ = startCameraZ / this.DETAIL_ZOOM_SCALE; // å¯é…ç½®æ”¾å¤§å€ç‡
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ç·©å‹•å‡½æ•¸ï¼šease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // ğŸ”§ éæ¸¡æœŸé–“çš„æ»‘é¼ æ§åˆ¶ï¼šåŒæ™‚æ‡‰ç”¨ä¸»è¦–å·®å’Œå±€éƒ¨è¦–è§’æ§åˆ¶
                    const rawInputX = this.isMobile ? this.currentOffsetX : this.mouse.x;
                    const rawInputY = this.isMobile ? this.currentOffsetY : this.mouse.y;
                    
                    // ä¸»è¦–å·®æ¬Šé‡ï¼šå¾1éæ¸¡åˆ°0
                    const mainParallaxWeight = 1.0 - easeProgress;
                    // å±€éƒ¨è¦–è§’æ¬Šé‡ï¼šå¾0éæ¸¡åˆ°1  
                    const detailViewWeight = easeProgress;
                    
                    // è¨ˆç®—æ··åˆçš„å ´æ™¯ä½ç½®
                    let finalSceneX = startSceneX + (targetSceneX - startSceneX) * easeProgress;
                    let finalSceneY = startSceneY + (targetSceneY - startSceneY) * easeProgress;
                    
                    // æ‡‰ç”¨ä¸»è¦–å·®æ•ˆæœï¼ˆæ¬Šé‡éæ¸›ï¼‰
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // æ‡‰ç”¨å±€éƒ¨è¦–è§’æ§åˆ¶ï¼ˆæ¬Šé‡éå¢ï¼‰
                    if (detailViewWeight > 0) {
                        const detailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        const detailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        
                        // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedOffsetX = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetX));
                        const limitedOffsetY = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetY));
                        
                        // ç–ŠåŠ å±€éƒ¨è¦–è§’åç§»
                        finalSceneX += limitedOffsetX;
                        finalSceneY += limitedOffsetY;
                    }
                    
                    // æ›´æ–°ç›¸æ©Ÿä½ç½® (æ”¾å¤§æ•ˆæœ)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // æ›´æ–°å ´æ™¯ä½ç½® (ç§»å‹•åˆ°å±€éƒ¨åœ–ä¸­å¿ƒ + æ»‘é¼ åç§»)
                    this.scene.position.x = finalSceneX;
                    this.scene.position.y = finalSceneY;
                    
                    // ğŸŒŸ å±€éƒ¨åœ–æ·¡å…¥ - åœ¨æ”¾å¤§éç¨‹ä¸­é€æ¼¸é¡¯ç¤ºï¼ŒåŒæ™‚èª¿æ•´ç¾½åŒ–å¼·åº¦
                    if (detailMesh.material.uniforms) {
                        // é€æ˜åº¦éæ¸¡ï¼šä½¿ç”¨ç¨å¿«çš„é€Ÿåº¦ä½†ä¸è¦å¤ªå¿«
                        const targetOpacity = Math.min(1.0, easeProgress * 1.1);
                        detailMesh.material.uniforms.opacity.value = targetOpacity;
                        
                        // ğŸ”§ ä¿®æ­£ç¾½åŒ–éæ¸¡ï¼šä½¿ç”¨ç·šæ€§é€²åº¦è€Œéç·©å‹•é€²åº¦ï¼Œç¢ºä¿å¹³æ»‘éæ¸¡
                        const linearProgress = progress; // ä½¿ç”¨ç·šæ€§é€²åº¦è€ŒéeaseProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_MAIN_VIEW - (linearProgress * featherRange);
                        detailMesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                        // console.log(`ğŸŒŸ ç¾½åŒ–éæ¸¡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // ğŸ”´ é»é»æ·¡å‡ºæ•ˆæœ - æ”¾å¤§æ™‚
                    this.updateDotsTransitionOpacity('zoomIn', progress);
                    
                    // ğŸŒ«ï¸ æ‡‰ç”¨éæ¸¡æ¨¡ç³Šæ•ˆæœ
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // å‹•ç•«å®Œæˆ
                        this.camera.position.z = targetCameraZ;
                        // ğŸ”§ æœ€çµ‚ä½ç½®éœ€è¦åŒ…å«ç•¶å‰çš„å±€éƒ¨è¦–è§’åç§»
                        const finalDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const finalDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        const finalLimitedOffsetX = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetX));
                        const finalLimitedOffsetY = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetY));
                        
                        this.scene.position.x = targetSceneX + finalLimitedOffsetX;
                        this.scene.position.y = targetSceneY + finalLimitedOffsetY;
                        
                        // ğŸŒŸ è¨­å®šæœ€çµ‚ç‹€æ…‹ï¼šå®Œå…¨ä¸é€æ˜ï¼Œç¾½åŒ–æœ€å¼±
                        if (detailMesh.material.uniforms) {
                            detailMesh.material.uniforms.opacity.value = 1.0;
                            detailMesh.material.uniforms.featherStrength.value = this.FEATHER_DETAIL_VIEW;  // å±€éƒ¨è¦–è§’ç¾½åŒ–æœ€å¼±
                        }
                        
                        // ğŸŒ«ï¸ é‡ç½®æ¨¡ç³Šæ•ˆæœ
                        this.resetTransitionBlur();
                        
                        // ğŸ”´ é‡ç½®é»é»é€æ˜åº¦ç‚º0%ï¼ˆå±€éƒ¨è¦–è§’æ™‚å®Œå…¨éš±è—ï¼‰
                        this.resetDotsTransitionOpacity(0.0);
                        
                        this.isTransitioning = false;
                        
                        console.log(`ğŸ¯ æ”¾å¤§å‹•ç•«å®Œæˆï¼Œé€²å…¥å±€éƒ¨è¦–è§’: ${clickedDot.config.id}`);
                    }
                };
                
                animate();
            }

            returnToMainView() {
                if (this.isTransitioning || this.viewState === 'main') return;
                
                this.isTransitioning = true;
                
                // ğŸ•¹ï¸ é‡ç½®å±€éƒ¨è¦–è§’æ§åˆ¶
                this.resetDetailViewControl();
                
                console.log('ğŸ”„ é–‹å§‹è¿”å›ä¸»è¦–è§’å‹•ç•«');
                
                // æ‰¾åˆ°ç•¶å‰çš„å±€éƒ¨åœ–
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === this.currentDetailDot.config.id
                );
                
                // è¨­å®šå‹•ç•«åƒæ•¸
                const duration = 1500; // 1.5ç§’
                const startTime = Date.now();
                
                // è¨˜éŒ„èµ·å§‹ç‹€æ…‹
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // ğŸ”§ åˆ†é›¢èµ·å§‹ä½ç½®çš„åŸºç¤ä½ç½®å’Œæ»‘é¼ åç§»
                const detailMesh = detailLayer.mesh;
                const baseSceneX = -detailMesh.position.x;  // å±€éƒ¨åœ–ä¸­å¿ƒå°æ‡‰çš„åŸºç¤å ´æ™¯ä½ç½®
                const baseSceneY = -detailMesh.position.y;
                const startOffsetX = startSceneX - baseSceneX;  // èµ·å§‹æ™‚çš„æ»‘é¼ åç§»
                const startOffsetY = startSceneY - baseSceneY;
                
                // ç›®æ¨™ç‹€æ…‹ (å›åˆ°åŸå§‹ä½ç½®) - ä½¿ç”¨åˆå§‹ç›¸æ©Ÿä½ç½®
                const targetCameraZ = 5; // å›ºå®šå›åˆ°åˆå§‹ä½ç½®
                const targetSceneX = 0;
                const targetSceneY = 0;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ç·©å‹•å‡½æ•¸ï¼šease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // ğŸ”§ éæ¸¡æœŸé–“çš„æ»‘é¼ æ§åˆ¶ï¼šåŒæ™‚æ‡‰ç”¨å±€éƒ¨è¦–è§’å’Œä¸»è¦–å·®æ§åˆ¶
                    const rawInputX = this.isMobile ? this.currentOffsetX : this.mouse.x;
                    const rawInputY = this.isMobile ? this.currentOffsetY : this.mouse.y;
                    
                    // å±€éƒ¨è¦–è§’æ¬Šé‡ï¼šå¾1éæ¸¡åˆ°0
                    const detailViewWeight = 1.0 - easeProgress;
                    // ä¸»è¦–å·®æ¬Šé‡ï¼šå¾0éæ¸¡åˆ°1
                    const mainParallaxWeight = easeProgress;
                    
                    // ğŸ”§ ä¿®æ­£ï¼šè¨ˆç®—åŸºç¤å ´æ™¯ä½ç½®çš„éæ¸¡
                    const baseTransitionX = baseSceneX + (targetSceneX - baseSceneX) * easeProgress;
                    const baseTransitionY = baseSceneY + (targetSceneY - baseSceneY) * easeProgress;
                    
                    // è¨ˆç®—æ··åˆçš„æ»‘é¼ åç§»
                    let finalOffsetX = 0;
                    let finalOffsetY = 0;
                    
                    // æ‡‰ç”¨å±€éƒ¨è¦–è§’æ§åˆ¶ï¼ˆæ¬Šé‡éæ¸›ï¼‰
                    if (detailViewWeight > 0) {
                        const currentDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const currentDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        
                        // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedCurrentOffsetX = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetX));
                        const limitedCurrentOffsetY = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetY));
                        
                        // ğŸ”§ ä¿®æ­£ï¼šå¾èµ·å§‹åç§»å¹³æ»‘éæ¸¡åˆ°0ï¼ˆå›åˆ°ä¸»è¦–è§’ä¸­å¿ƒï¼‰
                        // èµ·å§‹åç§»éš¨è‘—æ¬Šé‡æ¸›å°‘è€Œæ¸›å°‘ï¼Œæœ€çµ‚è®Šç‚º0
                        const transitionOffsetX = startOffsetX * detailViewWeight;
                        const transitionOffsetY = startOffsetY * detailViewWeight;
                        
                        // ç•¶å‰æ»‘é¼ åç§»ä¹Ÿéš¨è‘—æ¬Šé‡æ¸›å°‘è€Œæ¸›å°‘
                        const currentOffsetX = limitedCurrentOffsetX * detailViewWeight;
                        const currentOffsetY = limitedCurrentOffsetY * detailViewWeight;
                        
                        // æ··åˆå…©ç¨®åç§»ï¼Œä½†éƒ½æœƒéš¨è‘—æ¬Šé‡æ¸›å°‘
                        finalOffsetX = transitionOffsetX * 0.3 + currentOffsetX * 0.7;
                        finalOffsetY = transitionOffsetY * 0.3 + currentOffsetY * 0.7;
                    } else {
                        // ğŸ”§ æ¬Šé‡ç‚º0æ™‚ï¼Œåç§»ä¹Ÿæ‡‰è©²ç‚º0ï¼ˆå®Œå…¨å›åˆ°ä¸»è¦–è§’ï¼‰
                        finalOffsetX = 0;
                        finalOffsetY = 0;
                    }
                    
                    // ğŸ”§ ä¿®æ­£ï¼šå ´æ™¯åŸºç¤ä½ç½®å¹³æ»‘éæ¸¡åˆ°(0,0)
                    const sceneBaseX = baseTransitionX + finalOffsetX;
                    const sceneBaseY = baseTransitionY + finalOffsetY;
                    
                    // æ›´æ–°ç›¸æ©Ÿä½ç½® (ç¸®å°æ•ˆæœ)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // ğŸ”§ è¨­å®šå ´æ™¯åŸºç¤ä½ç½®
                    this.scene.position.x = sceneBaseX;
                    this.scene.position.y = sceneBaseY;
                    
                    // ğŸ”§ åœ¨å ´æ™¯åŸºç¤ä½ç½®ä¹‹ä¸Šæ‡‰ç”¨ä¸»è¦–å·®æ•ˆæœï¼ˆæ¬Šé‡éå¢ï¼‰
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // ğŸŒŸ å±€éƒ¨åœ–æ·¡å‡º - åŒæ™‚èª¿æ•´ç¾½åŒ–å¼·åº¦
                    if (detailLayer && detailLayer.mesh.material.uniforms) {
                        detailLayer.mesh.material.uniforms.opacity.value = 1.0 - easeProgress;
                        
                        // ğŸ”§ ä¿®æ­£ç¾½åŒ–éæ¸¡ï¼šä½¿ç”¨ç·šæ€§é€²åº¦ç¢ºä¿å¹³æ»‘éæ¸¡
                        const linearProgress = progress; // ä½¿ç”¨ç·šæ€§é€²åº¦è€ŒéeaseProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_DETAIL_VIEW + (linearProgress * featherRange);
                        detailLayer.mesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                        // console.log(`ğŸŒŸ ç¾½åŒ–éæ¸¡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // ğŸ”´ é»é»æ·¡å…¥æ•ˆæœ - ç¸®å°æ™‚
                    this.updateDotsTransitionOpacity('zoomOut', progress);
                    
                    // ğŸŒ«ï¸ æ‡‰ç”¨éæ¸¡æ¨¡ç³Šæ•ˆæœ
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // å‹•ç•«å®Œæˆ
                        this.camera.position.z = targetCameraZ;
                        
                        // ğŸ”§ å ´æ™¯ä½ç½®å·²ç¶“åœ¨å‹•ç•«éç¨‹ä¸­å¹³æ»‘éæ¸¡åˆ°ç›®æ¨™ä½ç½®(0,0)
                        // ä¸éœ€è¦å†æ¬¡è¨­å®šï¼Œé¿å…çªè·³
                        // this.scene.position.x = targetSceneX;
                        // this.scene.position.y = targetSceneY;
                        
                        // ğŸ”§ ç¢ºä¿æœ€çµ‚ç‹€æ…‹ï¼šå ´æ™¯ä½ç½®ç‚º(0,0)ï¼Œä¸»è¦–å·®æ•ˆæœç–ŠåŠ 
                        this.scene.position.x = 0;
                        this.scene.position.y = 0;
                        const finalMainInputX = rawInputX * this.parallaxTransitionProgress;
                        const finalMainInputY = rawInputY * this.parallaxTransitionProgress;
                        this.applyMainParallax(finalMainInputX, finalMainInputY);
                        
                        // ğŸŒŸ é‡ç½®å±€éƒ¨åœ–ç‹€æ…‹ï¼šé€æ˜åº¦ç‚º0ï¼Œç¾½åŒ–å¼·åº¦æœ€å¼·
                        if (detailLayer && detailLayer.mesh.material.uniforms) {
                            detailLayer.mesh.material.uniforms.opacity.value = 0.0;
                            detailLayer.mesh.material.uniforms.featherStrength.value = this.FEATHER_MAIN_VIEW;  // ä¸»è¦–è§’ç¾½åŒ–æœ€å¼·
                        }
                        
                        // ğŸŒ«ï¸ é‡ç½®æ¨¡ç³Šæ•ˆæœ
                        this.resetTransitionBlur();
                        
                        // ğŸ”´ é‡ç½®é»é»é€æ˜åº¦ç‚º100%ï¼ˆä¸»è¦–è§’æ™‚å®Œå…¨é¡¯ç¤ºï¼‰
                        this.resetDotsTransitionOpacity(1.0);
                        
                        // é‡ç½®ç‹€æ…‹
                        this.viewState = 'main';
                        this.currentDetailDot = null;
                        this.isTransitioning = false;
                        
                        console.log('ğŸ”„ è¿”å›ä¸»è¦–è§’å‹•ç•«å®Œæˆ');
                    }
                };
                
                animate();
            }

            loadDetailLayers() {
                console.log('ğŸ” é–‹å§‹è¼‰å…¥å±€éƒ¨åœ–å±¤');
                
                this.detailLayerInfo.forEach((detailInfo, index) => {
                    this.loadDetailLayer(detailInfo, index);
                });
            }

            loadDetailLayer(detailInfo, index) {
                const loader = new THREE.TextureLoader();
                
                console.log(`ğŸ” æ­£åœ¨è¼‰å…¥å±€éƒ¨åœ–: ${detailInfo.name}.png`);
                loader.load(
                    `images/${detailInfo.name}.png`,
                    (texture) => {
                        console.log(`ğŸ” æˆåŠŸè¼‰å…¥å±€éƒ¨åœ–: ${detailInfo.name}.png`);
                        this.createDetailLayerMesh(texture, detailInfo, index);
                    },
                    undefined,
                    (error) => {
                        console.error(`ğŸ” å±€éƒ¨åœ–è¼‰å…¥å¤±æ•—: ${detailInfo.name}.png`, error);
                    }
                );
            }

            createDetailLayerMesh(texture, detailInfo, index) {
                // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨ä¸»åœ–å±¤çš„å°ºå¯¸ä½œç‚ºåŸºæº–ï¼Œè€Œä¸æ˜¯å±€éƒ¨åœ–è‡ªå·±çš„å°ºå¯¸
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) {
                    console.error('ğŸ” ç„¡æ³•ç²å–ä¸»åœ–å±¤å°ºå¯¸ï¼Œå±€éƒ¨åœ–å»ºç«‹å¤±æ•—');
                    return;
                }
                
                const { width: mainWidth, height: mainHeight } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // ğŸ”§ å»ºç«‹èˆ‡ä¸»åœ–å±¤ç›¸åŒå¤§å°çš„å¹¾ä½•é«”ï¼Œç¨å¾Œç”¨ç¸®æ”¾æ§åˆ¶å¯¦éš›å¤§å°
                const geometry = new THREE.PlaneGeometry(mainWidth, mainHeight);
                
                // ğŸŒŸ å»ºç«‹å…·æœ‰é‚Šç·£ç¾½åŒ–æ•ˆæœçš„è‡ªå®šç¾©Shaderæè³ª
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform sampler2D mainTexture;
                    uniform float opacity;
                    uniform float featherStrength;  // ç¾½åŒ–å¼·åº¦ (0.0-1.0)
                    uniform float featherRange;     // ç¾½åŒ–å½±éŸ¿ç¯„åœ (0.0-1.0)
                    varying vec2 vUv;
                    
                    void main() {
                        // å–æ¨£ä¸»ç´‹ç†
                        vec4 color = texture2D(mainTexture, vUv);
                        
                        // è¨ˆç®—åˆ°é‚Šç·£çš„è·é›¢
                        vec2 center = vec2(0.5, 0.5);
                        vec2 edgeDistance = abs(vUv - center) * 2.0;  // è½‰æ›ç‚º0-1ç¯„åœ
                        float maxEdgeDistance = max(edgeDistance.x, edgeDistance.y);
                        
                        // ç¾½åŒ–è¨ˆç®—ï¼šå¾é‚Šç·£é–‹å§‹æ·¡åŒ–
                        float actualFeatherRange = featherStrength * featherRange;  // å¯¦éš›ç¾½åŒ–ç¯„åœ
                        float featherStart = 1.0 - actualFeatherRange;              // ç¾½åŒ–é–‹å§‹ä½ç½®
                        float featherEnd = 1.0;                                     // ç¾½åŒ–çµæŸä½ç½®ï¼ˆé‚Šç·£ï¼‰
                        
                        float edgeAlpha = 1.0;
                        if (maxEdgeDistance > featherStart && actualFeatherRange > 0.0) {
                            // åœ¨ç¾½åŒ–å€åŸŸå…§ï¼Œè¨ˆç®—é€æ˜åº¦æ¼¸è®Š
                            float featherProgress = (maxEdgeDistance - featherStart) / (featherEnd - featherStart);
                            // ä½¿ç”¨æ›´å¹³æ»‘çš„æ›²ç·š
                            edgeAlpha = 1.0 - smoothstep(0.0, 1.0, featherProgress * featherProgress);
                        }
                        
                        // æœ€çµ‚é€æ˜åº¦ = æè³ªé€æ˜åº¦ Ã— é‚Šç·£é€æ˜åº¦
                        color.a *= opacity * edgeAlpha;
                        
                        gl_FragColor = color;
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        mainTexture: { value: texture },
                        opacity: { value: 0.0 },  // åˆå§‹é€æ˜åº¦ç‚º0
                        featherStrength: { value: this.FEATHER_MAIN_VIEW },  // åˆå§‹ç¾½åŒ–å¼·åº¦ï¼šä¸»è¦–è§’æ™‚æœ€å¼·
                        featherRange: { value: this.FEATHER_TRANSITION_RANGE }  // ç¾½åŒ–å½±éŸ¿ç¯„åœ
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false  // ğŸ”§ é—œéµä¿®æ­£ï¼šé¿å…é€æ˜ç‰©ä»¶å¯«å…¥æ·±åº¦ç·©è¡å€é€ æˆé®æ“‹
                });
                
                // å»ºç«‹ç¶²æ ¼
                const mesh = new THREE.Mesh(geometry, material);
                
                // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨é»é»é…ç½®ç›´æ¥è¨ˆç®—ä½ç½®ï¼Œç¢ºä¿åæ¨™ç³»çµ±å®Œå…¨ä¸€è‡´
                const correspondingDot = this.interactiveDots.find(dot => 
                    dot.config.id === detailInfo.dotId
                );
                
                if (correspondingDot) {
                    // ğŸ”§ ä¿®æ­£ï¼šèˆ‡é»é»ç›¸åŒçš„åæ¨™è¨ˆç®—é‚è¼¯
                    const x = (correspondingDot.config.x - 0.5) * mainWidth;
                    const y = (0.5 - correspondingDot.config.y) * mainHeight; // Yè»¸ç¿»è½‰
                    
                    mesh.position.x = x;
                    mesh.position.y = y;
                    // ğŸ”§ Zè»¸ä½ç½®ï¼šç¾åœ¨æœ‰äº†depthWrite: falseï¼Œé †åºä¸å†é‡è¦
                    mesh.position.z = 0.06 + index * 0.01; // Zè»¸ä½ç½® 0.06~0.08 (index 0,1,2 å°æ‡‰ 0.06,0.07,0.08)
                    
                    console.log(`ğŸ” å±€éƒ¨åœ– ${detailInfo.name} ä½ç½®è¨­å®šç‚ºèˆ‡é»é» ${detailInfo.dotId} ç›¸åŒçš„è¨ˆç®—çµæœ:`, 
                               `(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
                } else {
                    console.warn(`ğŸ” æ‰¾ä¸åˆ°å°æ‡‰çš„é»é»: ${detailInfo.dotId}`);
                    mesh.position.z = 0.06 + index * 0.01;
                }
                
                // è¨­å®šåˆå§‹ç¸®æ”¾25%
                mesh.scale.setScalar(0.25);
                
                // å„²å­˜ç›¸é—œè³‡è¨Š
                mesh.userData = {
                    isDetailLayer: true,
                    detailInfo: detailInfo,
                    originalTexture: texture,  // å±€éƒ¨åœ–æœ¬èº«çš„ç´‹ç†
                    mainTexture: firstLayer.userData.mainTexture,  // ğŸ”§ æ–°å¢ï¼šä¸»åœ–å±¤ç´‹ç†å¼•ç”¨ï¼Œç”¨æ–¼å°ºå¯¸è¨ˆç®—
                    baseScale: 0.25,
                    dotId: detailInfo.dotId
                };
                
                // æ·»åŠ åˆ°å°æ‡‰çš„åœ–å±¤çµ„
                const targetGroup = this[detailInfo.group];
                if (targetGroup) {
                    targetGroup.add(mesh);
                    console.log(`ğŸ” å±€éƒ¨åœ– ${detailInfo.name} å·²æ·»åŠ åˆ° ${detailInfo.group}`);
                } else {
                    console.error(`ğŸ” æ‰¾ä¸åˆ°ç›®æ¨™åœ–å±¤çµ„: ${detailInfo.group}`);
                }
                
                // æ·»åŠ åˆ°å±€éƒ¨åœ–å±¤é™£åˆ—
                this.detailLayers.push({
                    mesh: mesh,
                    group: targetGroup,
                    detailInfo: detailInfo,
                    isVisible: true,
                    basePosition: {
                        x: mesh.position.x,
                        y: mesh.position.y,
                        z: mesh.position.z
                    }
                });
            }

            updateDetailLayersLayout() {
                // ç•¶è¦–çª—å¤§å°æ”¹è®Šæ™‚ï¼Œæ›´æ–°å±€éƒ¨åœ–å±¤ä½ç½®å’Œå°ºå¯¸
                if (!this.detailLayers.length || !this.interactiveDots.length) return;
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸ç”¨æ–¼è¨ˆç®—
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                this.detailLayers.forEach(detailLayer => {
                    const correspondingDot = this.interactiveDots.find(dot => 
                        dot.config.id === detailLayer.detailInfo.dotId
                    );
                    
                    if (correspondingDot) {
                        // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨èˆ‡é»é»ç›¸åŒçš„åæ¨™è¨ˆç®—é‚è¼¯ï¼Œç¢ºä¿å®Œå…¨ä¸€è‡´
                        const x = (correspondingDot.config.x - 0.5) * width;
                        const y = (0.5 - correspondingDot.config.y) * height; // Yè»¸ç¿»è½‰
                        
                        detailLayer.mesh.position.x = x;
                        detailLayer.mesh.position.y = y;
                        
                        // ğŸ”§ ä¿®æ­£ï¼šæ›´æ–°å¹¾ä½•é«”å°ºå¯¸ä»¥åŒ¹é…ä¸»åœ–å±¤
                        detailLayer.mesh.geometry.dispose(); // é‡‹æ”¾èˆŠçš„å¹¾ä½•é«”
                        detailLayer.mesh.geometry = new THREE.PlaneGeometry(width, height);
                        
                        // æ›´æ–°åŸºç¤ä½ç½®è¨˜éŒ„
                        detailLayer.basePosition.x = x;
                        detailLayer.basePosition.y = y;
                        
                        console.log(`ğŸ” æ›´æ–°å±€éƒ¨åœ– ${detailLayer.detailInfo.name} ä½ç½®åˆ° (${x.toFixed(2)}, ${y.toFixed(2)})ï¼Œå°ºå¯¸: ${width.toFixed(1)}x${height.toFixed(1)}`);
                    }
                });
            }

            // ğŸ”´ ================== äº’å‹•é»é»ç³»çµ± ==================

            createInteractiveDots() {
                console.log('ğŸ”´ é–‹å§‹å‰µå»ºäº’å‹•é»é»');
                
                // é»é»é…ç½®è³‡æ–™ - ä½ç½®ä»¥ç™¾åˆ†æ¯”è¡¨ç¤º (0-1)
                const dotsConfig = [
                    { id: 'dot1', x: 0.6385, y: 0.394, depth: 0.56 },
                    { id: 'dot2', x: 0.486, y: 0.647, depth: 0.57 },
                    { id: 'dot3', x: 0.71, y: 0.628, depth: 0.65 }
                ];

                // ç‚ºæ¯å€‹é»å‰µå»ºç¶²æ ¼
                dotsConfig.forEach((config, index) => {
                    const dot = this.createDotMesh(config);
                    this.interactiveDots.push({
                        mesh: dot,
                        config: config,
                        originalPosition: { x: config.x, y: config.y },
                        basePosition: { x: 0, y: 0 }, // åŸºç¤ä½ç½®ï¼ˆä¸å«è¦–å·®ï¼‰
                        isHovered: false,
                        hoverMultiplier: 1.0,         // hoveré€æ˜åº¦ä¹˜æ•¸
                        isPressed: false,             // æ˜¯å¦è¢«æŒ‰ä¸‹
                        pressedScale: 1.0,            // æŒ‰ä¸‹ç‹€æ…‹çš„ç¸®æ”¾
                        // è·é›¢äº’å‹•ç›¸é—œ
                        mouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // æ»‘é¼ è·é›¢ä¿‚æ•¸ (0=æœ€è¿‘, 1=æœ€é /è¶…å‡ºç¯„åœ)
                        targetMouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // ç›®æ¨™è·é›¢ä¿‚æ•¸
                        distanceScale: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_SCALE_FACTOR : 1.0,      // åŸºæ–¼è·é›¢çš„ç¸®æ”¾ä¿‚æ•¸
                        distanceOpacity: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_OPACITY_FACTOR : 1.0,   // åŸºæ–¼è·é›¢çš„é€æ˜åº¦ä¿‚æ•¸
                        // ğŸŒ«ï¸ éæ¸¡å‹•ç•«ç›¸é—œ
                        transitionOpacity: 1.0  // éæ¸¡å‹•ç•«é€æ˜åº¦ä¹˜æ•¸ (æ”¾å¤§ç¸®å°æ™‚çš„æ·¡å‡ºæ·¡å…¥)
                    });
                    this.dotsGroup.add(dot);
                });

                // è¨­å®šé»é»å®¹å™¨çš„æ¸²æŸ“é †åº
                this.dotsGroup.renderOrder = 1; // æ¯”ä¸»åœ–å±¤çµ„(0)é«˜ï¼Œæ¯”è¼‰å…¥å±¤ä½
                
                // åˆå§‹åŒ–é»é»å¸ƒå±€
                this.updateInteractiveDotsLayout();
                
                // è¨­å®šé»æ“Šäº‹ä»¶
                this.setupDotInteractions();
                
                console.log(`âœ… æˆåŠŸå‰µå»º ${this.interactiveDots.length} å€‹äº’å‹•é»é»`);
            }

            createDotMesh(config) {
                // å‰µå»ºå…·æœ‰é™°å½±æ•ˆæœçš„äº’å‹•é»é»æè³ª
                const canvas = document.createElement('canvas');
                const size = 128; // å¢åŠ ç•«å¸ƒå¤§å°ä»¥å®¹ç´æ›´å¤§çš„é™°å½±
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                const outerRadius = size * 0.2; // èª¿æ•´é»é»å¤§å°æ¯”ä¾‹
                const innerRadius = size * 0.1;  
                const shadowRadius = size * 0.32;  // é™°å½±ç¯„åœ
                
                // æ¸…é™¤ç•«å¸ƒ
                ctx.clearRect(0, 0, size, size);
                
                // ç¹ªè£½å¤§ç¯„åœæ“´æ•£é™°å½± - å¾ä¸­å¿ƒå‘å¤–æ¨¡ç³Š
                const shadowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, shadowRadius);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');     // ä¸­å¿ƒè¼ƒæ·±
                shadowGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.25)');  // æ¼¸è®Š
                shadowGradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');   // æ›´æ·¡
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');       // é‚Šç·£é€æ˜
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, shadowRadius, 0, Math.PI * 2);
                ctx.fillStyle = shadowGradient;
                ctx.fill();
                
                // è¨­å®šé»é»æœ¬èº«çš„é™°å½±æ•ˆæœ
                ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 2;
                
                // ç¹ªè£½å¤–åœˆ - åŠé€æ˜é‚Šæ¡†
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // é‡ç½®é™°å½±
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // ç¹ªè£½å…§åœˆ - å¯¦å¿ƒä¸­å¿ƒ
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                
                // å…§åœˆæ¼¸è®Šå¡«å……
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                innerGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)');
                
                ctx.fillStyle = innerGradient;
                ctx.fill();
                
                // æ·»åŠ ç²¾ç´°çš„ç™½è‰²å…‰æšˆæ•ˆæœ
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius + 3, 0, Math.PI * 2);
                const glowGradient = ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, outerRadius + 3);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // å‰µå»ºç´‹ç†
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // å‰µå»ºæè³ª
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,  // åˆå§‹ç‚ºé€æ˜ï¼Œç­‰å¾…æ·¡å…¥
                    blending: THREE.NormalBlending
                });
                
                // å‰µå»ºå¹¾ä½•é«” - èª¿æ•´å¤§å°ä»¥åŒ…å«é™°å½±ç¯„åœ
                const geometry = new THREE.PlaneGeometry(0.32, 0.32); // å¢å¤§ä»¥å®¹ç´é™°å½±
                
                // å‰µå»ºç¶²æ ¼
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    isDot: true,
                    dotId: config.id,
                    depthValue: config.depth,
                    baseOpacity: 0.85, // ç¨é«˜çš„åŸºç¤é€æ˜åº¦ç¢ºä¿å¯è¦‹æ€§
                    isVisible: false
                };
                
                return mesh;
            }

            updateInteractiveDotsLayout() {
                if (!this.layers.length || !this.interactiveDots.length) return;
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸ï¼ˆä½¿ç”¨ç¬¬ä¸€å€‹åœ–å±¤çš„ä¸»ç´‹ç†ï¼‰
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // æ›´æ–°æ¯å€‹é»çš„åŸºç¤ä½ç½®
                this.interactiveDots.forEach(dotData => {
                    const { config } = dotData;
                    
                    // è¨ˆç®—åœ¨ä¸»åœ–ç¯„åœå…§çš„ä½ç½®
                    // relativeX/Y å¾ 0~1 è½‰æ›ç‚º -width/2 ~ +width/2 çš„åº§æ¨™
                    const x = (config.x - 0.5) * width;
                    const y = (0.5 - config.y) * height; // Yè»¸ç¿»è½‰
                    
                    dotData.basePosition.x = x;
                    dotData.basePosition.y = y;
                    dotData.mesh.position.x = x;
                    dotData.mesh.position.y = y;
                    dotData.mesh.position.z = 0.1; // ç¢ºä¿åœ¨ä¸»åœ–å±¤ä¹‹ä¸Š
                });
                
                console.log('ğŸ”´ äº’å‹•é»é»å¸ƒå±€å·²æ›´æ–°');
            }

            updateInteractiveDotsParallax(inputX, inputY) {
                if (!this.interactiveDots.length) return;
                
                this.interactiveDots.forEach(dotData => {
                    const { mesh, basePosition, config } = dotData;
                    
                    // æ ¹æ“šé»çš„æ·±åº¦å€¼è¨ˆç®—è¦–å·®åç§»
                    const depthOffset = (config.depth - 0.625); // èˆ‡ shader ä¸­ç›¸åŒçš„åŸºæº–é»
                    const parallaxX = inputX * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    const parallaxY = inputY * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    
                    // æ‡‰ç”¨è¦–å·®åç§»åˆ°åŸºç¤ä½ç½®
                    mesh.position.x = basePosition.x + parallaxX;
                    mesh.position.y = basePosition.y + parallaxY;
                });
            }

            setupDotInteractions() {
                // å»ºç«‹raycasterç”¨æ–¼é»æ“Šæª¢æ¸¬
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // æ»‘é¼ æŒ‰ä¸‹äº‹ä»¶
                this.renderer.domElement.addEventListener('pointerdown', (event) => {
                    this.handleDotPointerDown(event);
                });
                
                // æ»‘é¼ æ”¾é–‹äº‹ä»¶
                this.renderer.domElement.addEventListener('pointerup', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // æ»‘é¼ é›¢é–‹æ™‚ä¹Ÿè¦æ”¾é–‹ï¼ˆé¿å…æ‹–æ‹½é›¢é–‹å¾Œå¡ä½ï¼‰
                this.renderer.domElement.addEventListener('pointerleave', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // æ¡Œæ©Ÿç‰ˆï¼šæ»‘é¼ hoveræ•ˆæœå’Œè·é›¢äº’å‹•
                if (!this.isMobile) {
                    this.renderer.domElement.addEventListener('pointermove', (event) => {
                        this.handleDotHover(event);
                        // åŒæ™‚æ›´æ–°è·é›¢äº’å‹•
                        if (this.DISTANCE_INTERACTION_ENABLED) {
                            this.updateDistanceInteraction(event);
                        }
                    });
                    
                    // è¨­å®šæ»‘é¼ æ¨£å¼
                    this.renderer.domElement.style.cursor = 'default';
                } else {
                    // è¡Œå‹•ç‰ˆï¼šè·é›¢äº’å‹•å·²åœ¨å»ºæ§‹å‡½æ•¸ä¸­é—œé–‰ï¼Œç„¡éœ€é¡å¤–äº‹ä»¶ç›£è½å™¨
                    console.log('è¡Œå‹•ç‰ˆï¼šè·é›¢æ„Ÿæ‡‰äº’å‹•å·²é—œé–‰');
                }
                // æ³¨æ„ï¼šè¡Œå‹•ç‰ˆçš„å‹•ç•«ç¾åœ¨çµ±ä¸€åœ¨ fadeInInteractiveDots å®Œæˆå¾Œå•Ÿå‹•
            }

            handleDotPointerDown(event) {
                // å¦‚æœæ­£åœ¨éæ¸¡å‹•ç•«ä¸­ï¼Œå¿½ç•¥é»æ“Š
                if (this.isTransitioning) return;
                
                // è½‰æ›æ»‘é¼ åº§æ¨™
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // è¨­å®šraycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                if (this.viewState === 'main') {
                    // ä¸»è¦–è§’ï¼šæª¢æŸ¥é»é»é»æ“Š
                    const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                    const intersects = this.raycaster.intersectObjects(dotMeshes);
                    
                    if (intersects.length > 0) {
                        const pressedDot = intersects[0].object;
                        const dotData = this.interactiveDots.find(d => d.mesh === pressedDot);
                        const dotId = pressedDot.userData.dotId;
                        console.log(`ğŸ”´ ${dotId} pressed down`);
                        
                        if (dotData) {
                            // è¨­å®šæŒ‰ä¸‹ç‹€æ…‹
                            dotData.isPressed = true;
                            this.animateDotPress(dotData, true);
                        }
                    }
                } else if (this.viewState === 'detail') {
                    // å±€éƒ¨è¦–è§’ï¼šé»æ“Šä»»æ„ä½ç½®è¿”å›ä¸»è¦–è§’
                    console.log('ğŸ”„ é»æ“Šç•«é¢è¿”å›ä¸»è¦–è§’');
                    this.returnToMainView();
                }
            }

            handleDotPointerUp(event) {
                // å¦‚æœæ­£åœ¨éæ¸¡å‹•ç•«ä¸­ï¼Œå¿½ç•¥é»æ“Š
                if (this.isTransitioning) return;
                
                if (this.viewState === 'main') {
                    // ä¸»è¦–è§’ï¼šæª¢æŸ¥æ˜¯å¦æœ‰é»é»è¢«æŒ‰ä¸‹ä¸¦è§¸ç™¼æ”¾å¤§
                    let clickedDot = null;
                    this.interactiveDots.forEach(dotData => {
                        if (dotData.isPressed) {
                            console.log(`ğŸ”´ ${dotData.mesh.userData.dotId} released`);
                            clickedDot = dotData;
                            dotData.isPressed = false;
                            this.animateDotPress(dotData, false);
                        }
                    });
                    
                    // å¦‚æœæœ‰é»é»è¢«é»æ“Šï¼Œæ”¾å¤§åˆ°å±€éƒ¨è¦–è§’
                    if (clickedDot) {
                        console.log(`ğŸ¯ æ”¾å¤§åˆ°å±€éƒ¨è¦–è§’: ${clickedDot.config.id}`);
                        this.zoomToDetailView(clickedDot);
                    }
                }
            }

            handleDotHover(event) {
                if (this.isMobile) return;
                
                // è½‰æ›æ»‘é¼ åº§æ¨™
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // è¨­å®šraycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                // æª¢æŸ¥èˆ‡é»é»çš„äº¤é›†
                const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                const intersects = this.raycaster.intersectObjects(dotMeshes);
                
                let currentHoveredDot = null;
                
                if (intersects.length > 0) {
                    currentHoveredDot = intersects[0].object;
                }
                
                // æ›´æ–°hoverç‹€æ…‹ - åªè™•ç†ç‹€æ…‹æ”¹è®Šçš„é»
                this.interactiveDots.forEach(dotData => {
                    const shouldBeHovered = dotData.mesh === currentHoveredDot;
                    
                    if (shouldBeHovered && !dotData.isHovered) {
                        // é–‹å§‹hover
                        dotData.isHovered = true;
                        this.animateDotHover(dotData.mesh, true);
                    } else if (!shouldBeHovered && dotData.isHovered) {
                        // çµæŸhover
                        dotData.isHovered = false;
                        this.animateDotHover(dotData.mesh, false);
                    }
                });
                
                // æ›´æ–°æ»‘é¼ æ¨£å¼
                this.renderer.domElement.style.cursor = currentHoveredDot ? 'pointer' : 'default';
            }

            animateDotPress(dotData, isPressed) {
                // æŒ‰ä¸‹/æ”¾é–‹å‹•ç•«
                const duration = isPressed ? 80 : 200; // æŒ‰ä¸‹å¿«ï¼Œæ”¾é–‹æ…¢
                const targetScale = isPressed ? 0.8 : 1.0; // æŒ‰ä¸‹ç¸®å°30%
                const targetOpacityBoost = isPressed ? 1.6 : 1.0; // æŒ‰ä¸‹æ™‚æ›´äº®
                
                const startScale = dotData.pressedScale;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ç·©å‹•å‡½æ•¸ï¼šæŒ‰ä¸‹æ™‚å¿«é€Ÿï¼Œæ”¾é–‹æ™‚å½ˆæ€§
                    const easeProgress = isPressed ? 
                        Math.pow(progress, 1.5) : // æŒ‰ä¸‹ï¼šease-in å¿«é€Ÿ
                        1 - Math.pow(1 - progress, 1.8); // æ”¾é–‹ï¼šease-out å½ˆæ€§
                    
                    // æ›´æ–°ç¸®æ”¾ä¿‚æ•¸
                    dotData.pressedScale = startScale + (targetScale - startScale) * easeProgress;
                    
                    // æ›´æ–°é€æ˜åº¦ï¼ˆæŒ‰ä¸‹æ™‚è®Šäº®ï¼‰
                    const targetMultiplier = dotData.isHovered ? 1.4 * targetOpacityBoost : targetOpacityBoost;
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            animateDotHover(dotMesh, isHovering) {
                // æ‰¾åˆ°å°æ‡‰çš„é»è³‡æ–™
                const dotData = this.interactiveDots.find(d => d.mesh === dotMesh);
                if (!dotData) return;
                
                // é¿å…é‡è¤‡å‹•ç•«
                if (dotMesh.userData.isAnimating) return;
                dotMesh.userData.isAnimating = true;
                
                // è¨­å®šç›®æ¨™é€æ˜åº¦ä¹˜æ•¸
                const targetOpacityMultiplier = isHovering ? 1.4 : 1.0;
                const duration = 200;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨æ›´å¿«çš„ç·©å‹•å‡½æ•¸ï¼Œè®“hoveråæ‡‰æ›´å³æ™‚
                    const easeProgress = 1 - Math.pow(1 - progress, 2); // ease-out quad
                    
                    // æ›´æ–°é€æ˜åº¦ä¹˜æ•¸
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetOpacityMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        dotMesh.userData.isAnimating = false;
                    }
                };
                animate();
            }

            // ğŸ¯ ================== è·é›¢æ„Ÿæ‡‰äº’å‹•ç³»çµ± ==================

            updateDistanceInteraction(event) {
                if (!this.loadingComplete || !this.layers.length) return;
                
                // ç²å–æ»‘é¼ åœ¨ç•«é¢ä¸­çš„ä½ç½®
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                // ç²å–ä¸»åœ–çš„å°ºå¯¸å’Œä½ç½®ä¿¡æ¯
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // è¨ˆç®—è¢å¹•ä¸­å¿ƒé»
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // è¨ˆç®—æœ€å¤§æ„Ÿæ‡‰è·é›¢ï¼ˆåŸºæ–¼ä¸»åœ–å¯¬åº¦ï¼‰
                const maxDistancePixels = width * this.MAX_DISTANCE * (window.innerWidth / (width * this.IMAGE_SCALE));
                
                this.interactiveDots.forEach(dotData => {
                    // è¨ˆç®—é»é»åœ¨è¢å¹•ä¸Šçš„å¯¦éš›ä½ç½®
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    
                    // è¨ˆç®—æ»‘é¼ èˆ‡é»é»çš„è·é›¢
                    const deltaX = mouseX - dotScreenX;
                    const deltaY = mouseY - dotScreenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // è¨ˆç®—è·é›¢ä¿‚æ•¸ (0 = æœ€è¿‘, 1 = æœ€é /è¶…å‡ºç¯„åœ)
                    let distanceFactor = Math.min(distance / maxDistancePixels, 1.0);
                    
                    // ä½¿ç”¨ç·©å‹•æ›²ç·šè®“è·é›¢è®ŠåŒ–æ›´è‡ªç„¶
                    distanceFactor = this.easeOutQuad(distanceFactor);
                    
                    // è¨­å®šç›®æ¨™è·é›¢ä¿‚æ•¸
                    dotData.targetMouseDistance = distanceFactor;
                });
            }

            updateDistanceInteractionAnimation() {
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // è·é›¢äº’å‹•å•Ÿç”¨ï¼šå¹³æ»‘éæ¸¡åˆ°ç›®æ¨™è·é›¢ä¿‚æ•¸
                        const delta = dotData.targetMouseDistance - dotData.mouseDistance;
                        dotData.mouseDistance += delta * this.DISTANCE_LERP_SPEED;
                        
                        // è¨ˆç®—åŸºæ–¼è·é›¢çš„ç¸®æ”¾å’Œé€æ˜åº¦
                        // ä½¿ç”¨åè½‰çš„è·é›¢ä¿‚æ•¸ï¼šè·é›¢è¿‘æ™‚ä¿‚æ•¸å¤§ï¼Œè·é›¢é æ™‚ä¿‚æ•¸å°
                        const proximityFactor = 1.0 - dotData.mouseDistance;
                        
                        // ç¸®æ”¾ä¿‚æ•¸ï¼šå¾æœ€å°ç¸®æ”¾åˆ°1.0
                        dotData.distanceScale = this.MIN_SCALE_FACTOR + (1.0 - this.MIN_SCALE_FACTOR) * proximityFactor;
                        
                        // é€æ˜åº¦ä¿‚æ•¸ï¼šå¾æœ€å°é€æ˜åº¦åˆ°1.0
                        dotData.distanceOpacity = this.MIN_OPACITY_FACTOR + (1.0 - this.MIN_OPACITY_FACTOR) * proximityFactor;
                    } else {
                        // è·é›¢äº’å‹•é—œé–‰ï¼šä¿æŒæ­£å¸¸å¤§å°å’Œé€æ˜åº¦
                        dotData.mouseDistance = 0.0;
                        dotData.targetMouseDistance = 0.0;
                        dotData.distanceScale = 1.0;
                        dotData.distanceOpacity = 1.0;
                    }
                });
            }

            resetDistanceInteraction() {
                // é‡ç½®æ‰€æœ‰é»é»çš„è·é›¢ä¿‚æ•¸
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // è·é›¢äº’å‹•å•Ÿç”¨ï¼šé‡ç½®åˆ°æœ€é ç‹€æ…‹
                        dotData.targetMouseDistance = 1.0;
                    } else {
                        // è·é›¢äº’å‹•é—œé–‰ï¼šé‡ç½®åˆ°æ­£å¸¸ç‹€æ…‹
                        dotData.targetMouseDistance = 0.0;
                    }
                });
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            // ğŸ¯ ================== è·é›¢æ„Ÿæ‡‰äº’å‹•ç³»çµ±çµæŸ ==================

            fadeInInteractiveDots() {
                // äº’å‹•é»é»çš„æ·¡å…¥å‹•ç•«
                const fadeInDuration = 1500; // 1.5ç§’æ·¡å…¥
                const startTime = Date.now();
                
                this.interactiveDots.forEach((dotData, index) => {
                    const delay = index * 300; // æ¯å€‹é»éŒ¯é–‹0.3ç§’
                    
                    setTimeout(() => {
                        dotData.mesh.userData.isVisible = true;
                        // ç‚ºæ¯å€‹é»è¨­å®šç¨ç«‹çš„å‹•ç•«é–‹å§‹æ™‚é–“
                        dotData.mesh.userData.animationStartTime = Date.now();
                        
                        const animate = () => {
                            const elapsed = Date.now() - startTime - delay;
                            const progress = Math.max(0, Math.min(elapsed / fadeInDuration, 1));
                            
                            if (progress > 0) {
                                // ç·©å‹•å‡½æ•¸ï¼šease-out
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                
                                // åœ¨æ·¡å…¥éç¨‹ä¸­å°±é–‹å§‹è¨ˆç®—å‘¼å¸å‹•ç•«ï¼Œç¢ºä¿çµ²æ»‘éŠœæ¥
                                const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                                const phase = index * Math.PI * 0.8;
                                const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                                
                                // ğŸ¯ æ›´æ–°è·é›¢äº’å‹•å‹•ç•«ï¼ˆæ·¡å…¥æœŸé–“ä¹Ÿéœ€è¦ï¼‰
                                this.updateDistanceInteractionAnimation();
                                
                                // æ·¡å…¥æœŸé–“ï¼šé€æ˜åº¦ = æ·¡å…¥é€²åº¦ Ã— åŸºç¤é€æ˜åº¦ Ã— å‘¼å¸ä¿‚æ•¸ Ã— hoverä¹˜æ•¸ Ã— è·é›¢é€æ˜åº¦ Ã— éæ¸¡é€æ˜åº¦
                                const targetOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                                const opacity = targetOpacity * easeProgress;
                                dotData.mesh.material.opacity = opacity;
                                
                                // å¤§å°å‘¼å¸æ•ˆæœï¼Œåœ¨æ·¡å…¥æœŸé–“ä¹ŸåŒæ­¥é–‹å§‹ï¼Œä¸¦è€ƒæ…®æ‰€æœ‰ç¸®æ”¾æ•ˆæœ
                                const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                                // çµ„åˆæ‰€æœ‰ç¸®æ”¾æ•ˆæœï¼šå‘¼å¸ Ã— hover Ã— æŒ‰ä¸‹ Ã— è·é›¢
                                const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                                const finalScale = hoverScale * dotData.pressedScale * dotData.distanceScale;
                                const scaleFactor = finalScale * easeProgress + (1 - easeProgress);
                                dotData.mesh.scale.setScalar(scaleFactor);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else {
                                // æ·¡å…¥å®Œæˆï¼Œåˆ‡æ›åˆ°ç´”å‘¼å¸å‹•ç•«
                                this.startBreathingAnimation(dotData, index);
                            }
                        };
                        animate();
                    }, delay);
                });
            }

            startBreathingAnimation(dotData, index) {
                // æ¡Œæ©Ÿç‰ˆå’Œè¡Œå‹•ç‰ˆçš„çµ±ä¸€å‘¼å¸å‹•ç•«ï¼Œä½¿ç”¨æ¯å€‹é»ç¨ç«‹çš„æ™‚é–“åŸºæº–
                const breathAnimate = () => {
                    if (!dotData.mesh.userData.isVisible) return;
                    
                    // ğŸ¯ æ›´æ–°è·é›¢äº’å‹•å‹•ç•«
                    this.updateDistanceInteractionAnimation();
                    
                    // ä½¿ç”¨æ¯å€‹é»ç¨ç«‹çš„å‹•ç•«é–‹å§‹æ™‚é–“ï¼Œç¢ºä¿çµ²æ»‘éŠœæ¥
                    const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                    const phase = index * Math.PI * 0.8; // æ¯å€‹é»æœ‰ä¸åŒçš„ç›¸ä½
                    
                    // é€æ˜åº¦å‘¼å¸æ•ˆæœï¼šåŸºç¤å‘¼å¸ Ã— hoverä¹˜æ•¸ Ã— è·é›¢é€æ˜åº¦ Ã— éæ¸¡é€æ˜åº¦
                    const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                    const currentOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                    dotData.mesh.material.opacity = currentOpacity;
                    
                    // å¤§å°å‘¼å¸æ•ˆæœï¼šçµ„åˆå‘¼å¸ã€hoverã€æŒ‰ä¸‹å’Œè·é›¢æ•ˆæœ
                    const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                    const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                    const scaleFactor = hoverScale * dotData.pressedScale * dotData.distanceScale;
                    dotData.mesh.scale.setScalar(scaleFactor);
                    
                    requestAnimationFrame(breathAnimate);
                };
                breathAnimate();
            }

            // ğŸ”´ ================== äº’å‹•é»é»ç³»çµ±çµæŸ ==================

            // ğŸ” ================== å±€éƒ¨åœ–ç³»çµ± ==================

            // ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶æ–¹æ³•
            updateDetailViewControl(inputX, inputY) {
                // æ›´æ–°å±€éƒ¨è¦–è§’çš„æ»‘é¼ ä½ç½®
                this.detailViewMouse.x = inputX;
                this.detailViewMouse.y = inputY;
                
                // è¨ˆç®—é‚Šç•Œè¶…å‡ºæ•ˆæœçš„åç§»é‡ - ç›¸åæ–¹å‘
                const offsetX = -inputX * this.DETAIL_VIEW_INTENSITY;  // Xè»¸ç›¸å
                const offsetY = -inputY * this.DETAIL_VIEW_INTENSITY;  // Yè»¸ç›¸å
                
                // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
                const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                this.detailViewOffset.x = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
                this.detailViewOffset.y = Math.max(-maxOffset, Math.min(maxOffset, offsetY));
                
                // æ›´æ–°å ´æ™¯ä½ç½®ä»¥å¯¦ç¾é‚Šç•Œè¶…å‡ºæ•ˆæœ
                if (this.currentDetailDot) {
                    const detailLayer = this.detailLayers.find(layer => 
                        layer.detailInfo.dotId === this.currentDetailDot.config.id
                    );
                    
                    if (detailLayer) {
                        const detailMesh = detailLayer.mesh;
                        
                        // è¨ˆç®—åŸºç¤å ´æ™¯ä½ç½®ï¼ˆå±€éƒ¨åœ–ä¸­å¿ƒå°é½Šç•«é¢ä¸­å¿ƒï¼‰
                        const baseSceneX = -detailMesh.position.x;
                        const baseSceneY = -detailMesh.position.y;
                        
                        // æ‡‰ç”¨é‚Šç•Œè¶…å‡ºåç§»
                        this.scene.position.x = baseSceneX + this.detailViewOffset.x;
                        this.scene.position.y = baseSceneY + this.detailViewOffset.y;
                        
                        // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                        // console.log(`ğŸ•¹ï¸ å±€éƒ¨è¦–è§’æ§åˆ¶: offset(${this.detailViewOffset.x.toFixed(3)}, ${this.detailViewOffset.y.toFixed(3)})`);
                    }
                }
            }

            resetDetailViewControl() {
                // é‡ç½®å±€éƒ¨è¦–è§’æ§åˆ¶
                this.detailViewMouse.x = 0;
                this.detailViewMouse.y = 0;
                this.detailViewOffset.x = 0;
                this.detailViewOffset.y = 0;
            }

            // ğŸ”´ ================== é»é»éæ¸¡é€æ˜åº¦æ§åˆ¶ç³»çµ± ==================

            updateDotsTransitionOpacity(animationType, progress) {
                // æ›´æ–°é»é»åœ¨æ”¾å¤§ç¸®å°éç¨‹ä¸­çš„é€æ˜åº¦
                if (!this.interactiveDots.length) return;

                let transitionOpacity = 1.0;

                if (animationType === 'zoomIn') {
                    // æ”¾å¤§æ™‚æ·¡å‡ºï¼šé€²åº¦ 0.0â†’0.5 é€æ˜åº¦ 100%â†’0%ï¼Œé€²åº¦ 0.5â†’1.0 é€æ˜åº¦ä¿æŒ 0%
                    if (progress <= 0.5) {
                        transitionOpacity = 1.0 - (progress / 0.5); // å¾1.0éæ¸¡åˆ°0.0
                    } else {
                        transitionOpacity = 0.0; // ä¿æŒé€æ˜
                    }
                } else if (animationType === 'zoomOut') {
                    // ç¸®å°æ™‚æ·¡å…¥ï¼šé€²åº¦ 0.0â†’0.5 é€æ˜åº¦ä¿æŒ 0%ï¼Œé€²åº¦ 0.5â†’1.0 é€æ˜åº¦ 0%â†’100%
                    if (progress <= 0.5) {
                        transitionOpacity = 0.0; // ä¿æŒé€æ˜
                    } else {
                        transitionOpacity = (progress - 0.5) / 0.5; // å¾0.0éæ¸¡åˆ°1.0
                    }
                }

                // æ‡‰ç”¨åˆ°æ‰€æœ‰é»é»
                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = transitionOpacity;
                });

                // å¯é¸ï¼šæ·»åŠ èª¿è©¦è³‡è¨Š
                // console.log(`ğŸ”´ é»é»éæ¸¡é€æ˜åº¦: ${animationType}, progress=${progress.toFixed(3)}, opacity=${transitionOpacity.toFixed(3)}`);
            }

            resetDotsTransitionOpacity(opacity) {
                // é‡ç½®æ‰€æœ‰é»é»çš„éæ¸¡é€æ˜åº¦
                if (!this.interactiveDots.length) return;

                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = opacity;
                });

                console.log(`ğŸ”´ é‡ç½®é»é»é€æ˜åº¦: ${(opacity * 100).toFixed(0)}%`);
            }

            // ğŸ”´ ================== é»é»éæ¸¡é€æ˜åº¦æ§åˆ¶ç³»çµ±çµæŸ ==================
        }

        // å…¨åŸŸè®Šæ•¸ç”¨æ–¼å­˜å–ParallaxViewerå¯¦ä¾‹
        let parallaxViewerInstance = null;

        // è¿”å›æŒ‰éˆ•è™•ç†å‡½æ•¸
        function handleBackButton() {
            if (parallaxViewerInstance) {
                if (parallaxViewerInstance.viewState === 'detail') {
                    // å±€éƒ¨è¦–è§’ï¼šè¿”å›ä¸»è¦–è§’
                    parallaxViewerInstance.returnToMainView();
                } else {
                    // ä¸»è¦–è§’ï¼šè¿”å›é¦–é 
                    window.location.href = '#';
                }
            } else {
                // é è¨­è¡Œç‚º
                window.location.href = '#';
            }
        }

        // ğŸ® é™€èºå„€æ¬Šé™è™•ç†å‡½æ•¸
        async function handleGyroPermission() {
            if (parallaxViewerInstance) {
                console.log('ğŸ® ä½¿ç”¨è€…é»æ“Šé™€èºå„€æ¬Šé™æŒ‰éˆ•');
                
                const success = await parallaxViewerInstance.startGyroControl();
                if (success) {
                    // éš±è—æ¬Šé™æŒ‰éˆ•
                    const button = document.getElementById('gyro-permission-button');
                    if (button) {
                        button.style.display = 'none';
                    }
                    
                    // åˆ‡æ›åˆ°é™€èºå„€æ§åˆ¶æ¨¡å¼
                    parallaxViewerInstance.currentControlMode = 'gyro';
                    console.log('ğŸ® æˆåŠŸå•Ÿç”¨é™€èºå„€æ§åˆ¶');
                    
                    // é¡¯ç¤ºé‡ç½®é™€èºå„€æŒ‰éˆ•
                    parallaxViewerInstance.showResetGyroButton();
                } else {
                    // æ¬Šé™è¢«æ‹’çµ•ï¼Œä¿æŒæŒ‡é‡æ§åˆ¶æ¨¡å¼
                    parallaxViewerInstance.currentControlMode = 'pointer';
                    console.log('ğŸ® é™€èºå„€æ¬Šé™è¢«æ‹’çµ•ï¼Œä½¿ç”¨æŒ‡é‡æ§åˆ¶æ¨¡å¼');
                }
            }
        }

        // ğŸ® é‡ç½®é™€èºå„€è™•ç†å‡½æ•¸
        function handleResetGyro() {
            if (parallaxViewerInstance) {
                console.log('ğŸ® ä½¿ç”¨è€…é»æ“Šé‡ç½®é™€èºå„€æŒ‰éˆ•');
                
                const success = parallaxViewerInstance.resetGyroBase();
                if (success) {
                    // é¡¯ç¤ºæˆåŠŸæç¤ºï¼ˆå¯é¸ï¼‰
                    console.log('ğŸ® é™€èºå„€åŸºæº–å€¼é‡ç½®æˆåŠŸ');
                } else {
                    // é¡¯ç¤ºéŒ¯èª¤æç¤ºï¼ˆå¯é¸ï¼‰
                    console.log('ğŸ® é™€èºå„€é‡ç½®å¤±æ•—ï¼Œè«‹ç¢ºä¿é™€èºå„€å·²å•Ÿç”¨');
                }
            }
        }

        // åˆå§‹åŒ–æ‡‰ç”¨ç¨‹å¼
        document.addEventListener('DOMContentLoaded', () => {
            parallaxViewerInstance = new ParallaxViewer();
            
            // ğŸ® æ ¹æ“šè£ç½®é¡å‹æ±ºå®šæ˜¯å¦é¡¯ç¤ºé™€èºå„€æ¬Šé™æŒ‰éˆ•
            if (parallaxViewerInstance.isMobile && 
                'DeviceOrientationEvent' in window && 
                parallaxViewerInstance.needsGyroPermission()) {
                
                const button = document.getElementById('gyro-permission-button');
                if (button) {
                    // å»¶é²é¡¯ç¤ºï¼Œè®“ä½¿ç”¨è€…å…ˆé«”é©—åŸºæœ¬åŠŸèƒ½
                    setTimeout(() => {
                        button.style.display = 'flex';
                    }, 3000); // 3ç§’å¾Œé¡¯ç¤º
                }
            } else if (parallaxViewerInstance.isMobile && 
                       'DeviceOrientationEvent' in window) {
                // ä¸éœ€è¦æ¬Šé™è«‹æ±‚çš„è£ç½®ï¼Œç›´æ¥å•Ÿç”¨é™€èºå„€
                parallaxViewerInstance.startGyroControl().then(success => {
                    if (success) {
                        parallaxViewerInstance.currentControlMode = 'gyro';
                        console.log('ğŸ® è‡ªå‹•å•Ÿç”¨é™€èºå„€æ§åˆ¶ï¼ˆç„¡éœ€æ¬Šé™ï¼‰');
                        
                        // è‡ªå‹•å•Ÿç”¨é™€èºå„€å¾Œï¼Œåœ¨è¼‰å…¥å®Œæˆæ™‚é¡¯ç¤ºé‡ç½®æŒ‰éˆ•
                        // é‡ç½®æŒ‰éˆ•æœƒåœ¨ startLoadingFadeOutAndParallaxTransition ä¸­è™•ç†
                    }
                });
            }
        });


    </script>
</body>
</html>