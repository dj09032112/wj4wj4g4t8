<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∫íÂãïÂºèË¶ñÂ∑ÆÁ∂≤È†Å</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a1a);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* üé≠ ‰∏âÂ±§Á¥öÊû∂Êßã Z-Index ÂÆöÁæ© */
        /* Â±§Á¥ö 3: UI Â±§ (z-index: 3000+) */
        #back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI Â±§ÔºöÊúÄ‰∏äÂ±§ */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #back-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        #back-button svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        /* üéÆ ÈôÄËû∫ÂÑÄÊ¨äÈôêÊåâÈàïÊ®£Âºè */
        #gyro-permission-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            font-family: Arial, sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 3000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #gyro-permission-button:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        #gyro-permission-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* üéÆ ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàïÊ®£Âºè */
        #reset-gyro-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            font-family: Arial, sans-serif;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 3000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #reset-gyro-button:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        #reset-gyro-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Â±§Á¥ö 2: ËºâÂÖ•Â±§ (z-index: 2000+) */
        #loading-cover {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 2000; /* ËºâÂÖ•Â±§Ôºö‰∏≠ÈñìÂ±§ */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #loading-cover.fade-in {
            opacity: 1;
            transition: opacity 0.5s ease; /* ÊòéÁ¢∫Ë®≠ÂÆöÊ∑°ÂÖ•ÊôÇÈñì */
        }

        @keyframes fadeOut { 
            0% { opacity: 1; } 
            80% { opacity: 0.15; } 
            100% { opacity: 0; } 
        }
        
        #loading-cover.fade-out { 
            animation: fadeOut 0.9s ease-out forwards; 
            will-change: opacity;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2001; /* ËºâÂÖ•Â±§ÔºöËºâÂÖ•ÂãïÁï´ */
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        #loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-container {
            position: relative;
            padding: 40px;
        }



        .elegant-spinner {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
        }

        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
        }

        .spinner-ring:nth-child(1) {
            border-top: 2px solid #dc9c3b;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .spinner-ring:nth-child(2) {
            border-right: 2px solid #d1936b;
            transform: scale(0.8);
            filter: drop-shadow(0 0 6px rgba(209, 147, 107, 0.4));
        }

        .spinner-ring:nth-child(3) {
            border-bottom: 2px solid #f4e3d4;
            transform: scale(0.6);
            filter: drop-shadow(0 0 4px rgba(244, 227, 212, 0.3));
        }

        .loading-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 20px;
        }

        .dot {
            width: 5px;
            height: 5px;
            background: #dc9c3b;
            border-radius: 50%;
            animation: dotPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(220, 156, 59, 0.5);
        }

        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.3s; }
        .dot:nth-child(3) { animation-delay: 0.6s; }

        .loading-particles {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 200px;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            opacity: 0;
            animation: particleFloat 4s linear infinite, particleGlow 2s ease-in-out infinite alternate;
            bottom: 5px; /* ÂàùÂßã‰ΩçÁΩÆÂú®ÂÆπÂô®Â∫ïÈÉ®Â§ñÈù¢ */
            filter: brightness(1.2);
        }

        @keyframes titleGlow {
            0% { 
                text-shadow: 0 0 20px rgba(244, 227, 212, 0.5);
                transform: scale(1);
            }
            100% { 
                text-shadow: 0 0 30px rgba(244, 227, 212, 0.8), 0 0 40px rgba(220, 156, 59, 0.3);
                transform: scale(1.02);
            }
        }

        @keyframes elegantSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes dotPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 0.3; 
            }
            50% { 
                transform: scale(1.3); 
                opacity: 1; 
                box-shadow: 0 0 15px rgba(220, 156, 59, 0.8);
            }
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(0) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(-20px) scale(1);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-250px) scale(1);
                opacity: 0;
            }
        }



        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2002; /* ËºâÂÖ•Â±§ÔºöÈåØË™§Ë®äÊÅØ */
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            max-width: 80%;
            display: none;
        }



        /* Â±§Á¥ö 1: ÂÖßÂÆπÂ±§ (z-index: 1000+) */
        #canvas {
            display: block;
            z-index: 1000; /* ÂÖßÂÆπÂ±§ÔºöÊúÄ‰∏ãÂ±§ */
        }

        @media (max-width: 768px) {
            #back-button {
                width: 45px;
                height: 45px;
                top: 15px;
                left: 15px;
            }
            
            .loading-container {
                padding: 20px;
            }
            
            .elegant-spinner {
                width: 60px;
                height: 60px;
                margin: 0 auto 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading-cover">
            <canvas id="loading-canvas"></canvas>
        </div>
        
        <div id="loading">
            <div class="loading-container">
                <div class="loading-particles" id="particles"></div>
                <div class="elegant-spinner">
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                </div>
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>
        
        <div id="error-message">
            <h3>‚ö†Ô∏è ËºâÂÖ•ÈåØË™§</h3>
            <p>Ë´ã‰ΩøÁî®Êú¨Âú∞‰º∫ÊúçÂô®ÈñãÂïüÊ≠§Á∂≤È†Å‰ª•ÈÅøÂÖç CORS ÂïèÈ°å</p>
            <br>
            <p><strong>Âª∫Ë≠∞Ëß£Ê±∫ÊñπÊ°àÔºö</strong></p>
            <p>1. ‰ΩøÁî® Python: <code>python -m http.server 8000</code></p>
            <p>2. ‰ΩøÁî® Node.js: <code>npx http-server</code></p>
            <p>3. ‰ΩøÁî® VS Code Live Server Êì¥ÂÖÖÂäüËÉΩ</p>
        </div>
        
        <button id="back-button" onclick="handleBackButton()">
            <svg viewBox="0 0 24 24">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.42-1.41L7.83 13H20v-2z"/>
            </svg>
        </button>
        
        <!-- üéÆ ÈôÄËû∫ÂÑÄÊ¨äÈôêÂºïÂ∞éÊåâÈàï -->
        <button id="gyro-permission-button" onclick="handleGyroPermission()" style="display: none;">
            <svg viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
            </svg>
            <span>ÂïüÁî®ÈôÄËû∫ÂÑÄ</span>
        </button>

        <!-- üéÆ ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï -->
        <button id="reset-gyro-button" onclick="handleResetGyro()" style="display: none;">
            <svg viewBox="0 0 24 24">
                <path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/>
            </svg>
            <span>ÈáçÁΩÆË¶ñËßí</span>
        </button>
        
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ParallaxViewer {
            constructor() {
                // üé≠ ‰∏âÂ±§Á¥öÊû∂ÊßãÁ≥ªÁµ±
                this.uiLayer = null;           // ÊúÄ‰∏äÂ±§ÔºöUI ÊéßÂà∂ÂÖÉÁ¥†
                this.loadingLayer = null;      // ‰∏≠ÈñìÂ±§ÔºöÂ∞ÅÈù¢ÂúñËàáËºâÂÖ•ÂãïÁï´
                this.contentLayer = null;      // ÊúÄ‰∏ãÂ±§Ôºö‰∏ªË¶ÅÂÖßÂÆπÂúñÂ±§ÁµÑ
                
                // Three.js Â†¥ÊôØÁ≥ªÁµ±
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.loadingScene = null;
                this.loadingCamera = null;
                this.loadingRenderer = null;
                
                // ÂúñÂ±§ÁÆ°ÁêÜ
                this.layers = [];              // ‰∏ªË¶ÅÂÖßÂÆπÂúñÂ±§ (7_BG~1_RabbitFornt)
                this.mainLayerGroup = null;    // ‰∏ªË¶ÅÂúñÂ±§ÁµÑÂÆπÂô®
                this.dotsGroup = null;         // ‰∫íÂãïÈªûÈªûÂÆπÂô®
                this.detailGroup1 = null;      // Â±ÄÈÉ®ÂúñÂÆπÂô®1
                this.detailGroup2 = null;      // Â±ÄÈÉ®ÂúñÂÆπÂô®2
                this.detailGroup3 = null;      // Â±ÄÈÉ®ÂúñÂÆπÂô®3
                this.detailLayers = [];        // Â±ÄÈÉ®ÂúñÂ±§Èô£Âàó
                
                // üéØ Ë¶ñËßíÁãÄÊÖãÁÆ°ÁêÜ
                this.viewState = 'main';       // 'main' | 'detail'
                this.currentDetailDot = null;  // Áï∂ÂâçÊîæÂ§ßÁöÑÈªûÈªû
                this.isTransitioning = false;  // ÊòØÂê¶Ê≠£Âú®ÈÅéÊ∏°ÂãïÁï´‰∏≠
                
                // üéØ Áõ∏Ê©üËÆäÊèõÂèÉÊï∏
                this.originalCameraPosition = { x: 0, y: 0, z: 5 };
                // targetCameraPosition Â∞áÂú®ÈúÄË¶ÅÊôÇÂãïÊÖãË®àÁÆóÔºå‰∏çÂÜç‰ΩøÁî®Âõ∫ÂÆöÂÄº
                this.originalScenePosition = { x: 0, y: 0, z: 0 };
                this.targetScenePosition = { x: 0, y: 0, z: 0 };
                
                // üïπÔ∏è Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂ÂèÉÊï∏
                this.DETAIL_VIEW_INTENSITY = 0.16;    // Â±ÄÈÉ®Ë¶ñËßíÁßªÂãïÂº∑Â∫¶ (Âª∫Ë≠∞ÁØÑÂúç: 0.05-0.3)
                this.DETAIL_VIEW_BOUNDARY = 0.26;      // ÈÇäÁïåË∂ÖÂá∫ÁØÑÂúç (Áõ∏Â∞çÊñºÂúñÁâáÂ§ßÂ∞è)
                this.detailViewMouse = { x: 0, y: 0 }; // Â±ÄÈÉ®Ë¶ñËßíÁöÑÊªëÈº†‰ΩçÁΩÆ
                this.detailViewOffset = { x: 0, y: 0 }; // Â±ÄÈÉ®Ë¶ñËßíÁöÑÂÅèÁßªÈáè
                
                // üåü Â±ÄÈÉ®ÂúñÁæΩÂåñÊïàÊûúÂèÉÊï∏
                this.FEATHER_MAIN_VIEW = 5.0;          // ‰∏ªË¶ñËßíÁæΩÂåñÂº∑Â∫¶ (Âª∫Ë≠∞ÁØÑÂúç: 0.5-1.0)
                this.FEATHER_DETAIL_VIEW = 0.1;        // Â±ÄÈÉ®Ë¶ñËßíÁæΩÂåñÂº∑Â∫¶ (Âª∫Ë≠∞ÁØÑÂúç: 0.0-0.3)
                this.FEATHER_TRANSITION_RANGE = 0.5;   // ÁæΩÂåñÂΩ±ÈüøÁØÑÂúç (Âª∫Ë≠∞ÁØÑÂúç: 0.2-0.5)
                
                // üå´Ô∏è ÈÅéÊ∏°Ê®°Á≥äÊïàÊûúÂèÉÊï∏
                this.TRANSITION_BLUR_STRENGTH = 3;      // ÈÅéÊ∏°Ê®°Á≥äÂº∑Â∫¶ (0-20ÔºåÂª∫Ë≠∞ÂÄºÔºö5-15)
                
                // üîç Â±ÄÈÉ®Ë¶ñËßíÊîæÂ§ßË®≠ÂÆö
                this.DETAIL_ZOOM_SCALE = 4.5;           // Â±ÄÈÉ®Ë¶ñËßíÊîæÂ§ßÂÄçÁéá (Âª∫Ë≠∞ÁØÑÂúç: 2.0-10.0ÔºåÈ†êË®≠5.0=500%)
                this.interactiveDots = [];     // ‰∫íÂãïÈªûÈªûÈô£Âàó
                this.raycaster = null;         // ÈªûÊìäÊ™¢Ê∏¨Âô®
                this.mouseVector = null;       // ÊªëÈº†ÂêëÈáè
                // üéÆ Ê∑∑ÂêàÊéßÂà∂Á≥ªÁµ±
                this.currentControlMode = 'none';  // Áï∂ÂâçÊéßÂà∂Ê®°ÂºèÔºö'none', 'pointer', 'gyro'
                this.gyroActive = false;           // ÈôÄËû∫ÂÑÄÊòØÂê¶Â∑≤ÂïüÁî®
                this.gyroPermissionGranted = false; // ÈôÄËû∫ÂÑÄÊ¨äÈôêÊòØÂê¶Â∑≤ÊéàÊ¨ä
                this.lastPointerTime = 0;          // ÊúÄÂæå‰∏ÄÊ¨°ÊåáÈáù‰∫ã‰ª∂ÊôÇÈñì
                this.POINTER_TIMEOUT = 300;        // ÊåáÈáù‰∫ã‰ª∂Ë∂ÖÊôÇÊôÇÈñì (ms)
                this.initialOrientation = this.getInitialOrientation(); // ÂÑ≤Â≠òÂàùÂßãËû¢ÂπïÊñπÂêë
                this.isResetting = false;          // ÊòØÂê¶Ê≠£Âú®Âü∑Ë°åÈáçÁΩÆÈÅéÊ∏°ÂãïÁï´
                
                // Áµ±‰∏ÄËº∏Âá∫ÊéßÂà∂ÂÄº
                this.currentOffsetX = 0;           // Áï∂ÂâçXËª∏ÂÅèÁßªÂÄº
                this.currentOffsetY = 0;           // Áï∂ÂâçYËª∏ÂÅèÁßªÂÄº
                
                // ÊªëÈº†ÊéßÂà∂Áõ∏Èóú
                this.mouse = { x: 0, y: 0 };
                this.targetMouse = { x: 0, y: 0 }; // ÁõÆÊ®ôÊªëÈº†‰ΩçÁΩÆ
                this.currentMouse = { x: 0, y: 0 }; // Áï∂ÂâçÊèíÂÄºÂæåÁöÑÊªëÈº†‰ΩçÁΩÆ
                this.mouseInsidePage = true; // ÊªëÈº†ÊòØÂê¶Âú®È†ÅÈù¢ÂÖß
                this.mouseJustReentered = false; // ÊªëÈº†ÊòØÂê¶ÂâõÈáçÊñ∞ÈÄ≤ÂÖ•È†ÅÈù¢
                this.mouseVelocity = { x: 0, y: 0 }; // ÊªëÈº†ÁßªÂãïÈÄüÂ∫¶
                this.inertiaTarget = { x: 0, y: 0 }; // ÊÖ£ÊÄßÁõÆÊ®ô‰ΩçÁΩÆ
                this.isInertiaActive = false; // ÊòØÂê¶Ê≠£Âú®Âü∑Ë°åÊÖ£ÊÄßÁ∑©Ë°ù
                
                // ÈôÄËû∫ÂÑÄÊéßÂà∂Áõ∏Èóú
                this.orientation = { x: 0, y: 0 };
                this.currentOrientation = this.getScreenOrientation();
                this.baseX = null;           // Áµ±‰∏ÄÁöÑXËª∏Âü∫Ê∫ñÂÄº
                this.baseY = null;           // Áµ±‰∏ÄÁöÑYËª∏Âü∫Ê∫ñÂÄº
                this.smoothedDelta = { x: 0, y: 0 }; // Âπ≥ÊªëÂæåÁöÑÂ∑ÆÂÄº
                this.SMOOTH_ALPHA = 0.15;    // ‰ΩéÈÄöÊøæÊ≥¢‰øÇÊï∏
                this.isMobile = this.detectMobile();
                this.loadingComplete = false;
                this.loadedImages = 0;
                this.totalImages = 0;
                this.errorCount = 0;
                this.loadingCoverLoaded = false;
                this.coverFadeOutComplete = false;
                this.parallaxTransitionProgress = 0; // 0 = ‰∏≠ÂøÉ‰ΩçÁΩÆ, 1 = ÊªëÈº†‰ΩçÁΩÆ
                
                // üéõÔ∏è Áµ±‰∏ÄË¶ñÂ∑ÆÂº∑Â∫¶ÊéßÂà∂ - Ë™øÊï¥ÈÄô‰∫õÊï∏ÂÄº‰æÜÊîπËÆäÊï¥È´îË¶ñÂ∑ÆÊïàÊûú
                this.PARALLAX_INTENSITY = 0.27; // ‰∏ªË¶ÅÊéßÂà∂ÂèÉÊï∏ÔºöÊéßÂà∂ÊªëÈº†/ÂÇæÊñúËº∏ÂÖ•ÁöÑÂΩ±ÈüøÁ®ãÂ∫¶ (Âª∫Ë≠∞ÁØÑÂúç: 0.05-0.3)
                this.DEPTH_SENSITIVITY = 0.5;  // Ê∑±Â∫¶ÂúñÊïèÊÑüÂ∫¶ÔºöÊéßÂà∂Ê∑±Â∫¶Â∑ÆÁï∞ÁöÑË¶ñÂ∑ÆÂπÖÂ∫¶ (Âª∫Ë≠∞ÁØÑÂúç: 0.1-0.5)
                
                // üì± Ë°åÂãïË£ùÁΩÆÈôÄËû∫ÂÑÄÊéßÂà∂
                this.GYRO_SENSITIVITY = 5.0;    // ÈôÄËû∫ÂÑÄÈùàÊïèÂ∫¶ÔºöÊéßÂà∂Ë£ùÁΩÆÂÇæÊñúÁöÑÊïèÊÑüÁ®ãÂ∫¶ (Âª∫Ë≠∞ÁØÑÂúç: 0.5-2.0)
                this.GYRO_INVERT_X = true;       // ÊòØÂê¶ÂèçËΩâXËª∏ (Â∑¶Âè≥ÂÇæÊñú)Ôºötrue=Ë£ùÁΩÆÂ∑¶ÂÇæÊôÇÁï´Èù¢Âè≥Áßª
                
                // üñºÔ∏è Áµ±‰∏ÄÂúñÁâáÂ§ßÂ∞èÊéßÂà∂
                this.IMAGE_SCALE = 1.02;        // ÂúñÁâáÁ∏ÆÊîæÊØî‰æãÔºöÊéßÂà∂Â∞ÅÈù¢ÂúñÂíå‰∏ªÂúñÁöÑÂ§ßÂ∞è (Âª∫Ë≠∞ÁØÑÂúç: 0.5-1.5)
                
                // ü´Å ÂëºÂê∏ÂãïÁï´ÊéßÂà∂
                this.BREATH_SPEED = 0.003;      // ÂëºÂê∏ÈÄüÂ∫¶‰øÇÊï∏ÔºöÊï∏ÂÄºË∂äÂ§ßÂëºÂê∏Ë∂äÂø´ (Âª∫Ë≠∞ÁØÑÂúç: 0.001-0.005)
                
                // üéØ Ë∑ùÈõ¢ÊÑüÊáâ‰∫íÂãïÊéßÂà∂
                this.DISTANCE_INTERACTION_ENABLED = !this.isMobile;  // Ê°åÊ©üÁâàÂïüÁî®ÔºåË°åÂãïÁâàÈóúÈñâ
                this.MAX_DISTANCE = 0.3;                   // ÊúÄÂ§ßÊÑüÊáâË∑ùÈõ¢ÔºàÁõ∏Â∞çÊñº‰∏ªÂúñÂØ¨Â∫¶Ôºâ
                this.MIN_SCALE_FACTOR = 0.6;               // ÊúÄÈÅ†ÊôÇÁöÑÊúÄÂ∞èÁ∏ÆÊîæÔºà60%Ôºâ
                this.MIN_OPACITY_FACTOR = 0.5;             // ÊúÄÈÅ†ÊôÇÁöÑÊúÄÂ∞èÈÄèÊòéÂ∫¶Ôºà50%Ôºâ
                this.DISTANCE_LERP_SPEED = 0.5;            // Ë∑ùÈõ¢ÂãïÁï´ÈÅéÊ∏°ÈÄüÂ∫¶

                /*
                 * üìñ ÂèÉÊï∏Ë™™ÊòéÔºö
                 * 
                 * PARALLAX_INTENSITY (parallaxOffset ÁöÑ‰πòÊï∏)Ôºö
                 * - ÊéßÂà∂ÊªëÈº†ÁßªÂãïÊàñË£ùÁΩÆÂÇæÊñúÂ∞çË¶ñÂ∑ÆÁöÑÂΩ±ÈüøÁ®ãÂ∫¶
                 * - Êï∏ÂÄºË∂äÂ§ßÔºåÊªëÈº†ÁßªÂãïÊôÇË¶ñÂ∑ÆÊïàÊûúË∂äÊòéÈ°Ø
                 * - ÂΩ±ÈüøÊï¥È´îË¶ñÂ∑ÆÁöÑ"ÈùàÊïèÂ∫¶"
                 * 
                 * DEPTH_SENSITIVITY (parallaxStrength)Ôºö
                 * - ÊéßÂà∂Ê∑±Â∫¶Âúñ‰∏≠‰∏çÂêåÁÅ∞ÈöéÂÄº‰πãÈñìÁöÑË¶ñÂ∑ÆÂ∑ÆÁï∞
                 * - Êï∏ÂÄºË∂äÂ§ßÔºåÊ∑±Â∫¶ÂúñÁöÑÁôΩËâ≤ÂíåÈªëËâ≤ÂçÄÂüüË¶ñÂ∑ÆÂ∑ÆÁï∞Ë∂äÂ§ß
                 * - ÂΩ±ÈüøË¶ñÂ∑ÆÁöÑ"Ê∑±Â∫¶ÊÑü"
                 * 
                 * GYRO_SENSITIVITYÔºö
                 * - ÊéßÂà∂Ë°åÂãïË£ùÁΩÆÈôÄËû∫ÂÑÄÁöÑÊïèÊÑüÁ®ãÂ∫¶
                 * - Êï∏ÂÄºË∂äÂ§ßÔºåË£ùÁΩÆÂÇæÊñúÊôÇË¶ñÂ∑ÆÊïàÊûúË∂äÊòéÈ°Ø
                 * - ÂÉÖÂΩ±ÈüøË°åÂãïË£ùÁΩÆÁöÑÂÇæÊñúÊéßÂà∂
                 * 
                 * GYRO_INVERT_XÔºö
                 * - ÊéßÂà∂ÊòØÂê¶ÂèçËΩâÂ∑¶Âè≥ÂÇæÊñúÁöÑÊñπÂêë
                 * - trueÔºöË£ùÁΩÆÂ∑¶ÂÇæÊôÇÁï´Èù¢ÂêëÂè≥ÁßªÂãïÔºàÊõ¥Áõ¥ËßÄÔºâ
                 * - falseÔºöË£ùÁΩÆÂ∑¶ÂÇæÊôÇÁï´Èù¢ÂêëÂ∑¶ÁßªÂãï
                 * 
                 * üéØ Ë™øÊï¥Âª∫Ë≠∞Ôºö
                 * - ÊÉ≥Ë¶ÅÊõ¥ÊïèÊÑüÁöÑÊªëÈº†ÊéßÂà∂ ‚Üí Â¢ûÂä† PARALLAX_INTENSITY
                 * - ÊÉ≥Ë¶ÅÊõ¥ÊïèÊÑüÁöÑÈôÄËû∫ÂÑÄÊéßÂà∂ ‚Üí Â¢ûÂä† GYRO_SENSITIVITY
                 * - ÊÉ≥Ë¶ÅÊõ¥Âº∑ÁÉàÁöÑÊ∑±Â∫¶ÊïàÊûú ‚Üí Â¢ûÂä† DEPTH_SENSITIVITY  
                 * - ÊÉ≥Ë¶ÅÊõ¥Á¥∞ËÜ©ÁöÑÊïàÊûú ‚Üí ÂêåÊôÇÈôç‰ΩéÊâÄÊúâÊï∏ÂÄº
                 */
                
                // ÂúñÂ±§Ë≥áË®ä - ÊåâÁÖßÂæûÂæåÂà∞ÂâçÁöÑÈ†ÜÂ∫èÔºà7ÊúÄÂæåÈù¢Ôºå1ÊúÄÂâçÈù¢Ôºâ
                this.layerInfo = [
                    { name: '0_7_BG' },        // ÊúÄÂ∫ïÂ±§ËÉåÊôØ
                    { name: '0_6_RabbitBack' }, // ÂæåÊñπÂÖîÂ≠ê
                    { name: '0_5_Volume' },     // È´îÁ©çÈúß
                    { name: '0_4_RabbitMain' }, // ‰∏ªË¶ÅÂÖîÂ≠ê
                    { name: '0_3_Text' },       // ÊñáÂ≠ó
                    { name: '0_2_Dust' },       // Â°µÂüÉÔºàÁèæÂú®Âú®ÊñáÂ≠ó‰πã‰∏äÔºâ
                    { name: '0_1_RabbitFornt' } // ÊúÄÂâçÂ±§ÂÖîÂ≠ê
                ];
                
                // üîç Â±ÄÈÉ®ÂúñÈÖçÁΩÆË≥áÊñô - ËàáÈªûÈªûÂ∞çÊáâ
                this.detailLayerInfo = [
                    { name: '1_0_All', dotId: 'dot1', group: 'detailGroup1' },
                    { name: '2_0_All', dotId: 'dot2', group: 'detailGroup2' },
                    { name: '3_0_All', dotId: 'dot3', group: 'detailGroup3' }
                ];
                
                this.init();
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       window.innerWidth <= 768;
            }

            // üéÆ Ê™¢Ê∏¨ÊòØÂê¶ÈúÄË¶ÅÊ¨äÈôêË´ãÊ±Ç
            needsGyroPermission() {
                return typeof DeviceOrientationEvent.requestPermission === 'function';
            }

            // üéÆ Áç≤ÂèñÂàùÂßãËû¢ÂπïÊñπÂêë
            getInitialOrientation() {
                if (screen.orientation && screen.orientation.angle !== undefined) {
                    return screen.orientation.angle;
                }
                return window.orientation || 0;
            }

            // üéõÔ∏è Áç≤ÂèñÁï∂ÂâçËû¢ÂπïÊñπÂêë
            getScreenOrientation() {
                // ÂÑ™ÂÖà‰ΩøÁî® Screen Orientation API
                if (screen.orientation && screen.orientation.type) {
                    return screen.orientation.type.split('-')[0] + '-' + screen.orientation.type.split('-')[1];
                }
                
                // ÂõûÈÄÄÂà∞ËßíÂ∫¶Âà§Êñ∑
                const angle = screen.orientation ? screen.orientation.angle : window.orientation;
                switch (angle) {
                    case 0: return 'portrait-primary';
                    case 90: return 'landscape-primary';
                    case -90:
                    case 270: return 'landscape-secondary';
                    case 180: return 'portrait-secondary';
                    default: return 'portrait-primary';
                }
            }

            // üéÆ ================== Ê∑∑ÂêàÊéßÂà∂Á≥ªÁµ±Ê†∏ÂøÉÊñπÊ≥ï ==================

            // üéõÔ∏è Ê†πÊìöËû¢ÂπïÊñπÂêëËΩâÊèõÈôÄËû∫ÂÑÄÊï∏ÂÄº
            transformGyroData(alpha, beta, gamma) {
                let x, y;
                
                // Áç≤ÂèñËû¢ÂπïÊñπÂêëËßíÂ∫¶ÈÄ≤Ë°åÂàùÂßãË£úÂÑü
                const orientationAngle = screen.orientation?.angle || window.orientation || 0;
                
                switch (this.currentOrientation) {
                    case 'portrait-primary':
                        x = gamma;
                        y = beta;
                        break;
                    case 'portrait-secondary':
                        x = -gamma;
                        y = -beta;
                        break;
                    case 'landscape-primary':
                        x = beta;
                        y = -gamma;
                        break;
                    case 'landscape-secondary':
                        x = -beta;
                        y = gamma;
                        break;
                    default:
                        x = gamma;
                        y = beta;
                }
                
                return { x, y };
            }

            // üéÆ ÂïüÂãïÈôÄËû∫ÂÑÄÊéßÂà∂ÔºàÂÉÖË≤†Ë≤¨ÊéàÊ¨äËàá‰∫ã‰ª∂Ë®ªÂÜäÔºâ
            async startGyroControl() {
                // Ê™¢Êü•ÊòØÂê¶ÊîØÊè¥ÈôÄËû∫ÂÑÄ
                if (!('DeviceOrientationEvent' in window)) {
                    console.log('‚ùå Ë£ùÁΩÆ‰∏çÊîØÊè¥ÈôÄËû∫ÂÑÄ');
                    return false;
                }
                
                // ÂòóË©¶Ë´ãÊ±ÇÊ¨äÈôêÔºàÂÉÖiOS 13+Ôºâ
                if (this.needsGyroPermission()) {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.gyroPermissionGranted = true;
                            console.log('‚úÖ ÈôÄËû∫ÂÑÄÊ¨äÈôêÂ∑≤ÊéàÊ¨ä');
                        } else {
                            console.log('‚ùå ÈôÄËû∫ÂÑÄÊ¨äÈôêË¢´ÊãíÁµï');
                            return false;
                        }
                    } catch (error) {
                        console.log('‚ùå ÈôÄËû∫ÂÑÄÊ¨äÈôêË´ãÊ±ÇÂ§±Êïó:', error);
                        return false;
                    }
                } else {
                    // ÂÖ∂‰ªñË£ùÁΩÆÔºàAndroid ÊàñËàä iOSÔºâÁõ¥Êé•ÂïüÁî®
                    this.gyroPermissionGranted = true;
                }
                
                // Ë®ªÂÜäÈôÄËû∫ÂÑÄ‰∫ã‰ª∂ÔºàÂ∏∏ÈßêÔºâ
                this.gyroActive = true;
                this.registerGyroEvents();
                console.log('üéÆ ÈôÄËû∫ÂÑÄ‰∫ã‰ª∂Â∑≤Ë®ªÂÜä');
                
                // ÈáçË®≠Âü∫Ê∫ñÂÄºÔºåÁ≠âÂæÖÁ¨¨‰∏ÄÁ≠Ü deviceorientation ‰∫ã‰ª∂
                this.baseX = null;
                this.baseY = null;
                
                return true;
            }

            // üéÆ ÂÅúÊ≠¢ÈôÄËû∫ÂÑÄÊéßÂà∂ÔºàÂÉÖË®≠ÂÆöÁãÄÊÖãÔºå‰∏çÁßªÈô§‰∫ã‰ª∂Ôºâ
            stopGyroControl() {
                this.gyroActive = false;
                console.log('üéÆ ÈôÄËû∫ÂÑÄÊéßÂà∂Â∑≤ÂÅúÁî®Ôºà‰∫ã‰ª∂‰øùÊåÅË®ªÂÜäÔºâ');
            }

            // üéÆ ÈáçÁΩÆÈôÄËû∫ÂÑÄÂü∫Ê∫ñÂÄº
            resetGyroBase() {
                if (!this.gyroActive || this.currentControlMode !== 'gyro') {
                    console.log('üéÆ ÈôÄËû∫ÂÑÄÊú™ÂïüÁî®Êàñ‰∏çÂú®ÈôÄËû∫ÂÑÄÊ®°ÂºèÔºåÁÑ°Ê≥ïÈáçÁΩÆ');
                    return false;
                }
                
                // ÈñãÂßã500msÁöÑÈÅéÊ∏°ÂãïÁï´
                this.startResetTransition();
                
                return true;
            }

            // üéÆ ÈñãÂßãÈáçÁΩÆÈÅéÊ∏°ÂãïÁï´
            startResetTransition() {
                const transitionDuration = 500; // 500ms
                const startTime = Date.now();
                const startOffsetX = this.currentOffsetX;
                const startOffsetY = this.currentOffsetY;
                
                // Ë®≠ÂÆöÈáçÁΩÆÁãÄÊÖãÔºåÈò≤Ê≠¢ÈôÄËû∫ÂÑÄÊõ¥Êñ∞Ë¶ÜËìãÈÅéÊ∏°ÂÄº
                this.isResetting = true;
                
                console.log('üéÆ ÈñãÂßãÈáçÁΩÆË¶ñËßíÈÅéÊ∏°ÂãïÁï´');
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / transitionDuration, 1);
                    
                    // ‰ΩøÁî®Á∑©Âá∫ÂáΩÊï∏ (ease-out) ËÆìÂãïÁï´Êõ¥Ëá™ÁÑ∂
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    
                    // ÂæûÁï∂ÂâçÂÅèÁßªÂÄºÂπ≥ÊªëÈÅéÊ∏°Âà∞0
                    this.currentOffsetX = startOffsetX * (1 - easedProgress);
                    this.currentOffsetY = startOffsetY * (1 - easedProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ÂãïÁï´ÂÆåÊàêÔºåÈáçË®≠Âü∫Ê∫ñÂÄº
                        this.currentOffsetX = 0;
                        this.currentOffsetY = 0;
                        this.baseX = null;
                        this.baseY = null;
                        this.smoothedDelta = { x: 0, y: 0 };
                        
                        // Ê∏ÖÈô§ÈáçÁΩÆÁãÄÊÖãÔºåÂÖÅË®±ÈôÄËû∫ÂÑÄÊ≠£Â∏∏Êõ¥Êñ∞
                        this.isResetting = false;
                        
                        console.log('üéÆ ÈáçÁΩÆË¶ñËßíÈÅéÊ∏°ÂãïÁï´ÂÆåÊàêÔºåÂü∫Ê∫ñÂÄºÂ∑≤ÈáçÁΩÆ');
                    }
                };
                
                animate();
            }

            // üéÆ ÂïüÂãïÊåáÈáùÊéßÂà∂ÔºàÂÉÖÂàáÊèõÊ®°ÂºèÔºå‰∏çÂÅúÊ≠¢ÈôÄËû∫ÂÑÄÔºâ
            startPointerControl() {
                if (this.currentControlMode === 'pointer') return;
                
                this.currentControlMode = 'pointer';
                this.lastPointerTime = Date.now();
                
                console.log('üéÆ ÂàáÊèõÂà∞ÊåáÈáùÊéßÂà∂Ê®°Âºè');
            }

            // üéÆ ÂÅúÊ≠¢ÊåáÈáùÊéßÂà∂
            stopPointerControl() {
                if (this.currentControlMode !== 'pointer') return;
                
                this.currentControlMode = 'none';
                console.log('üéÆ ÊåáÈáùÊéßÂà∂Â∑≤ÂÅúÊ≠¢');
            }

            // üéÆ ÂæûÈôÄËû∫ÂÑÄÊõ¥Êñ∞ÊéßÂà∂ÂÄº
            updateFromGyro(alpha, beta, gamma) {
                // Ê™¢Êü•ÊéßÂà∂Ê®°ÂºèÔºåÂè™ÊúâÂú®ÈôÄËû∫ÂÑÄÊ®°ÂºèÊôÇÊâçÊõ¥Êñ∞
                if (this.currentControlMode !== 'gyro') return;
                
                // Ê†πÊìöËû¢ÂπïÊñπÂêëËΩâÊèõÁÇ∫Áµ±‰∏ÄÁöÑX/YËª∏
                const { x, y } = this.transformGyroData(alpha, beta, gamma);

                // Á¨¨‰∏ÄÊ¨°ÈÄ≤‰æÜÊôÇÂª∫Á´ãÂü∫Ê∫ñÂÄº
                if (this.baseX === null) {
                    this.baseX = x;
                    this.baseY = y;
                    console.log('üéõÔ∏è Âª∫Á´ãÈôÄËû∫ÂÑÄÂü∫Ê∫ñÂÄº:', {
                        orientation: this.currentOrientation,
                        baseX: this.baseX.toFixed(2),
                        baseY: this.baseY.toFixed(2)
                    });
                    return; // Áõ¥Êé• returnÔºåÁ≠âÂæÖ‰∏ã‰∏ÄÁ≠ÜÂ∑ÆÂÄº
                }

                // Ë®àÁÆóÂ∑ÆÂÄº
                let deltaX = (x - this.baseX) / 45; // Ê®ôÊ∫ñÂåñÂà∞ ¬±1 ÁØÑÂúç
                let deltaY = (y - this.baseY) / 45;

                // ÊáâÁî®ÈùàÊïèÂ∫¶ÂèÉÊï∏
                deltaX *= this.GYRO_SENSITIVITY;
                deltaY *= this.GYRO_SENSITIVITY;

                // ÈôêÂà∂ÁØÑÂúç
                deltaX = THREE.MathUtils.clamp(deltaX, -1, 1);
                deltaY = THREE.MathUtils.clamp(deltaY, -1, 1);

                // üîÑ ÊáâÁî®Â∑¶Âè≥ÂèçËΩâË®≠ÂÆö
                if (this.GYRO_INVERT_X) {
                    deltaX = -deltaX;
                }

                // ‰ΩéÈÄöÊøæÊ≥¢Âπ≥ÊªëËôïÁêÜ
                this.smoothedDelta.x = this.smoothedDelta.x * (1 - this.SMOOTH_ALPHA) + deltaX * this.SMOOTH_ALPHA;
                this.smoothedDelta.y = this.smoothedDelta.y * (1 - this.SMOOTH_ALPHA) + deltaY * this.SMOOTH_ALPHA;

                // Êõ¥Êñ∞Áµ±‰∏ÄËº∏Âá∫ÂÄºÔºàÂè™ÊúâÂú®ÈùûÈáçÁΩÆÈÅéÊ∏°ÊúüÈñìÊâçÊõ¥Êñ∞Ôºâ
                if (!this.isResetting) {
                    this.currentOffsetX = this.smoothedDelta.x;
                    this.currentOffsetY = this.smoothedDelta.y;
                }
            }

            // üéÆ ÂæûÊåáÈáùÊõ¥Êñ∞ÊéßÂà∂ÂÄº
            updateFromPointer(x, y) {
                // Ë®àÁÆóÊ®ôÊ∫ñÂåñÁöÑÂÅèÁßªÂÄº (-1 Âà∞ +1)
                const offsetX = (x / window.innerWidth) * 2 - 1;
                const offsetY = -(y / window.innerHeight) * 2 + 1; // ÂèçËΩâYËª∏
                
                // Êõ¥Êñ∞ÁõÆÊ®ôÊªëÈº†‰ΩçÁΩÆÔºàÁî®ÊñºÊèíÂÄºÔºâ
                this.targetMouse.x = offsetX;
                this.targetMouse.y = offsetY;
                
                // Ë®àÁÆóÊªëÈº†ÁßªÂãïÈÄüÂ∫¶ÔºàÁî®ÊñºÊÖ£ÊÄßÊïàÊûúÔºâ
                if (!this.isMobile) {
                    this.mouseVelocity.x = offsetX - this.mouse.x;
                    this.mouseVelocity.y = offsetY - this.mouse.y;
                }
                
                // Êõ¥Êñ∞ÊªëÈº†‰ΩçÁΩÆÔºàÁî®ÊñºÈÄüÂ∫¶Ë®àÁÆóÔºâ
                this.mouse.x = offsetX;
                this.mouse.y = offsetY;
                
                // Êõ¥Êñ∞Áµ±‰∏ÄËº∏Âá∫ÂÄº
                this.currentOffsetX = offsetX;
                this.currentOffsetY = offsetY;
                
                // Êõ¥Êñ∞ÊúÄÂæåÊåáÈáùÊôÇÈñì
                this.lastPointerTime = Date.now();
            }

            // üéÆ Ë®ªÂÜäÈôÄËû∫ÂÑÄ‰∫ã‰ª∂ÔºàÂ∏∏ÈßêÔºâ
            registerGyroEvents() {
                if (!this.gyroActive) return;
                
                this.gyroHandler = (event) => {
                    // ‰øùÁïô deviceorientation ‰∫ã‰ª∂„ÄåÂ∏∏Èßê„ÄçÔºõPointer Ê®°ÂºèÂÉÖÂøΩÁï•ÂÖ∂Ëº∏Âá∫Ôºå‰∏çÂÅúÊ≠¢‰∫ã‰ª∂
                    if (this.currentControlMode === 'gyro') {
                        this.updateFromGyro(event.alpha || 0, event.beta || 0, event.gamma || 0);
                    }
                };
                
                window.addEventListener('deviceorientation', this.gyroHandler);
            }

            // üéÆ ÁßªÈô§ÈôÄËû∫ÂÑÄ‰∫ã‰ª∂
            removeGyroEvents() {
                if (this.gyroHandler) {
                    window.removeEventListener('deviceorientation', this.gyroHandler);
                    this.gyroHandler = null;
                }
            }

            // üéÆ Ê™¢Êü•ÊéßÂà∂Ê®°ÂºèÂàáÊèõ
            checkControlModeSwitch() {
                const now = Date.now();
                
                // Â¶ÇÊûúÊòØÊåáÈáùÊ®°Âºè‰∏îË∂ÖÈÅéË∂ÖÊôÇÊôÇÈñìÔºåÂàáÊèõÂõûÈôÄËû∫ÂÑÄ
                // Âè™Âú®Ë°åÂãïÁâà‰∏îÊúâÈôÄËû∫ÂÑÄÊ¨äÈôêÊôÇÊâçÂàáÊèõ
                if (this.currentControlMode === 'pointer' && 
                    this.isMobile &&
                    (now - this.lastPointerTime) > this.POINTER_TIMEOUT &&
                    this.gyroPermissionGranted) {
                    
                    this.currentControlMode = 'gyro';
                    console.log('üéÆ Ëá™ÂãïÂàáÊèõÂà∞ÈôÄËû∫ÂÑÄÊéßÂà∂Ê®°Âºè');
                }
            }

            // üéÆ È°ØÁ§∫ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï
            showResetGyroButton() {
                const resetButton = document.getElementById('reset-gyro-button');
                if (resetButton && this.isMobile && this.gyroPermissionGranted) {
                    resetButton.style.display = 'flex';
                    console.log('üéÆ È°ØÁ§∫ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï');
                }
            }

            // üéÆ Èö±ËóèÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï
            hideResetGyroButton() {
                const resetButton = document.getElementById('reset-gyro-button');
                if (resetButton) {
                    resetButton.style.display = 'none';
                    console.log('üéÆ Èö±ËóèÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï');
                }
            }

            // Áµ±‰∏ÄÁöÑÂúñÁâáÂ∞∫ÂØ∏Ë®àÁÆóÂáΩÊï∏
            calculateImageSize(texture = null) {
                // Â¶ÇÊûúÊúâÂÇ≥ÂÖ• textureÔºå‰ΩøÁî®ÂÖ∂ÂéüÂßãÊØî‰æãÔºõÂê¶Ââá‰ΩøÁî®È†êË®≠ÊØî‰æã
                let aspectRatio;
                if (texture && texture.image) {
                    aspectRatio = texture.image.width / texture.image.height;
                    console.log(`‰ΩøÁî®ÂúñÁâáÂéüÂßãÊØî‰æã: ${texture.image.width}x${texture.image.height} (ÊØî‰æã: ${aspectRatio.toFixed(3)})`);
                } else {
                    aspectRatio = 1920 / 1080; // Êñ∞ÁöÑÈ†êË®≠ÊØî‰æã
                    console.log(`‰ΩøÁî®È†êË®≠ÊØî‰æã: 1920x1080 (ÊØî‰æã: ${aspectRatio.toFixed(3)})`);
                }
                
                const distance = 5;
                const fov = 75 * Math.PI / 180;
                const worldHeight = 2 * Math.tan(fov / 2) * distance;
                const worldWidth = worldHeight * (window.innerWidth / window.innerHeight);
                
                // Ë®àÁÆóË¶ñÁ™óÈï∑ÂØ¨ÊØî
                const windowAspectRatio = window.innerWidth / window.innerHeight;
                
                let width, height;
                
                // Ëá™ÂãïÊØîËºÉË¶ñÁ™óÈï∑ÂØ¨ÊØîËàáÂúñÁâáÈï∑ÂØ¨ÊØîÔºåÊ±∫ÂÆö‰ª•ÂØ¨Â∫¶ÊàñÈ´òÂ∫¶ÁÇ∫‰∏ª
                if (windowAspectRatio >= aspectRatio) {
                    // Ë¶ñÁ™óÊØîÂúñÁâáÂØ¨ÔºàÊàñÁõ∏Á≠âÔºâÔºå‰ª•ÂØ¨Â∫¶ÁÇ∫‰∏ª
                    width = worldWidth * this.IMAGE_SCALE;
                    height = width / aspectRatio;
                } else {
                    // Ë¶ñÁ™óÊØîÂúñÁâáÁ™ÑÔºå‰ª•È´òÂ∫¶ÁÇ∫‰∏ª
                    height = worldHeight * this.IMAGE_SCALE;
                    width = height * aspectRatio;
                }
                
                return { width, height };
            }

            setupLoadingScene() {
                // Âª∫Á´ãËºâÂÖ•Â†¥ÊôØ
                this.loadingScene = new THREE.Scene();
                
                // Âª∫Á´ãËºâÂÖ•Áõ∏Ê©ü
                this.loadingCamera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.loadingCamera.position.z = 5;
                
                // Âª∫Á´ãËºâÂÖ•Ê∏≤ÊüìÂô®
                this.loadingRenderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('loading-canvas'),
                    antialias: true,
                    alpha: true
                });
                this.loadingRenderer.setSize(window.innerWidth, window.innerHeight);
                this.loadingRenderer.setClearColor(0x000000, 1);
            }

            loadLoadingCover() {
                console.log('ÈñãÂßãËºâÂÖ•Â∞ÅÈù¢ÂúñÁâá...');
                const loader = new THREE.TextureLoader();
                loader.load(
                    'images/Loading.png',
                    (texture) => {
                        console.log('Â∞ÅÈù¢ÂúñÁâáËºâÂÖ•ÊàêÂäüÔºåÈñãÂßãÊ∑°ÂÖ•ÂãïÁï´');
                        this.createLoadingMesh(texture);
                        this.loadingCoverLoaded = true;
                        
                        // Â∞ÅÈù¢ÂúñËºâÂÖ•ÂÆåÊàêÂæåÊâçÈñãÂßãÊ∑°ÂÖ•ÂãïÁï´
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            // Ê∑°ÂÖ•ÂãïÁï´ÂÆåÊàêÂæåÈñãÂßãËºâÂÖ•ÂÖ∂‰ªñÂúñÁâá
                            setTimeout(() => {
                                console.log('Â∞ÅÈù¢ÂúñÊ∑°ÂÖ•ÂÆåÊàêÔºåÈñãÂßãËºâÂÖ•ÂÖ∂‰ªñÂúñÁâá');
                                this.loadLayers();
                            }, 500); // Á≠âÂæÖ0.5ÁßíÊ∑°ÂÖ•ÂÆåÊàê
                        }, 50); // Áü≠Êö´Âª∂ÈÅ≤Á¢∫‰øùÊ∏≤ÊüìÂÆåÊàê
                    },
                    undefined,
                    (error) => {
                        console.warn('Â∞ÅÈù¢ÂúñÁâáËºâÂÖ•Â§±ÊïóÔºå‰ΩøÁî®ÈªëËâ≤ËÉåÊôØ‰∏¶ÈñãÂßãËºâÂÖ•ÂÖ∂‰ªñÂúñÁâá');
                        this.loadingCoverLoaded = true;
                        
                        // Âç≥‰ΩøËºâÂÖ•Â§±Êïó‰πüË¶ÅÈñãÂßãÊ∑°ÂÖ•ÂíåËºâÂÖ•ÂÖ∂‰ªñÂúñÁâá
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            setTimeout(() => {
                                this.loadLayers();
                            }, 500);
                        }, 50);
                    }
                );
            }

            createLoadingMesh(texture) {
                // ‰ΩøÁî®Áµ±‰∏ÄÁöÑÂ∞∫ÂØ∏Ë®àÁÆóÂáΩÊï∏ÔºåÂÇ≥ÂÖ• texture ‰ª•Áç≤ÂèñÂéüÂßãÊØî‰æã
                const { width, height } = this.calculateImageSize(texture);

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                // Â≠òÂÑ≤ texture ÂºïÁî®‰ª•‰æø resize ÊôÇÈáçÊñ∞Ë®àÁÆó
                mesh.userData.texture = texture;
                this.loadingScene.add(mesh);
            }

            init() {
                this.setupLoadingScene();
                this.setupScene();
                this.setupEventListeners();
                this.createLoadingParticles(); // ÂâµÂª∫ËºâÂÖ•Á≤íÂ≠êÊïàÊûú
                this.randomizeSpinnerRings(); // Ë®≠ÂÆöÈö®Ê©üÊóãËΩâÊïàÊûú
                
                // üé≠ Ë®≠ÂÆöÂ±§Á¥öÂºïÁî®
                this.loadingLayer = this.loadingScene; // ËºâÂÖ•Â±§ÔºöThree.js Â†¥ÊôØ
                this.uiLayer = document.getElementById('back-button'); // UIÂ±§ÔºöDOM ÂÖÉÁ¥†
                
                this.loadLoadingCover(); // ÂÑ™ÂÖàËºâÂÖ•Â∞ÅÈù¢Âúñ
                this.animate();
            }

            createLoadingParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;

                // ÂÆöÁæ©ËºâÂÖ•ÂãïÁï´ÁöÑÈ°èËâ≤Ë™øËâ≤Êùø
                const colorPalette = [
                    {
                        bg: '#dc9c3b',
                        rgba: '220, 156, 59'
                    },
                    {
                        bg: '#d1936b', 
                        rgba: '209, 147, 107'
                    },
                    {
                        bg: '#f4e3d4',
                        rgba: '244, 227, 212'
                    }
                ];

                // ÂâµÂª∫ 10 ÂÄãÁ≤íÂ≠ê
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // Èö®Ê©üÈÅ∏ÊìáÈ°èËâ≤
                    const colorIndex = Math.floor(Math.random() * colorPalette.length);
                    const selectedColor = colorPalette[colorIndex];
                    
                    // Èö®Ê©üÂ§ßÂ∞è (1-2px)
                    const size = Math.random() * 1.6 + 0.8;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // Ë®≠ÂÆöËÉåÊôØÈ°èËâ≤
                    particle.style.background = selectedColor.bg;
                    
                    // Ë®≠ÂÆöÂü∫Á§éÁôºÂÖâÊïàÊûú
                    particle.style.boxShadow = `
                        0 0 6px rgba(${selectedColor.rgba}, 0.8),
                        0 0 12px rgba(${selectedColor.rgba}, 0.6),
                        0 0 18px rgba(${selectedColor.rgba}, 0.4),
                        0 0 24px rgba(${selectedColor.rgba}, 0.2)
                    `;
                    
                    // Èö®Ê©üÊ∞¥Âπ≥‰ΩçÁΩÆ (10%-90%)ÔºåÈÅøÂÖçË≤ºÈÇä
                    particle.style.left = (Math.random() * 80 + 10) + '%';
                    
                    // Èö®Ê©üÈ£ÑÊµÆÂãïÁï´Âª∂ÈÅ≤ÂíåÊåÅÁ∫åÊôÇÈñì
                    const floatDelay = Math.random() * 1.5;
                    const floatDuration = Math.random() * 3 + 2.5;
                    
                    // Èö®Ê©üÁôºÂÖâÂãïÁï´Âª∂ÈÅ≤
                    const glowDelay = Math.random() * 0.5;
                    
                    // ÂâµÂª∫ÂîØ‰∏ÄÁöÑÁôºÂÖâÂãïÁï´ÂêçÁ®±
                    const glowAnimationName = `particleGlow${i}`;
                    
                    // ÂãïÊÖãÂâµÂª∫ÁôºÂÖâÂãïÁï´ÁöÑCSSË¶èÂâá
                    const glowKeyframes = `
                        @keyframes ${glowAnimationName} {
                            0% {
                                box-shadow: 
                                    0 0 6px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 12px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 18px rgba(${selectedColor.rgba}, 0.4),
                                    0 0 24px rgba(${selectedColor.rgba}, 0.2);
                                filter: brightness(1.2);
                            }
                            100% {
                                box-shadow: 
                                    0 0 10px rgba(${selectedColor.rgba}, 1),
                                    0 0 20px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 30px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 40px rgba(${selectedColor.rgba}, 0.3);
                                filter: brightness(1.5);
                            }
                        }
                    `;
                    
                    // Â∞áÂãïÁï´Ë¶èÂâáÊ∑ªÂä†Âà∞È†ÅÈù¢
                    const style = document.createElement('style');
                    style.textContent = glowKeyframes;
                    document.head.appendChild(style);
                    
                    // Ë®≠ÂÆöË§áÂêàÂãïÁï´ÔºöÈ£ÑÊµÆ + ÂÄãÂà•ÁôºÂÖâ
                    particle.style.animation = `
                        particleFloat ${floatDuration}s linear infinite ${floatDelay}s,
                        ${glowAnimationName} 2s ease-in-out infinite alternate ${glowDelay}s
                    `;
                    
                    particlesContainer.appendChild(particle);
                }
            }

            randomizeSpinnerRings() {
                const spinnerRings = document.querySelectorAll('.spinner-ring');
                
                spinnerRings.forEach((ring, index) => {
                    // Èö®Ê©üÊóãËΩâÈÄüÂ∫¶ (1.5s - 4s)
                    const duration = Math.random() * 2 + 1.5;
                    
                    // Èö®Ê©üËµ∑ÂßãËßíÂ∫¶ (0¬∞ - 360¬∞)
                    const startAngle = Math.random() * 360;
                    
                    // Èö®Ê©üÊñπÂêë (È†ÜÊôÇÈáùÊàñÈÄÜÊôÇÈáù)
                    const direction = Math.random() > 0.5 ? 'normal' : 'reverse';
                    
                    // ÂâµÂª∫ÂîØ‰∏ÄÁöÑÊóãËΩâÂãïÁï´ÂêçÁ®±
                    const spinAnimationName = `spinnerSpin${index}`;
                    
                    // ÂãïÊÖãÂâµÂª∫ÊóãËΩâÂãïÁï´ÁöÑCSSË¶èÂâá
                    const spinKeyframes = `
                        @keyframes ${spinAnimationName} {
                            0% { transform: rotate(${startAngle}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                            100% { transform: rotate(${startAngle + 360}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                        }
                    `;
                    
                    // Â∞áÂãïÁï´Ë¶èÂâáÊ∑ªÂä†Âà∞È†ÅÈù¢
                    const style = document.createElement('style');
                    style.textContent = spinKeyframes;
                    document.head.appendChild(style);
                    
                    // Ë®≠ÂÆöÂãïÁï´
                    ring.style.animation = `${spinAnimationName} ${duration}s linear infinite`;
                    ring.style.animationDirection = direction;
                });
            }

            // Êõ¥Êñ∞ÊâÄÊúâÂúñÂ±§ÁöÑÂ∞∫ÂØ∏
            updateAllLayerSizes() {
                // Êõ¥Êñ∞ËºâÂÖ•Â†¥ÊôØ‰∏≠ÁöÑÁ∂≤Ê†º
                if (this.loadingScene) {
                    this.loadingScene.children.forEach(mesh => {
                        if (mesh.userData.texture) {
                            const { width, height } = this.calculateImageSize(mesh.userData.texture);
                            mesh.geometry.dispose(); // ÈáãÊîæËàäÁöÑÂπæ‰ΩïÈ´î
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        }
                    });
                }

                // Êõ¥Êñ∞‰∏ªÂ†¥ÊôØ‰∏≠ÁöÑÂúñÂ±§
                this.layers.forEach(layerGroup => {
                    if (layerGroup.userData.mainTexture) {
                        const { width, height } = this.calculateImageSize(layerGroup.userData.mainTexture);
                        
                        layerGroup.children.forEach(mesh => {
                            mesh.geometry.dispose(); // ÈáãÊîæËàäÁöÑÂπæ‰ΩïÈ´î
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        });
                    }
                });

                // üî¥ Êõ¥Êñ∞‰∫íÂãïÈªûÈªûÁöÑ‰ΩçÁΩÆÂíåÁ∏ÆÊîæ
                this.updateInteractiveDotsLayout();
                
                // üîç Êõ¥Êñ∞Â±ÄÈÉ®ÂúñÂ±§ÁöÑ‰ΩçÁΩÆÂíåÁ∏ÆÊîæ
                this.updateDetailLayersLayout();
            }

            setupScene() {
                // Âª∫Á´ãÂ†¥ÊôØ
                this.scene = new THREE.Scene();
                
                // Âª∫Á´ãÁõ∏Ê©ü
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 5;
                
                // Âª∫Á´ãÊ∏≤ÊüìÂô®
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 1);
                
                // ÂïüÁî®Ê∑±Â∫¶Ê∏¨Ë©¶‰ª•Á¢∫‰øùÊ≠£Á¢∫ÁöÑÂúñÂ±§È†ÜÂ∫è
                this.renderer.sortObjects = true;
                
                // üé≠ ÂâµÂª∫‰∏ªË¶ÅÂúñÂ±§ÁµÑÂÆπÂô® (7_BG~1_RabbitFornt)
                this.mainLayerGroup = new THREE.Group();
                this.mainLayerGroup.name = 'MainContentLayers';
                this.scene.add(this.mainLayerGroup);
                
                // üî¥ ÂâµÂª∫‰∫íÂãïÈªûÈªûÂÆπÂô®
                this.dotsGroup = new THREE.Group();
                this.dotsGroup.name = 'InteractiveDots';
                this.scene.add(this.dotsGroup);
                
                // üîç ÂâµÂª∫Â±ÄÈÉ®ÂúñÂÆπÂô®
                this.detailGroup1 = new THREE.Group();
                this.detailGroup1.name = 'DetailLayer1';
                this.detailGroup1.renderOrder = 0.08;
                this.scene.add(this.detailGroup1);
                
                this.detailGroup2 = new THREE.Group();
                this.detailGroup2.name = 'DetailLayer2';
                this.detailGroup2.renderOrder = 0.07;
                this.scene.add(this.detailGroup2);
                
                this.detailGroup3 = new THREE.Group();
                this.detailGroup3.name = 'DetailLayer3';
                this.detailGroup3.renderOrder = 0.06;
                this.scene.add(this.detailGroup3);
                
                // Ë®≠ÂÆöÂúñÂ±§ÁµÑÂºïÁî®
                this.contentLayer = this.mainLayerGroup;
                console.log('‚úÖ Â§öÂ±§Á¥öÊû∂ÊßãÂàùÂßãÂåñÂÆåÊàê');
                console.log('üì± UIÂ±§: z-index 3000+ (ËøîÂõûÊåâÈàïÁ≠â)');
                console.log('üé¨ ËºâÂÖ•Â±§: z-index 2000+ (Â∞ÅÈù¢ÂúñËàáËºâÂÖ•ÂãïÁï´)');
                console.log('üñºÔ∏è ÂÖßÂÆπÂ±§: z-index 1000+ (‰∏ªË¶ÅÂúñÂ±§ÁµÑ)');
                console.log('üî¥ ‰∫íÂãïÈªûÈªû: renderOrder 1 (ÊúÄ‰∏äÂ±§)');
                console.log('üîç Â±ÄÈÉ®ÂúñÂ±§: zËª∏ 0.06~0.08 (dot1:0.06, dot2:0.07, dot3:0.08), depthWrite:false');
                console.log('üñºÔ∏è ‰∏ªË¶ÅÂúñÂ±§: renderOrder 0 (ÊúÄ‰∏ãÂ±§)');
            }

            setupEventListeners() {
                // üéÆ ================== Ê∑∑ÂêàÊéßÂà∂‰∫ã‰ª∂Áõ£ËÅΩÂô® ==================
                
                // üéõÔ∏è Ëû¢ÂπïÊñπÂêëËÆäÂåñÁõ£ËÅΩ
                const handleOrientationChange = () => {
                    const newOrientation = this.getScreenOrientation();
                    if (newOrientation !== this.currentOrientation) {
                        console.log(`üîÑ Ëû¢ÂπïÊñπÂêëËÆäÂåñ: ${this.currentOrientation} ‚Üí ${newOrientation}`);
                        this.currentOrientation = newOrientation;
                        // ÈáçË®≠Âü∫Ê∫ñÂÄºÔºåÈÅøÂÖçÁøªËΩâÊôÇË∑≥Âãï
                        this.baseX = null;
                        this.baseY = null;
                        this.smoothedDelta = { x: 0, y: 0 };
                    }
                };

                // Áõ£ËÅΩÊñπÂêëËÆäÂåñ‰∫ã‰ª∂
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', handleOrientationChange);
                } else {
                    window.addEventListener('orientationchange', handleOrientationChange);
                }

                // üéÆ ÊåáÈáù‰∫ã‰ª∂ËôïÁêÜÔºàÊªëÈº†„ÄÅËß∏Êéß„ÄÅÊªæËº™Ôºâ
                const handlePointerEvent = (event) => {
                    // Âè™Âú®ÂÅµÊ∏¨Âà∞„ÄåÁúüÂØ¶ÊªëÈº†„Äç‰∫ã‰ª∂ÊôÇÊâçÂïüÁî® Pointer Ê®°Âºè
                    // Ê°åÈù¢ÁâàÊªëÈº†‰∫ã‰ª∂Ê≤íÊúâ pointerTypeÔºåË°åÂãïÁâàÈúÄË¶ÅÊ™¢Êü•
                    if (this.isMobile && event.pointerType && event.pointerType !== 'mouse') return; // ÂøΩÁï• touch / pen
                    
                    // ÂïüÂãïÊåáÈáùÊéßÂà∂Ê®°Âºè
                    this.startPointerControl();
                    
                    // Êõ¥Êñ∞ÊéßÂà∂ÂÄº
                    if (event.type === 'wheel') {
                        // ÊªæËº™‰∫ã‰ª∂Ôºö‰ΩøÁî®ÊªëÈº†Áï∂Ââç‰ΩçÁΩÆ
                        this.updateFromPointer(this.mouse.x, this.mouse.y);
                    } else {
                        // ÊªëÈº†‰∫ã‰ª∂Ôºö‰ΩøÁî®‰∫ã‰ª∂‰ΩçÁΩÆ
                        const x = event.clientX || 0;
                        const y = event.clientY || 0;
                        this.updateFromPointer(x, y);
                    }
                    
                    // üïπÔ∏è Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂ - Âè™Âú®Â±ÄÈÉ®Ë¶ñËßíÁîüÊïà
                    if (this.viewState === 'detail' && !this.isTransitioning) {
                        this.updateDetailViewControl(this.currentOffsetX, this.currentOffsetY);
                    }
                };

                // üéÆ Ëß∏Êéß‰∫ã‰ª∂ËôïÁêÜÔºàÂÉÖÁî®Êñº‰∫íÂãïÔºå‰∏çÂàáÊèõÊéßÂà∂Ê®°ÂºèÔºâ
                const handleTouchEvent = (event) => {
                    // Ëß∏Êéß‰∫ã‰ª∂‰∏çÂàáÊèõÊéßÂà∂Ê®°ÂºèÔºå‰øùÊåÅÁï∂ÂâçÊ®°Âºè
                    const x = event.touches?.[0]?.clientX || 0;
                    const y = event.touches?.[0]?.clientY || 0;
                    
                    // Â¶ÇÊûúÁï∂ÂâçÊòØÊåáÈáùÊ®°ÂºèÔºåÊõ¥Êñ∞ÊéßÂà∂ÂÄº
                    if (this.currentControlMode === 'pointer') {
                        this.updateFromPointer(x, y);
                    }
                    
                    // üïπÔ∏è Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂ - Âè™Âú®Â±ÄÈÉ®Ë¶ñËßíÁîüÊïà
                    if (this.viewState === 'detail' && !this.isTransitioning) {
                        this.updateDetailViewControl(this.currentOffsetX, this.currentOffsetY);
                    }
                };

                // Ë®ªÂÜäÊåáÈáù‰∫ã‰ª∂ÔºàÂÉÖÊªëÈº†Ôºâ
                document.addEventListener('mousemove', handlePointerEvent);
                document.addEventListener('wheel', handlePointerEvent, { passive: true });

                // Ë®ªÂÜäËß∏Êéß‰∫ã‰ª∂ÔºàÂÉÖÁî®Êñº‰∫íÂãïÔºâ
                document.addEventListener('touchmove', handleTouchEvent, { passive: true });

                // üéÆ Ê°åÈù¢ÁâàÂ∞àÁî®‰∫ã‰ª∂ÔºàÊÖ£ÊÄßÊïàÊûúÁ≠âÔºâ
                if (!this.isMobile) {
                    // ÊªëÈº†Èõ¢ÈñãÈ†ÅÈù¢‰∫ã‰ª∂
                    document.addEventListener('mouseleave', () => {
                        this.mouseInsidePage = false;
                        this.mouseJustReentered = false;
                        
                        // ÂïüÂãïÊÖ£ÊÄßÁ∑©Ë°ùÊïàÊûú
                        const inertiaMultiplier = 1.5;
                        this.inertiaTarget.x = this.currentMouse.x + this.mouseVelocity.x * inertiaMultiplier;
                        this.inertiaTarget.y = this.currentMouse.y + this.mouseVelocity.y * inertiaMultiplier;
                        this.isInertiaActive = true;
                        
                        console.log('ÊªëÈº†Èõ¢ÈñãÈ†ÅÈù¢ÔºåÂïüÂãïÊÖ£ÊÄßÁ∑©Ë°ùÊïàÊûú');
                    });
                    
                    // ÊªëÈº†ÈÄ≤ÂÖ•È†ÅÈù¢‰∫ã‰ª∂
                    document.addEventListener('mouseenter', () => {
                        if (!this.mouseInsidePage) {
                            this.mouseInsidePage = true;
                            this.mouseJustReentered = true;
                            console.log('ÊªëÈº†ÈáçÊñ∞ÈÄ≤ÂÖ•È†ÅÈù¢ÔºåÈñãÂßãÂπ≥ÊªëÈÅéÊ∏°Âà∞Êñ∞‰ΩçÁΩÆ');
                        }
                    });
                }

                // üéÆ Á¨¨‰∏ÄÊ¨°‰ΩøÁî®ËÄÖ‰∫íÂãïÊôÇÂòóË©¶ÂïüÁî®ÈôÄËû∫ÂÑÄ
                const handleFirstInteraction = async () => {
                    if (this.currentControlMode === 'none') {
                        if (this.isMobile) {
                            console.log('üéÆ Ê™¢Ê∏¨Âà∞Á¨¨‰∏ÄÊ¨°‰ΩøÁî®ËÄÖ‰∫íÂãïÔºåÂòóË©¶ÂïüÁî®ÈôÄËû∫ÂÑÄ');
                            
                            const gyroSuccess = await this.startGyroControl();
                            if (gyroSuccess) {
                                this.currentControlMode = 'gyro';
                            } else {
                                this.currentControlMode = 'pointer';
                            }
                        } else {
                            // Ê°åÈù¢ÁâàÁõ¥Êé•Ë®≠ÂÆöÁÇ∫ÊåáÈáùÊéßÂà∂Ê®°Âºè
                            console.log('üéÆ Ê°åÈù¢ÁâàÔºåË®≠ÂÆöÁÇ∫ÊåáÈáùÊéßÂà∂Ê®°Âºè');
                            this.currentControlMode = 'pointer';
                        }
                    }
                    
                    // ÁßªÈô§‰∏ÄÊ¨°ÊÄß‰∫ã‰ª∂Áõ£ËÅΩÂô®
                    document.removeEventListener('mousedown', handleFirstInteraction);
                    document.removeEventListener('touchstart', handleFirstInteraction);
                };

                // Ë®ªÂÜäÁ¨¨‰∏ÄÊ¨°‰∫íÂãï‰∫ã‰ª∂
                document.addEventListener('mousedown', handleFirstInteraction);
                document.addEventListener('touchstart', handleFirstInteraction);

                // üéÆ ÊªëÈº†‰∫ã‰ª∂Áõ£ËÅΩÔºàÁî®ÊñºËá™ÂãïÂàáÊèõÂà∞ Pointer Ê®°ÂºèÔºâ
                const mouseEvents = ['mousedown', 'mousemove', 'wheel'];
                mouseEvents.forEach(eventType => {
                    document.addEventListener(eventType, (event) => {
                        // Âè™Âú®ÂÅµÊ∏¨Âà∞„ÄåÁúüÂØ¶ÊªëÈº†„Äç‰∫ã‰ª∂ÊôÇÊâçÂàáÊèõ
                        // Ê°åÈù¢ÁâàÊªëÈº†‰∫ã‰ª∂Ê≤íÊúâ pointerTypeÔºåË°åÂãïÁâàÈúÄË¶ÅÊ™¢Êü•
                        if (this.isMobile && event.pointerType && event.pointerType !== 'mouse') return;
                        
                        // Ë®òÈåÑÊúÄÂæåÊªëÈº†‰∫íÂãïÊôÇÈñì
                        this.lastPointerTime = Date.now();
                        
                        // Â¶ÇÊûúÁï∂ÂâçÊòØÈôÄËû∫ÂÑÄÊ®°ÂºèÔºåÂàáÊèõÂà∞ÊåáÈáùÊ®°Âºè
                        if (this.currentControlMode === 'gyro') {
                            this.currentControlMode = 'pointer';
                            console.log('üéÆ Ê™¢Ê∏¨Âà∞ÊªëÈº†‰∫íÂãïÔºåÂàáÊèõÂà∞ÊåáÈáùÊéßÂà∂Ê®°Âºè');
                        }
                    }, { passive: true });
                });

                // Ë¶ñÁ™óÂ§ßÂ∞èË™øÊï¥
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    // ÂêåÊôÇË™øÊï¥ËºâÂÖ•Â†¥ÊôØ
                    if (this.loadingCamera && this.loadingRenderer) {
                        this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                        this.loadingCamera.updateProjectionMatrix();
                        this.loadingRenderer.setSize(window.innerWidth, window.innerHeight);
                    }

                    // Ëá™ÂãïÈáçÊñ∞Ë®àÁÆó‰∏¶Ë™øÊï¥ÊâÄÊúâÂúñÂ±§ÁöÑ PlaneGeometry
                    this.updateAllLayerSizes();
                });
            }

            loadLayers() {
                // Âè™Ë®àÁÆó‰∏ªÂúñÔºåÂõ†ÁÇ∫Ê∑±Â∫¶ÂúñÂíåÁôºÂÖâÂúñÂèØËÉΩ‰∏çÂ≠òÂú®ÔºàÂ∞ÅÈù¢Âúñ‰∏çË®àÂÖ•Ôºâ
                this.totalImages = this.layerInfo.length;
                console.log(`ÈñãÂßãËºâÂÖ• ${this.totalImages} Âºµ‰∏ªË¶ÅÂúñÁâá`);
                
                this.layerInfo.forEach((layerData, index) => {
                    this.loadLayer(layerData, index);
                });
            }

            loadLayer(layerData, index) {
                const loader = new THREE.TextureLoader();
                const layerGroup = new THREE.Group();
                
                // ËºâÂÖ•‰∏ªÂúñ
                console.log(`Ê≠£Âú®ËºâÂÖ•: ${layerData.name}.png`);
                loader.load(
                    `images/${layerData.name}.png`,
                    (mainTexture) => {
                        console.log(`ÊàêÂäüËºâÂÖ•‰∏ªÂúñ: ${layerData.name}.png`);
                        // ËºâÂÖ•Ê∑±Â∫¶Âúñ
                        loader.load(
                            `images/${layerData.name}_depth.png`,
                            (depthTexture) => {
                                // ËºâÂÖ•ÁôºÂÖâÂúñ
                                loader.load(
                                    `images/${layerData.name}_glow.png`,
                                    (glowTexture) => {
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index);
                                        this.onImageLoaded();
                                    },
                                    undefined,
                                    () => {
                                        // ÁôºÂÖâÂúñËºâÂÖ•Â§±ÊïóÔºåÂè™‰ΩøÁî®‰∏ªÂúñÂíåÊ∑±Â∫¶Âúñ
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, null, layerData, index);
                                        this.onImageLoaded();
                                    }
                                );
                            },
                            undefined,
                            (error) => {
                                console.warn(`Ê∑±Â∫¶ÂúñËºâÂÖ•Â§±Êïó: ${layerData.name}_depth.png`);
                                this.createLayerMesh(layerGroup, mainTexture, null, null, layerData, index);
                                this.onImageLoaded();
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`‰∏ªÂúñËºâÂÖ•Â§±Êïó: ${layerData.name}.png`, error);
                        this.onImageLoaded(); // ‰øÆÊ≠£ÔºöËºâÂÖ•Â§±Êïó‰πüË¶ÅË®àÊï∏
                    }
                );
            }

            createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index) {
                // ‰ΩøÁî®Áµ±‰∏ÄÁöÑÂ∞∫ÂØ∏Ë®àÁÆóÂáΩÊï∏ÔºåÂÇ≥ÂÖ• mainTexture ‰ª•Áç≤ÂèñÂéüÂßãÊØî‰æã
                const { width, height } = this.calculateImageSize(mainTexture);

                // Â¶ÇÊûúÊúâÊ∑±Â∫¶ÂúñÔºå‰ΩøÁî®Ëá™ÂÆöÁæ© Shader ‰æÜÂØ¶ÁèæÂü∫ÊñºÊ∑±Â∫¶ÂúñÁöÑË¶ñÂ∑Æ
                if (depthTexture) {
                    const vertexShader = `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;
                    
                    const fragmentShader = `
                        uniform sampler2D mainTexture;
                        uniform sampler2D depthTexture;
                        uniform vec2 parallaxOffset;
                        uniform float parallaxStrength;
                        varying vec2 vUv;
                        
                        void main() {
                            // ËÆÄÂèñÊ∑±Â∫¶ÂúñÁöÑÁÅ∞ÈöéÂÄº
                            float depth = texture2D(depthTexture, vUv).r;
                            
                            // Ê†πÊìöÊ∑±Â∫¶ÂÄºË®àÁÆóË¶ñÂ∑ÆÂÅèÁßª - ‰øÆÊ≠£Ë®àÁÆóÊñπÂºè
                            vec2 offset = parallaxOffset * (depth - 0.625) * parallaxStrength;
                            vec2 parallaxUV = vUv + offset;
                            
                            // Ê™¢Êü•ÊòØÂê¶Ë∂ÖÂá∫ÈÇäÁïå
                            if (parallaxUV.x < 0.0 || parallaxUV.x > 1.0 || parallaxUV.y < 0.0 || parallaxUV.y > 1.0) {
                                // Ë∂ÖÂá∫ÈÇäÁïåÊôÇÔºå‰ΩøÁî®ÂéüÂßãUVÂèñÊ®£
                                parallaxUV = vUv;
                            }
                            
                            // ÂèñÊ®£‰∏ªÁ¥ãÁêÜ
                            vec4 color = texture2D(mainTexture, parallaxUV);
                            gl_FragColor = color;
                        }
                    `;

                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                    // Âª∫Á´ãÁôºÂÖâÂúñÂ±§ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ- ÂøÖÈ†àÂú®‰∏ªÂúñÂ±§‰πãÂâçÂä†ÂÖ•
                    if (glowTexture) {
                        console.log(`ËºâÂÖ•ÁôºÂÖâÂúñÂ±§: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                mainTexture: { value: glowTexture },
                                depthTexture: { value: depthTexture },
                                parallaxOffset: { value: new THREE.Vector2(0, 0) },
                                parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                            },
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // ÈáçË¶ÅÔºöÈÅøÂÖçÊ∑±Â∫¶Ë°ùÁ™Å
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // Á®çÂæÆÂæÄÂæåÊîæÔºåÂú®‰∏ªÂúñ‰∏ãÂ±§
                        layerGroup.add(glowMesh);
                    }

                    // Âª∫Á´ã‰∏ªÂúñÂ±§
                    const mainMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            mainTexture: { value: mainTexture },
                            depthTexture: { value: depthTexture },
                            parallaxOffset: { value: new THREE.Vector2(0, 0) },
                            parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                } else {
                    // Ê≤íÊúâÊ∑±Â∫¶ÂúñÔºå‰ΩøÁî®Âü∫Êú¨ÊùêË≥™
                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                                                                if (glowTexture) {
                        console.log(`ËºâÂÖ•ÁôºÂÖâÂúñÂ±§ÔºàÁÑ°Ê∑±Â∫¶ÂúñÔºâ: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            map: glowTexture,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // ÈÅøÂÖçÊ∑±Â∫¶Ë°ùÁ™Å
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // Âú®‰∏ªÂúñ‰∏ãÂ±§
                        layerGroup.add(glowMesh);
                    }

                    const mainMaterial = new THREE.MeshBasicMaterial({
                        map: mainTexture,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                }

                // Ê†πÊìöÂúñÂ±§Á∑®ËôüË®≠ÂÆöZ‰ΩçÁΩÆ - Á∑®ËôüË∂äÂ∞èË∂äÂú®ÂâçÈù¢
                const layerNumber = parseInt(layerData.name.split('_')[1]); // Âèñ Main_7_BG ‰∏≠ÁöÑ "7"
                layerGroup.position.z = (7 - layerNumber) * 0.01; // 1ËôüÊúÄÂâçÈù¢(z=0.06)Ôºå7ËôüÊúÄÂæåÈù¢(z=0)
                layerGroup.userData = {
                    depthTexture: depthTexture,
                    hasDepth: !!depthTexture,
                    mainTexture: mainTexture // Â≠òÂÑ≤‰∏ªÁ¥ãÁêÜÂºïÁî®‰ª•‰æø resize ÊôÇÈáçÊñ∞Ë®àÁÆó
                };

                this.layers.push(layerGroup);
                this.mainLayerGroup.add(layerGroup); // Ê∑ªÂä†Âà∞‰∏ªË¶ÅÂúñÂ±§ÁµÑÂÆπÂô®
            }

            onImageLoaded() {
                this.loadedImages++;
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // üå´Ô∏è Á¢∫‰øùÂàùÂßãÁãÄÊÖãÊ≤íÊúâÊ®°Á≥äÊïàÊûú
                    this.resetTransitionBlur();
                    
                    // üî¥ ËºâÂÖ•ÂÆåÊàêÂæåÂâµÂª∫‰∫íÂãïÈªûÈªû
                    this.createInteractiveDots();
                    
                    // üîç ËºâÂÖ•Â±ÄÈÉ®ÂúñÂ±§
                    this.loadDetailLayers();
                    
                    // ËºâÂÖ•ÂÆåÊàêÂæåÔºåÈñãÂßãÊ∑°Âá∫Â∞ÅÈù¢
                    setTimeout(() => {
                        this.startFadeOut();
                    }, 1000); // Âª∂ÈÅ≤1ÁßíÈñãÂßãÊ∑°Âá∫
                }
            }

            startFadeOut() {
                const cover = document.getElementById('loading-cover');
                console.log('ÈñãÂßãÂ∞ÅÈù¢Ê∑°Âá∫ÂãïÁï´');
                
                // ÁßªÈô§Ê∑°ÂÖ• class
                cover.classList.remove('fade-in');
                
                // ‰ΩøÁî®ÂÖ©Ê¨° requestAnimationFrame Á¢∫‰øùÊµÅÊö¢Ê∑°Âá∫
                requestAnimationFrame(() => {       // ËÆìÁ¨¨‰∏ÄÂπÄÂëàÁèæ opacity:1
                    requestAnimationFrame(() => {     // Á¨¨‰∫åÂπÄÂÜçÂä†ÂãïÁï´ class
                        cover.classList.add('fade-out');
                    });
                });
                
                // Áõ£ËÅΩÂãïÁï´ÁµêÊùü‰∫ã‰ª∂
                cover.addEventListener('animationend', () => {
                    cover.style.display = 'none';
                    this.coverFadeOutComplete = true;
                    console.log('Â∞ÅÈù¢Ê∑°Âá∫ÂÆåÊàê');
                }, { once: true });
                
                // Â∞ÅÈù¢ÈñãÂßãÊ∑°Âá∫Âæå0.5ÁßíÔºåÈñãÂßãËºâÂÖ•‰∏≠ÂãïÁï´Ê∑°Âá∫ÂíåË¶ñÂ∑ÆÈÅéÊ∏°
                setTimeout(() => {
                    console.log('ÈñãÂßãËºâÂÖ•‰∏≠Ê∑°Âá∫ÂíåË¶ñÂ∑ÆÈÅéÊ∏°ÂãïÁï´');
                    this.startLoadingFadeOutAndParallaxTransition();
                }, 100); // Â∞ÅÈù¢ÈñãÂßãÊ∑°Âá∫Âæå0.5ÁßíËß∏Áôº
                
                // üî¥ Â∞ÅÈù¢ÈñãÂßãÊ∑°Âá∫Âæå1ÁßíÔºå‰∫íÂãïÈªûÈªûÊ∑°ÂÖ•
                setTimeout(() => {
                    console.log('üî¥ ÈñãÂßã‰∫íÂãïÈªûÈªûÊ∑°ÂÖ•ÂãïÁï´');
                    this.fadeInInteractiveDots();
                }, 1000); // Â∞ÅÈù¢ÈñãÂßãÊ∑°Âá∫Âæå1ÁßíËß∏Áôº
            }

            onImageError() {
                this.errorCount++;
                this.loadedImages++;
                
                // Â¶ÇÊûúÈåØË™§Â§™Â§öÔºåÈ°ØÁ§∫ÈåØË™§Ë®äÊÅØ
                if (this.errorCount >= 3) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error-message').style.display = 'block';
                }
                
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // üå´Ô∏è Á¢∫‰øùÂàùÂßãÁãÄÊÖãÊ≤íÊúâÊ®°Á≥äÊïàÊûú
                    this.resetTransitionBlur();
                    
                    document.getElementById('loading').style.display = 'none';
                }
            }

            startLoadingFadeOutAndParallaxTransition() {
                // ÂàÜÂà•ËôïÁêÜËºâÂÖ•‰∏≠ÂãïÁï´Ê∑°Âá∫ÂíåË¶ñÂ∑ÆÈÅéÊ∏°
                const loadingFadeDuration = 1000; // ËºâÂÖ•‰∏≠Ê∑°Âá∫Ôºö1Áßí
                const parallaxTransitionDuration = 1500; // Ë¶ñÂ∑ÆÈÅéÊ∏°Ôºö1.5Áßí
                
                // ÈñãÂßãËºâÂÖ•‰∏≠ÂãïÁï´ÁöÑÊ∑°Âá∫
                const loadingElement = document.getElementById('loading');
                loadingElement.classList.add('fade-out');
                
                // 1ÁßíÂæåÂÆåÂÖ®Èö±ËóèËºâÂÖ•‰∏≠ÂÖÉÁ¥†Ôºå‰∏¶È°ØÁ§∫ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    
                    // üéÆ Âú®ËºâÂÖ•‰∏≠ÂãïÁï´Ê∑°Âá∫ÊôÇÈ°ØÁ§∫ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï
                    // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈ°ØÁ§∫ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï
                    if (this.isMobile && this.gyroPermissionGranted) {
                        // Â¶ÇÊûúÊúâÈôÄËû∫ÂÑÄÊ¨äÈôêÊåâÈàïÔºåÁ≠âÂæÖÂÆÉÊ∂àÂ§±ÂæåÂÜçÈ°ØÁ§∫ÈáçÁΩÆÊåâÈàï
                        const gyroButton = document.getElementById('gyro-permission-button');
                        if (gyroButton && gyroButton.style.display !== 'none') {
                            // Áõ£ËÅΩÈôÄËû∫ÂÑÄÊ¨äÈôêÊåâÈàïÁöÑÈö±Ëóè
                            const checkGyroButton = () => {
                                if (gyroButton.style.display === 'none') {
                                    this.showResetGyroButton();
                                } else {
                                    setTimeout(checkGyroButton, 100);
                                }
                            };
                            checkGyroButton();
                        } else {
                            // Ê≤íÊúâÈôÄËû∫ÂÑÄÊ¨äÈôêÊåâÈàïÔºåÁõ¥Êé•È°ØÁ§∫ÈáçÁΩÆÊåâÈàï
                            this.showResetGyroButton();
                        }
                    }
                }, loadingFadeDuration);
                
                // ÂêåÊôÇÈñãÂßãË¶ñÂ∑ÆÈÅéÊ∏°ÂãïÁï´Ôºà1.5ÁßíÔºâ
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / parallaxTransitionDuration, 1);
                    
                    // Ëá™ÂÆöÁæ©Á∑©ÂãïÂáΩÊï∏Ôºö70%Á∑©ÈÄ≤ + 30%Á∑©Âá∫
                    let easedProgress;
                    if (progress <= 0.7) {
                        // Ââç70%‰ΩøÁî®Á∑©ÈÄ≤ (ease-in)
                        const t = progress / 0.7; // Â∞á0-0.7Êò†Â∞ÑÂà∞0-1
                        easedProgress = Math.pow(t, 3) * 0.7; // cubic ease-inÔºåÁµêÊûúÊò†Â∞ÑÂà∞0-0.7
                    } else {
                        // Âæå30%‰ΩøÁî®Á∑©Âá∫ (ease-out)
                        const t = (progress - 0.7) / 0.3; // Â∞á0.7-1Êò†Â∞ÑÂà∞0-1
                        easedProgress = 0.7 + (1 - Math.pow(1 - t, 3)) * 0.3; // cubic ease-outÔºåÁµêÊûúÊò†Â∞ÑÂà∞0.7-1
                    }
                    
                    this.parallaxTransitionProgress = easedProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.parallaxTransitionProgress = 1; // Á¢∫‰øùÂÆåÂÖ®ÈÅéÊ∏°Âà∞ÊªëÈº†‰ΩçÁΩÆ
                    }
                };
                
                animate();
            }

            updateMousePosition() {
                if (this.isMobile) return; // Ë°åÂãïË£ùÁΩÆ‰∏çÈúÄË¶ÅÊªëÈº†ÊèíÂÄº
                
                if (this.mouseInsidePage) {
                    // ÊªëÈº†Âú®È†ÅÈù¢ÂÖßÁöÑÊ≠£Â∏∏Ë∑üÈö®ÈÇèËºØ
                    const deltaX = this.targetMouse.x - this.currentMouse.x;
                    const deltaY = this.targetMouse.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    let dynamicLerpFactor;
                    
                    if (this.mouseJustReentered) {
                        // ÊªëÈº†ÂâõÈáçÊñ∞ÈÄ≤ÂÖ•È†ÅÈù¢Ôºö‰ΩøÁî®ÊÖ¢ÈÄüÈÅéÊ∏°Ôºà60%Á∑©ÂÖ•Ôºå40%Á∑©Âá∫Ôºâ
                        const maxLerpFactor = 0.12;
                        const minLerpFactor = 0.02;
                        dynamicLerpFactor = Math.max(minLerpFactor, maxLerpFactor / (1 + distance * 3.5));
                        
                        // Áï∂Ë∑ùÈõ¢Ë∂≥Â§†Â∞èÊôÇÔºåÂàáÊèõÂà∞Ê≠£Â∏∏Ë∑üÈö®Ê®°Âºè
                        if (distance < 0.1) {
                            this.mouseJustReentered = false;
                            console.log('ÈÅéÊ∏°ÂÆåÊàêÔºåÂàáÊèõÂà∞Ê≠£Â∏∏Ë∑üÈö®Ê®°Âºè');
                        }
                    } else {
                        // ÊªëÈº†Ê≠£Â∏∏Âú®È†ÅÈù¢ÂÖßÁßªÂãïÔºö‰ΩøÁî®Âø´ÈÄüË∑üÈö®
                        dynamicLerpFactor = 0.25; // Âø´ÈÄüÈüøÊáâÁöÑÂõ∫ÂÆö‰øÇÊï∏
                    }
                    
                    this.currentMouse.x += deltaX * dynamicLerpFactor;
                    this.currentMouse.y += deltaY * dynamicLerpFactor;
                    
                } else if (this.isInertiaActive) {
                    // ÊªëÈº†Èõ¢ÈñãÈ†ÅÈù¢ÊôÇÁöÑÊÖ£ÊÄßÁ∑©Ë°ùÈÇèËºØ
                    const deltaX = this.inertiaTarget.x - this.currentMouse.x;
                    const deltaY = this.inertiaTarget.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // ÊÖ£ÊÄßÁ∑©Ë°ùÁöÑÂÑ™ÈõÖÊ∏õÈÄü‰øÇÊï∏ÔºàÂü∫ÊñºË∑ùÈõ¢ÁöÑÂãïÊÖãÊ∏õÈÄüÔºâ
                    const baseInertiaFactor = 0.025; // Âü∫Á§éÊ∏õÈÄü‰øÇÊï∏ÔºàÊõ¥ÊÖ¢Ôºâ
                    const distanceBoost = Math.min(distance * 0.8, 0.06); // Ë∑ùÈõ¢Ë∂äÈÅ†ÔºåÊ∏õÈÄüË∂äÊÖ¢
                    const inertiaLerpFactor = baseInertiaFactor + distanceBoost;
                    
                    this.currentMouse.x += deltaX * inertiaLerpFactor;
                    this.currentMouse.y += deltaY * inertiaLerpFactor;
                    
                    // Êõ¥ÂØ¨È¨ÜÁöÑÂÅúÊ≠¢Ê¢ù‰ª∂ÔºåËÆìÂãïÁï´Êõ¥ÂÑ™ÈõÖÂú∞ÁµêÊùü
                    if (distance < 0.005) {
                        this.isInertiaActive = false;
                        console.log('ÊÖ£ÊÄßÁ∑©Ë°ùÂÆåÊàê');
                    }
                }
                // ÂÖ∂‰ªñÊÉÖÊ≥ÅÔºöÊªëÈº†Èõ¢ÈñãÈ†ÅÈù¢‰∏îÁÑ°ÊÖ£ÊÄßÊôÇÔºåcurrentMouse ‰øùÊåÅ‰∏çËÆä
                
                // Êõ¥Êñ∞ mouse ÁÇ∫Áï∂ÂâçÊèíÂÄºÂæåÁöÑ‰ΩçÁΩÆ
                this.mouse.x = this.currentMouse.x;
                this.mouse.y = this.currentMouse.y;
            }

            updateParallax() {
                if (!this.loadingComplete) return;

                let rawInputX, rawInputY;

                // Êõ¥Êñ∞ÊªëÈº†‰ΩçÁΩÆÊèíÂÄºÔºàÂÉÖÂú®Ê°åÈù¢ÁâàÔºâ
                if (!this.isMobile) {
                    this.updateMousePosition();
                    // Ê°åÈù¢Áâà‰ΩøÁî®ÊèíÂÄºÂæåÁöÑÊªëÈº†‰ΩçÁΩÆ
                    rawInputX = this.mouse.x;
                    rawInputY = this.mouse.y;
                } else {
                    // Ë°åÂãïÁâà‰ΩøÁî®Áµ±‰∏ÄÊéßÂà∂ÂÄº
                    rawInputX = this.currentOffsetX;
                    rawInputY = this.currentOffsetY;
                }
                
                // üîß ‰øÆÊ≠£ÔºöÂú®ÈÅéÊ∏°ÊúüÈñìÂíå‰∏çÂêåË¶ñËßí‰∏ãÈÉΩË¶ÅËôïÁêÜÊªëÈº†Ëº∏ÂÖ•
                if (this.viewState === 'detail' && !this.isTransitioning) {
                    // üïπÔ∏è Á¥îÂ±ÄÈÉ®Ë¶ñËßíÔºöÂè™ÊáâÁî®Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂
                    this.updateDetailViewControl(rawInputX, rawInputY);
                } else if (this.viewState === 'main' && !this.isTransitioning) {
                    // üñºÔ∏è Á¥î‰∏ªË¶ñËßíÔºöÂè™ÊáâÁî®‰∏ªË¶ñÂ∑ÆÊïàÊûú
                    const inputX = rawInputX * this.parallaxTransitionProgress;
                    const inputY = rawInputY * this.parallaxTransitionProgress;
                    this.applyMainParallax(inputX, inputY);
                } else if (this.isTransitioning) {
                    // üîÑ ÈÅéÊ∏°ÊúüÈñìÔºöÂêåÊôÇÊáâÁî®ÂÖ©Á®ÆÊïàÊûúÔºå‰ΩÜÊ¨äÈáç‰∏çÂêå
                    // ÈÄôÂÄãÈÇèËºØÊúÉÂú®ÂãïÁï´ÂáΩÊï∏‰∏≠ËôïÁêÜ
                    return;
                }
            }

            // üå´Ô∏è ÈÅéÊ∏°Ê®°Á≥äÊïàÊûúÊéßÂà∂ÊñπÊ≥ï
            applyTransitionBlur(progress) {
                // üîß ‰∏âÊÆµÂºèÈùûÂ∞çÁ®±Ê®°Á≥äÊõ≤Á∑öÔºö
                // ÈÄ≤Â∫¶ 0.0 ‚Üí Ê®°Á≥ä 0%
                // ÈÄ≤Â∫¶ 0.33 ‚Üí Ê®°Á≥ä 100%
                // ÈÄ≤Â∫¶ 0.66 ‚Üí Ê®°Á≥ä 25%
                // ÈÄ≤Â∫¶ 1.0 ‚Üí Ê®°Á≥ä 0%
                
                let blurFactor;
                
                if (progress <= 0.33) {
                    // Ââç33%ÔºöÂæû0%Á∑©ÈÄ≤Âà∞100% (‰ΩøÁî®ease-inÊõ≤Á∑ö)
                    const t = progress / 0.33; // Êò†Â∞ÑÂà∞0-1
                    blurFactor = t * t; // quadratic ease-in
                } else if (progress <= 0.66) {
                    // 33%-66%ÔºöÂæû100%Âø´ÈÄü‰∏ãÈôçÂà∞25% (Á∑öÊÄß)
                    const t = (progress - 0.33) / 0.33; // Êò†Â∞ÑÂà∞0-1
                    blurFactor = 1.0 - (t * 0.75); // Âæû1.0‰∏ãÈôçÂà∞0.25
                } else {
                    // 66%-100%ÔºöÂæû25%Á∑©Âá∫Âà∞0% (‰ΩøÁî®ease-outÊõ≤Á∑ö)
                    const t = (progress - 0.66) / 0.34; // Êò†Â∞ÑÂà∞0-1 (0.34 = 1.0 - 0.66)
                    const easeOutT = 1 - Math.pow(1 - t, 2); // quadratic ease-out
                    blurFactor = 0.25 * (1 - easeOutT); // Âæû0.25‰∏ãÈôçÂà∞0
                }
                
                const blurIntensity = blurFactor * this.TRANSITION_BLUR_STRENGTH;
                
                // ÊáâÁî®Ê®°Á≥äÂà∞canvasÂÖÉÁ¥†
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = `blur(${blurIntensity}px)`;
                }
                
                // ÂèØÈÅ∏ÔºöÊ∑ªÂä†Ë™øË©¶Ë≥áË®ä
                console.log(`üå´Ô∏è ÈÅéÊ∏°Ê®°Á≥ä: progress=${progress.toFixed(3)}, factor=${(blurFactor*100).toFixed(1)}%, blur=${blurIntensity.toFixed(2)}px`);
            }
            
            // üå´Ô∏è ÈáçÁΩÆÊ®°Á≥äÊïàÊûú
            resetTransitionBlur() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = 'none';
                }
            }
            
            // üîç ÂãïÊÖãË®≠ÂÆöÂ±ÄÈÉ®Ë¶ñËßíÊîæÂ§ßÂÄçÁéá
            setDetailZoomScale(scale) {
                if (scale < 1.0) {
                    console.warn('‚ö†Ô∏è ÊîæÂ§ßÂÄçÁéá‰∏çËÉΩÂ∞èÊñº1.0ÔºåÂ∑≤Ë®≠ÂÆöÁÇ∫1.0');
                    scale = 1.0;
                } else if (scale > 20.0) {
                    console.warn('‚ö†Ô∏è ÊîæÂ§ßÂÄçÁéá‰∏çËÉΩÂ§ßÊñº20.0ÔºåÂ∑≤Ë®≠ÂÆöÁÇ∫20.0');
                    scale = 20.0;
                }
                
                this.DETAIL_ZOOM_SCALE = scale;
                console.log(`üîç Â±ÄÈÉ®Ë¶ñËßíÊîæÂ§ßÂÄçÁéáÂ∑≤Ë®≠ÂÆöÁÇ∫: ${scale}x (${(scale*100).toFixed(0)}%)`);
            }
            
            // üîç ÂãïÊÖãÁç≤ÂèñÁõÆÊ®ôÁõ∏Ê©ü‰ΩçÁΩÆ
            getTargetCameraPosition() {
                return {
                    x: 0,
                    y: 0,
                    z: this.originalCameraPosition.z / this.DETAIL_ZOOM_SCALE
                };
            }

            // üîß Êñ∞Â¢ûÔºöÁç®Á´ãÁöÑ‰∏ªË¶ñÂ∑ÆÊáâÁî®ÊñπÊ≥ï
            applyMainParallax(inputX, inputY) {
                this.layers.forEach((layer) => {
                    const userData = layer.userData;
                    
                    if (userData.hasDepth) {
                        // Â∞çÊñºÊúâÊ∑±Â∫¶ÂúñÁöÑÂúñÂ±§ÔºåÊõ¥Êñ∞ Shader ÁöÑ parallaxOffset ÂèÉÊï∏
                        layer.children.forEach((mesh) => {
                            if (mesh.material && mesh.material.uniforms) {
                                mesh.material.uniforms.parallaxOffset.value.set(
                                    inputX * this.PARALLAX_INTENSITY, 
                                    inputY * this.PARALLAX_INTENSITY
                                );
                            }
                        });
                    }
                    // Ê≤íÊúâÊ∑±Â∫¶ÂúñÁöÑÂúñÂ±§‰øùÊåÅÈùúÊ≠¢Ôºå‰ΩçÁΩÆ‰∏çËÆä
                });

                // üî¥ Êõ¥Êñ∞‰∫íÂãïÈªûÈªûÁöÑË¶ñÂ∑ÆÊïàÊûú
                this.updateInteractiveDotsParallax(inputX, inputY);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // üéÆ Ê™¢Êü•ÊéßÂà∂Ê®°ÂºèÂàáÊèõ
                this.checkControlModeSwitch();
                
                // Â¶ÇÊûúËºâÂÖ•Â∞ÅÈù¢ÈÇÑÂú®È°ØÁ§∫ÔºåÊ∏≤ÊüìËºâÂÖ•Â†¥ÊôØ
                if (!this.loadingComplete && this.loadingCoverLoaded && this.loadingRenderer) {
                    this.loadingRenderer.render(this.loadingScene, this.loadingCamera);
                }
                
                // Ê∏≤Êüì‰∏ªÂ†¥ÊôØ
                if (this.loadingComplete) {
                    this.updateParallax();
                }
                this.renderer.render(this.scene, this.camera);
            }

            // üîç ================== Â±ÄÈÉ®ÂúñÁ≥ªÁµ± ==================

            zoomToDetailView(clickedDot) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                this.viewState = 'detail';
                this.currentDetailDot = clickedDot;
                
                // üïπÔ∏è ÈáçÁΩÆÂ±ÄÈÉ®Ë¶ñËßíÊéßÂà∂
                this.resetDetailViewControl();
                
                // ÊâæÂà∞Â∞çÊáâÁöÑÂ±ÄÈÉ®Âúñ
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === clickedDot.config.id
                );
                
                if (!detailLayer) {
                    console.error(`üîç Êâæ‰∏çÂà∞Â∞çÊáâÁöÑÂ±ÄÈÉ®Âúñ: ${clickedDot.config.id}`);
                    this.isTransitioning = false;
                    return;
                }
                
                console.log(`üéØ ÈñãÂßãÊîæÂ§ßÂãïÁï´Âà∞ ${clickedDot.config.id}ÔºåÊîæÂ§ßÂÄçÁéá: ${this.DETAIL_ZOOM_SCALE}x (${(this.DETAIL_ZOOM_SCALE*100).toFixed(0)}%)`);
                
                // Ë®àÁÆóÁõÆÊ®ô‰ΩçÁΩÆ - Â∞áÂ±ÄÈÉ®ÂúñÁöÑ‰∏≠ÂøÉÁßªÂãïÂà∞Áï´Èù¢‰∏≠ÂøÉ
                const detailMesh = detailLayer.mesh;
                const targetSceneX = -detailMesh.position.x;  // ÂèçÂêëÁßªÂãïÂ†¥ÊôØ
                const targetSceneY = -detailMesh.position.y;
                
                // Ë®≠ÂÆöÂãïÁï´ÂèÉÊï∏
                const duration = 1500; // 1.5Áßí
                const startTime = Date.now();
                
                // Ë®òÈåÑËµ∑ÂßãÁãÄÊÖã
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // ÁõÆÊ®ôÁãÄÊÖã - Ê†πÊìöË®≠ÂÆöÁöÑÊîæÂ§ßÂÄçÁéáË®àÁÆóÁõ∏Ê©ü‰ΩçÁΩÆ
                // ÊîæÂ§ßÂÄçÁéá = ÂàùÂßãË∑ùÈõ¢ / ÁõÆÊ®ôË∑ùÈõ¢ÔºåÊâÄ‰ª•ÁõÆÊ®ôË∑ùÈõ¢ = ÂàùÂßãË∑ùÈõ¢ / ÊîæÂ§ßÂÄçÁéá
                const targetCameraZ = startCameraZ / this.DETAIL_ZOOM_SCALE; // ÂèØÈÖçÁΩÆÊîæÂ§ßÂÄçÁéá
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Á∑©ÂãïÂáΩÊï∏Ôºöease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // üîß ÈÅéÊ∏°ÊúüÈñìÁöÑÊªëÈº†ÊéßÂà∂ÔºöÂêåÊôÇÊáâÁî®‰∏ªË¶ñÂ∑ÆÂíåÂ±ÄÈÉ®Ë¶ñËßíÊéßÂà∂
                    const rawInputX = this.isMobile ? this.currentOffsetX : this.mouse.x;
                    const rawInputY = this.isMobile ? this.currentOffsetY : this.mouse.y;
                    
                    // ‰∏ªË¶ñÂ∑ÆÊ¨äÈáçÔºöÂæû1ÈÅéÊ∏°Âà∞0
                    const mainParallaxWeight = 1.0 - easeProgress;
                    // Â±ÄÈÉ®Ë¶ñËßíÊ¨äÈáçÔºöÂæû0ÈÅéÊ∏°Âà∞1  
                    const detailViewWeight = easeProgress;
                    
                    // Ë®àÁÆóÊ∑∑ÂêàÁöÑÂ†¥ÊôØ‰ΩçÁΩÆ
                    let finalSceneX = startSceneX + (targetSceneX - startSceneX) * easeProgress;
                    let finalSceneY = startSceneY + (targetSceneY - startSceneY) * easeProgress;
                    
                    // ÊáâÁî®‰∏ªË¶ñÂ∑ÆÊïàÊûúÔºàÊ¨äÈáçÈÅûÊ∏õÔºâ
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // ÊáâÁî®Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂ÔºàÊ¨äÈáçÈÅûÂ¢ûÔºâ
                    if (detailViewWeight > 0) {
                        const detailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        const detailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        
                        // ÊáâÁî®ÈÇäÁïåÈôêÂà∂
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedOffsetX = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetX));
                        const limitedOffsetY = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetY));
                        
                        // ÁñäÂä†Â±ÄÈÉ®Ë¶ñËßíÂÅèÁßª
                        finalSceneX += limitedOffsetX;
                        finalSceneY += limitedOffsetY;
                    }
                    
                    // Êõ¥Êñ∞Áõ∏Ê©ü‰ΩçÁΩÆ (ÊîæÂ§ßÊïàÊûú)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // Êõ¥Êñ∞Â†¥ÊôØ‰ΩçÁΩÆ (ÁßªÂãïÂà∞Â±ÄÈÉ®Âúñ‰∏≠ÂøÉ + ÊªëÈº†ÂÅèÁßª)
                    this.scene.position.x = finalSceneX;
                    this.scene.position.y = finalSceneY;
                    
                    // üåü Â±ÄÈÉ®ÂúñÊ∑°ÂÖ• - Âú®ÊîæÂ§ßÈÅéÁ®ã‰∏≠ÈÄêÊº∏È°ØÁ§∫ÔºåÂêåÊôÇË™øÊï¥ÁæΩÂåñÂº∑Â∫¶
                    if (detailMesh.material.uniforms) {
                        // ÈÄèÊòéÂ∫¶ÈÅéÊ∏°Ôºö‰ΩøÁî®Á®çÂø´ÁöÑÈÄüÂ∫¶‰ΩÜ‰∏çË¶ÅÂ§™Âø´
                        const targetOpacity = Math.min(1.0, easeProgress * 1.1);
                        detailMesh.material.uniforms.opacity.value = targetOpacity;
                        
                        // üîß ‰øÆÊ≠£ÁæΩÂåñÈÅéÊ∏°Ôºö‰ΩøÁî®Á∑öÊÄßÈÄ≤Â∫¶ËÄåÈùûÁ∑©ÂãïÈÄ≤Â∫¶ÔºåÁ¢∫‰øùÂπ≥ÊªëÈÅéÊ∏°
                        const linearProgress = progress; // ‰ΩøÁî®Á∑öÊÄßÈÄ≤Â∫¶ËÄåÈùûeaseProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_MAIN_VIEW - (linearProgress * featherRange);
                        detailMesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // ÂèØÈÅ∏ÔºöÊ∑ªÂä†Ë™øË©¶Ë≥áË®ä
                        // console.log(`üåü ÁæΩÂåñÈÅéÊ∏°: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // üî¥ ÈªûÈªûÊ∑°Âá∫ÊïàÊûú - ÊîæÂ§ßÊôÇ
                    this.updateDotsTransitionOpacity('zoomIn', progress);
                    
                    // üå´Ô∏è ÊáâÁî®ÈÅéÊ∏°Ê®°Á≥äÊïàÊûú
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ÂãïÁï´ÂÆåÊàê
                        this.camera.position.z = targetCameraZ;
                        // üîß ÊúÄÁµÇ‰ΩçÁΩÆÈúÄË¶ÅÂåÖÂê´Áï∂ÂâçÁöÑÂ±ÄÈÉ®Ë¶ñËßíÂÅèÁßª
                        const finalDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const finalDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        const finalLimitedOffsetX = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetX));
                        const finalLimitedOffsetY = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetY));
                        
                        this.scene.position.x = targetSceneX + finalLimitedOffsetX;
                        this.scene.position.y = targetSceneY + finalLimitedOffsetY;
                        
                        // üåü Ë®≠ÂÆöÊúÄÁµÇÁãÄÊÖãÔºöÂÆåÂÖ®‰∏çÈÄèÊòéÔºåÁæΩÂåñÊúÄÂº±
                        if (detailMesh.material.uniforms) {
                            detailMesh.material.uniforms.opacity.value = 1.0;
                            detailMesh.material.uniforms.featherStrength.value = this.FEATHER_DETAIL_VIEW;  // Â±ÄÈÉ®Ë¶ñËßíÁæΩÂåñÊúÄÂº±
                        }
                        
                        // üå´Ô∏è ÈáçÁΩÆÊ®°Á≥äÊïàÊûú
                        this.resetTransitionBlur();
                        
                        // üî¥ ÈáçÁΩÆÈªûÈªûÈÄèÊòéÂ∫¶ÁÇ∫0%ÔºàÂ±ÄÈÉ®Ë¶ñËßíÊôÇÂÆåÂÖ®Èö±ËóèÔºâ
                        this.resetDotsTransitionOpacity(0.0);
                        
                        this.isTransitioning = false;
                        
                        console.log(`üéØ ÊîæÂ§ßÂãïÁï´ÂÆåÊàêÔºåÈÄ≤ÂÖ•Â±ÄÈÉ®Ë¶ñËßí: ${clickedDot.config.id}`);
                    }
                };
                
                animate();
            }

            returnToMainView() {
                if (this.isTransitioning || this.viewState === 'main') return;
                
                this.isTransitioning = true;
                
                // üïπÔ∏è ÈáçÁΩÆÂ±ÄÈÉ®Ë¶ñËßíÊéßÂà∂
                this.resetDetailViewControl();
                
                console.log('üîÑ ÈñãÂßãËøîÂõû‰∏ªË¶ñËßíÂãïÁï´');
                
                // ÊâæÂà∞Áï∂ÂâçÁöÑÂ±ÄÈÉ®Âúñ
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === this.currentDetailDot.config.id
                );
                
                // Ë®≠ÂÆöÂãïÁï´ÂèÉÊï∏
                const duration = 1500; // 1.5Áßí
                const startTime = Date.now();
                
                // Ë®òÈåÑËµ∑ÂßãÁãÄÊÖã
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // üîß ÂàÜÈõ¢Ëµ∑Âßã‰ΩçÁΩÆÁöÑÂü∫Á§é‰ΩçÁΩÆÂíåÊªëÈº†ÂÅèÁßª
                const detailMesh = detailLayer.mesh;
                const baseSceneX = -detailMesh.position.x;  // Â±ÄÈÉ®Âúñ‰∏≠ÂøÉÂ∞çÊáâÁöÑÂü∫Á§éÂ†¥ÊôØ‰ΩçÁΩÆ
                const baseSceneY = -detailMesh.position.y;
                const startOffsetX = startSceneX - baseSceneX;  // Ëµ∑ÂßãÊôÇÁöÑÊªëÈº†ÂÅèÁßª
                const startOffsetY = startSceneY - baseSceneY;
                
                // ÁõÆÊ®ôÁãÄÊÖã (ÂõûÂà∞ÂéüÂßã‰ΩçÁΩÆ) - ‰ΩøÁî®ÂàùÂßãÁõ∏Ê©ü‰ΩçÁΩÆ
                const targetCameraZ = 5; // Âõ∫ÂÆöÂõûÂà∞ÂàùÂßã‰ΩçÁΩÆ
                const targetSceneX = 0;
                const targetSceneY = 0;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Á∑©ÂãïÂáΩÊï∏Ôºöease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // üîß ÈÅéÊ∏°ÊúüÈñìÁöÑÊªëÈº†ÊéßÂà∂ÔºöÂêåÊôÇÊáâÁî®Â±ÄÈÉ®Ë¶ñËßíÂíå‰∏ªË¶ñÂ∑ÆÊéßÂà∂
                    const rawInputX = this.isMobile ? this.currentOffsetX : this.mouse.x;
                    const rawInputY = this.isMobile ? this.currentOffsetY : this.mouse.y;
                    
                    // Â±ÄÈÉ®Ë¶ñËßíÊ¨äÈáçÔºöÂæû1ÈÅéÊ∏°Âà∞0
                    const detailViewWeight = 1.0 - easeProgress;
                    // ‰∏ªË¶ñÂ∑ÆÊ¨äÈáçÔºöÂæû0ÈÅéÊ∏°Âà∞1
                    const mainParallaxWeight = easeProgress;
                    
                    // üîß ‰øÆÊ≠£ÔºöË®àÁÆóÂü∫Á§éÂ†¥ÊôØ‰ΩçÁΩÆÁöÑÈÅéÊ∏°
                    const baseTransitionX = baseSceneX + (targetSceneX - baseSceneX) * easeProgress;
                    const baseTransitionY = baseSceneY + (targetSceneY - baseSceneY) * easeProgress;
                    
                    // Ë®àÁÆóÊ∑∑ÂêàÁöÑÊªëÈº†ÂÅèÁßª
                    let finalOffsetX = 0;
                    let finalOffsetY = 0;
                    
                    // ÊáâÁî®Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂ÔºàÊ¨äÈáçÈÅûÊ∏õÔºâ
                    if (detailViewWeight > 0) {
                        const currentDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const currentDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        
                        // ÊáâÁî®ÈÇäÁïåÈôêÂà∂
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedCurrentOffsetX = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetX));
                        const limitedCurrentOffsetY = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetY));
                        
                        // üîß ‰øÆÊ≠£ÔºöÂæûËµ∑ÂßãÂÅèÁßªÂπ≥ÊªëÈÅéÊ∏°Âà∞0ÔºàÂõûÂà∞‰∏ªË¶ñËßí‰∏≠ÂøÉÔºâ
                        // Ëµ∑ÂßãÂÅèÁßªÈö®ËëóÊ¨äÈáçÊ∏õÂ∞ëËÄåÊ∏õÂ∞ëÔºåÊúÄÁµÇËÆäÁÇ∫0
                        const transitionOffsetX = startOffsetX * detailViewWeight;
                        const transitionOffsetY = startOffsetY * detailViewWeight;
                        
                        // Áï∂ÂâçÊªëÈº†ÂÅèÁßª‰πüÈö®ËëóÊ¨äÈáçÊ∏õÂ∞ëËÄåÊ∏õÂ∞ë
                        const currentOffsetX = limitedCurrentOffsetX * detailViewWeight;
                        const currentOffsetY = limitedCurrentOffsetY * detailViewWeight;
                        
                        // Ê∑∑ÂêàÂÖ©Á®ÆÂÅèÁßªÔºå‰ΩÜÈÉΩÊúÉÈö®ËëóÊ¨äÈáçÊ∏õÂ∞ë
                        finalOffsetX = transitionOffsetX * 0.3 + currentOffsetX * 0.7;
                        finalOffsetY = transitionOffsetY * 0.3 + currentOffsetY * 0.7;
                    } else {
                        // üîß Ê¨äÈáçÁÇ∫0ÊôÇÔºåÂÅèÁßª‰πüÊáâË©≤ÁÇ∫0ÔºàÂÆåÂÖ®ÂõûÂà∞‰∏ªË¶ñËßíÔºâ
                        finalOffsetX = 0;
                        finalOffsetY = 0;
                    }
                    
                    // üîß ‰øÆÊ≠£ÔºöÂ†¥ÊôØÂü∫Á§é‰ΩçÁΩÆÂπ≥ÊªëÈÅéÊ∏°Âà∞(0,0)
                    const sceneBaseX = baseTransitionX + finalOffsetX;
                    const sceneBaseY = baseTransitionY + finalOffsetY;
                    
                    // Êõ¥Êñ∞Áõ∏Ê©ü‰ΩçÁΩÆ (Á∏ÆÂ∞èÊïàÊûú)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // üîß Ë®≠ÂÆöÂ†¥ÊôØÂü∫Á§é‰ΩçÁΩÆ
                    this.scene.position.x = sceneBaseX;
                    this.scene.position.y = sceneBaseY;
                    
                    // üîß Âú®Â†¥ÊôØÂü∫Á§é‰ΩçÁΩÆ‰πã‰∏äÊáâÁî®‰∏ªË¶ñÂ∑ÆÊïàÊûúÔºàÊ¨äÈáçÈÅûÂ¢ûÔºâ
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // üåü Â±ÄÈÉ®ÂúñÊ∑°Âá∫ - ÂêåÊôÇË™øÊï¥ÁæΩÂåñÂº∑Â∫¶
                    if (detailLayer && detailLayer.mesh.material.uniforms) {
                        detailLayer.mesh.material.uniforms.opacity.value = 1.0 - easeProgress;
                        
                        // üîß ‰øÆÊ≠£ÁæΩÂåñÈÅéÊ∏°Ôºö‰ΩøÁî®Á∑öÊÄßÈÄ≤Â∫¶Á¢∫‰øùÂπ≥ÊªëÈÅéÊ∏°
                        const linearProgress = progress; // ‰ΩøÁî®Á∑öÊÄßÈÄ≤Â∫¶ËÄåÈùûeaseProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_DETAIL_VIEW + (linearProgress * featherRange);
                        detailLayer.mesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // ÂèØÈÅ∏ÔºöÊ∑ªÂä†Ë™øË©¶Ë≥áË®ä
                        // console.log(`üåü ÁæΩÂåñÈÅéÊ∏°: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // üî¥ ÈªûÈªûÊ∑°ÂÖ•ÊïàÊûú - Á∏ÆÂ∞èÊôÇ
                    this.updateDotsTransitionOpacity('zoomOut', progress);
                    
                    // üå´Ô∏è ÊáâÁî®ÈÅéÊ∏°Ê®°Á≥äÊïàÊûú
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ÂãïÁï´ÂÆåÊàê
                        this.camera.position.z = targetCameraZ;
                        
                        // üîß Â†¥ÊôØ‰ΩçÁΩÆÂ∑≤Á∂ìÂú®ÂãïÁï´ÈÅéÁ®ã‰∏≠Âπ≥ÊªëÈÅéÊ∏°Âà∞ÁõÆÊ®ô‰ΩçÁΩÆ(0,0)
                        // ‰∏çÈúÄË¶ÅÂÜçÊ¨°Ë®≠ÂÆöÔºåÈÅøÂÖçÁ™ÅË∑≥
                        // this.scene.position.x = targetSceneX;
                        // this.scene.position.y = targetSceneY;
                        
                        // üîß Á¢∫‰øùÊúÄÁµÇÁãÄÊÖãÔºöÂ†¥ÊôØ‰ΩçÁΩÆÁÇ∫(0,0)Ôºå‰∏ªË¶ñÂ∑ÆÊïàÊûúÁñäÂä†
                        this.scene.position.x = 0;
                        this.scene.position.y = 0;
                        const finalMainInputX = rawInputX * this.parallaxTransitionProgress;
                        const finalMainInputY = rawInputY * this.parallaxTransitionProgress;
                        this.applyMainParallax(finalMainInputX, finalMainInputY);
                        
                        // üåü ÈáçÁΩÆÂ±ÄÈÉ®ÂúñÁãÄÊÖãÔºöÈÄèÊòéÂ∫¶ÁÇ∫0ÔºåÁæΩÂåñÂº∑Â∫¶ÊúÄÂº∑
                        if (detailLayer && detailLayer.mesh.material.uniforms) {
                            detailLayer.mesh.material.uniforms.opacity.value = 0.0;
                            detailLayer.mesh.material.uniforms.featherStrength.value = this.FEATHER_MAIN_VIEW;  // ‰∏ªË¶ñËßíÁæΩÂåñÊúÄÂº∑
                        }
                        
                        // üå´Ô∏è ÈáçÁΩÆÊ®°Á≥äÊïàÊûú
                        this.resetTransitionBlur();
                        
                        // üî¥ ÈáçÁΩÆÈªûÈªûÈÄèÊòéÂ∫¶ÁÇ∫100%Ôºà‰∏ªË¶ñËßíÊôÇÂÆåÂÖ®È°ØÁ§∫Ôºâ
                        this.resetDotsTransitionOpacity(1.0);
                        
                        // ÈáçÁΩÆÁãÄÊÖã
                        this.viewState = 'main';
                        this.currentDetailDot = null;
                        this.isTransitioning = false;
                        
                        console.log('üîÑ ËøîÂõû‰∏ªË¶ñËßíÂãïÁï´ÂÆåÊàê');
                    }
                };
                
                animate();
            }

            loadDetailLayers() {
                console.log('üîç ÈñãÂßãËºâÂÖ•Â±ÄÈÉ®ÂúñÂ±§');
                
                this.detailLayerInfo.forEach((detailInfo, index) => {
                    this.loadDetailLayer(detailInfo, index);
                });
            }

            loadDetailLayer(detailInfo, index) {
                const loader = new THREE.TextureLoader();
                
                console.log(`üîç Ê≠£Âú®ËºâÂÖ•Â±ÄÈÉ®Âúñ: ${detailInfo.name}.png`);
                loader.load(
                    `images/${detailInfo.name}.png`,
                    (texture) => {
                        console.log(`üîç ÊàêÂäüËºâÂÖ•Â±ÄÈÉ®Âúñ: ${detailInfo.name}.png`);
                        this.createDetailLayerMesh(texture, detailInfo, index);
                    },
                    undefined,
                    (error) => {
                        console.error(`üîç Â±ÄÈÉ®ÂúñËºâÂÖ•Â§±Êïó: ${detailInfo.name}.png`, error);
                    }
                );
            }

            createDetailLayerMesh(texture, detailInfo, index) {
                // üîß ‰øÆÊ≠£Ôºö‰ΩøÁî®‰∏ªÂúñÂ±§ÁöÑÂ∞∫ÂØ∏‰ΩúÁÇ∫Âü∫Ê∫ñÔºåËÄå‰∏çÊòØÂ±ÄÈÉ®ÂúñËá™Â∑±ÁöÑÂ∞∫ÂØ∏
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) {
                    console.error('üîç ÁÑ°Ê≥ïÁç≤Âèñ‰∏ªÂúñÂ±§Â∞∫ÂØ∏ÔºåÂ±ÄÈÉ®ÂúñÂª∫Á´ãÂ§±Êïó');
                    return;
                }
                
                const { width: mainWidth, height: mainHeight } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // üîß Âª∫Á´ãËàá‰∏ªÂúñÂ±§Áõ∏ÂêåÂ§ßÂ∞èÁöÑÂπæ‰ΩïÈ´îÔºåÁ®çÂæåÁî®Á∏ÆÊîæÊéßÂà∂ÂØ¶ÈöõÂ§ßÂ∞è
                const geometry = new THREE.PlaneGeometry(mainWidth, mainHeight);
                
                // üåü Âª∫Á´ãÂÖ∑ÊúâÈÇäÁ∑£ÁæΩÂåñÊïàÊûúÁöÑËá™ÂÆöÁæ©ShaderÊùêË≥™
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform sampler2D mainTexture;
                    uniform float opacity;
                    uniform float featherStrength;  // ÁæΩÂåñÂº∑Â∫¶ (0.0-1.0)
                    uniform float featherRange;     // ÁæΩÂåñÂΩ±ÈüøÁØÑÂúç (0.0-1.0)
                    varying vec2 vUv;
                    
                    void main() {
                        // ÂèñÊ®£‰∏ªÁ¥ãÁêÜ
                        vec4 color = texture2D(mainTexture, vUv);
                        
                        // Ë®àÁÆóÂà∞ÈÇäÁ∑£ÁöÑË∑ùÈõ¢
                        vec2 center = vec2(0.5, 0.5);
                        vec2 edgeDistance = abs(vUv - center) * 2.0;  // ËΩâÊèõÁÇ∫0-1ÁØÑÂúç
                        float maxEdgeDistance = max(edgeDistance.x, edgeDistance.y);
                        
                        // ÁæΩÂåñË®àÁÆóÔºöÂæûÈÇäÁ∑£ÈñãÂßãÊ∑°Âåñ
                        float actualFeatherRange = featherStrength * featherRange;  // ÂØ¶ÈöõÁæΩÂåñÁØÑÂúç
                        float featherStart = 1.0 - actualFeatherRange;              // ÁæΩÂåñÈñãÂßã‰ΩçÁΩÆ
                        float featherEnd = 1.0;                                     // ÁæΩÂåñÁµêÊùü‰ΩçÁΩÆÔºàÈÇäÁ∑£Ôºâ
                        
                        float edgeAlpha = 1.0;
                        if (maxEdgeDistance > featherStart && actualFeatherRange > 0.0) {
                            // Âú®ÁæΩÂåñÂçÄÂüüÂÖßÔºåË®àÁÆóÈÄèÊòéÂ∫¶Êº∏ËÆä
                            float featherProgress = (maxEdgeDistance - featherStart) / (featherEnd - featherStart);
                            // ‰ΩøÁî®Êõ¥Âπ≥ÊªëÁöÑÊõ≤Á∑ö
                            edgeAlpha = 1.0 - smoothstep(0.0, 1.0, featherProgress * featherProgress);
                        }
                        
                        // ÊúÄÁµÇÈÄèÊòéÂ∫¶ = ÊùêË≥™ÈÄèÊòéÂ∫¶ √ó ÈÇäÁ∑£ÈÄèÊòéÂ∫¶
                        color.a *= opacity * edgeAlpha;
                        
                        gl_FragColor = color;
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        mainTexture: { value: texture },
                        opacity: { value: 0.0 },  // ÂàùÂßãÈÄèÊòéÂ∫¶ÁÇ∫0
                        featherStrength: { value: this.FEATHER_MAIN_VIEW },  // ÂàùÂßãÁæΩÂåñÂº∑Â∫¶Ôºö‰∏ªË¶ñËßíÊôÇÊúÄÂº∑
                        featherRange: { value: this.FEATHER_TRANSITION_RANGE }  // ÁæΩÂåñÂΩ±ÈüøÁØÑÂúç
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false  // üîß ÈóúÈçµ‰øÆÊ≠£ÔºöÈÅøÂÖçÈÄèÊòéÁâ©‰ª∂ÂØ´ÂÖ•Ê∑±Â∫¶Á∑©Ë°ùÂçÄÈÄ†ÊàêÈÅÆÊìã
                });
                
                // Âª∫Á´ãÁ∂≤Ê†º
                const mesh = new THREE.Mesh(geometry, material);
                
                // üîß ‰øÆÊ≠£Ôºö‰ΩøÁî®ÈªûÈªûÈÖçÁΩÆÁõ¥Êé•Ë®àÁÆó‰ΩçÁΩÆÔºåÁ¢∫‰øùÂùêÊ®ôÁ≥ªÁµ±ÂÆåÂÖ®‰∏ÄËá¥
                const correspondingDot = this.interactiveDots.find(dot => 
                    dot.config.id === detailInfo.dotId
                );
                
                if (correspondingDot) {
                    // üîß ‰øÆÊ≠£ÔºöËàáÈªûÈªûÁõ∏ÂêåÁöÑÂùêÊ®ôË®àÁÆóÈÇèËºØ
                    const x = (correspondingDot.config.x - 0.5) * mainWidth;
                    const y = (0.5 - correspondingDot.config.y) * mainHeight; // YËª∏ÁøªËΩâ
                    
                    mesh.position.x = x;
                    mesh.position.y = y;
                    // üîß ZËª∏‰ΩçÁΩÆÔºöÁèæÂú®Êúâ‰∫ÜdepthWrite: falseÔºåÈ†ÜÂ∫è‰∏çÂÜçÈáçË¶Å
                    mesh.position.z = 0.06 + index * 0.01; // ZËª∏‰ΩçÁΩÆ 0.06~0.08 (index 0,1,2 Â∞çÊáâ 0.06,0.07,0.08)
                    
                    console.log(`üîç Â±ÄÈÉ®Âúñ ${detailInfo.name} ‰ΩçÁΩÆË®≠ÂÆöÁÇ∫ËàáÈªûÈªû ${detailInfo.dotId} Áõ∏ÂêåÁöÑË®àÁÆóÁµêÊûú:`, 
                               `(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
                } else {
                    console.warn(`üîç Êâæ‰∏çÂà∞Â∞çÊáâÁöÑÈªûÈªû: ${detailInfo.dotId}`);
                    mesh.position.z = 0.06 + index * 0.01;
                }
                
                // Ë®≠ÂÆöÂàùÂßãÁ∏ÆÊîæ25%
                mesh.scale.setScalar(0.25);
                
                // ÂÑ≤Â≠òÁõ∏ÈóúË≥áË®ä
                mesh.userData = {
                    isDetailLayer: true,
                    detailInfo: detailInfo,
                    originalTexture: texture,  // Â±ÄÈÉ®ÂúñÊú¨Ë∫´ÁöÑÁ¥ãÁêÜ
                    mainTexture: firstLayer.userData.mainTexture,  // üîß Êñ∞Â¢ûÔºö‰∏ªÂúñÂ±§Á¥ãÁêÜÂºïÁî®ÔºåÁî®ÊñºÂ∞∫ÂØ∏Ë®àÁÆó
                    baseScale: 0.25,
                    dotId: detailInfo.dotId
                };
                
                // Ê∑ªÂä†Âà∞Â∞çÊáâÁöÑÂúñÂ±§ÁµÑ
                const targetGroup = this[detailInfo.group];
                if (targetGroup) {
                    targetGroup.add(mesh);
                    console.log(`üîç Â±ÄÈÉ®Âúñ ${detailInfo.name} Â∑≤Ê∑ªÂä†Âà∞ ${detailInfo.group}`);
                } else {
                    console.error(`üîç Êâæ‰∏çÂà∞ÁõÆÊ®ôÂúñÂ±§ÁµÑ: ${detailInfo.group}`);
                }
                
                // Ê∑ªÂä†Âà∞Â±ÄÈÉ®ÂúñÂ±§Èô£Âàó
                this.detailLayers.push({
                    mesh: mesh,
                    group: targetGroup,
                    detailInfo: detailInfo,
                    isVisible: true,
                    basePosition: {
                        x: mesh.position.x,
                        y: mesh.position.y,
                        z: mesh.position.z
                    }
                });
            }

            updateDetailLayersLayout() {
                // Áï∂Ë¶ñÁ™óÂ§ßÂ∞èÊîπËÆäÊôÇÔºåÊõ¥Êñ∞Â±ÄÈÉ®ÂúñÂ±§‰ΩçÁΩÆÂíåÂ∞∫ÂØ∏
                if (!this.detailLayers.length || !this.interactiveDots.length) return;
                
                // Áç≤Âèñ‰∏ªÂúñÁöÑÂ∞∫ÂØ∏Áî®ÊñºË®àÁÆó
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                this.detailLayers.forEach(detailLayer => {
                    const correspondingDot = this.interactiveDots.find(dot => 
                        dot.config.id === detailLayer.detailInfo.dotId
                    );
                    
                    if (correspondingDot) {
                        // üîß ‰øÆÊ≠£Ôºö‰ΩøÁî®ËàáÈªûÈªûÁõ∏ÂêåÁöÑÂùêÊ®ôË®àÁÆóÈÇèËºØÔºåÁ¢∫‰øùÂÆåÂÖ®‰∏ÄËá¥
                        const x = (correspondingDot.config.x - 0.5) * width;
                        const y = (0.5 - correspondingDot.config.y) * height; // YËª∏ÁøªËΩâ
                        
                        detailLayer.mesh.position.x = x;
                        detailLayer.mesh.position.y = y;
                        
                        // üîß ‰øÆÊ≠£ÔºöÊõ¥Êñ∞Âπæ‰ΩïÈ´îÂ∞∫ÂØ∏‰ª•ÂåπÈÖç‰∏ªÂúñÂ±§
                        detailLayer.mesh.geometry.dispose(); // ÈáãÊîæËàäÁöÑÂπæ‰ΩïÈ´î
                        detailLayer.mesh.geometry = new THREE.PlaneGeometry(width, height);
                        
                        // Êõ¥Êñ∞Âü∫Á§é‰ΩçÁΩÆË®òÈåÑ
                        detailLayer.basePosition.x = x;
                        detailLayer.basePosition.y = y;
                        
                        console.log(`üîç Êõ¥Êñ∞Â±ÄÈÉ®Âúñ ${detailLayer.detailInfo.name} ‰ΩçÁΩÆÂà∞ (${x.toFixed(2)}, ${y.toFixed(2)})ÔºåÂ∞∫ÂØ∏: ${width.toFixed(1)}x${height.toFixed(1)}`);
                    }
                });
            }

            // üî¥ ================== ‰∫íÂãïÈªûÈªûÁ≥ªÁµ± ==================

            createInteractiveDots() {
                console.log('üî¥ ÈñãÂßãÂâµÂª∫‰∫íÂãïÈªûÈªû');
                
                // ÈªûÈªûÈÖçÁΩÆË≥áÊñô - ‰ΩçÁΩÆ‰ª•ÁôæÂàÜÊØîË°®Á§∫ (0-1)
                const dotsConfig = [
                    { id: 'dot1', x: 0.6385, y: 0.394, depth: 0.56 },
                    { id: 'dot2', x: 0.486, y: 0.647, depth: 0.57 },
                    { id: 'dot3', x: 0.71, y: 0.628, depth: 0.65 }
                ];

                // ÁÇ∫ÊØèÂÄãÈªûÂâµÂª∫Á∂≤Ê†º
                dotsConfig.forEach((config, index) => {
                    const dot = this.createDotMesh(config);
                    this.interactiveDots.push({
                        mesh: dot,
                        config: config,
                        originalPosition: { x: config.x, y: config.y },
                        basePosition: { x: 0, y: 0 }, // Âü∫Á§é‰ΩçÁΩÆÔºà‰∏çÂê´Ë¶ñÂ∑ÆÔºâ
                        isHovered: false,
                        hoverMultiplier: 1.0,         // hoverÈÄèÊòéÂ∫¶‰πòÊï∏
                        isPressed: false,             // ÊòØÂê¶Ë¢´Êåâ‰∏ã
                        pressedScale: 1.0,            // Êåâ‰∏ãÁãÄÊÖãÁöÑÁ∏ÆÊîæ
                        // Ë∑ùÈõ¢‰∫íÂãïÁõ∏Èóú
                        mouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // ÊªëÈº†Ë∑ùÈõ¢‰øÇÊï∏ (0=ÊúÄËøë, 1=ÊúÄÈÅ†/Ë∂ÖÂá∫ÁØÑÂúç)
                        targetMouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // ÁõÆÊ®ôË∑ùÈõ¢‰øÇÊï∏
                        distanceScale: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_SCALE_FACTOR : 1.0,      // Âü∫ÊñºË∑ùÈõ¢ÁöÑÁ∏ÆÊîæ‰øÇÊï∏
                        distanceOpacity: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_OPACITY_FACTOR : 1.0,   // Âü∫ÊñºË∑ùÈõ¢ÁöÑÈÄèÊòéÂ∫¶‰øÇÊï∏
                        // üå´Ô∏è ÈÅéÊ∏°ÂãïÁï´Áõ∏Èóú
                        transitionOpacity: 1.0  // ÈÅéÊ∏°ÂãïÁï´ÈÄèÊòéÂ∫¶‰πòÊï∏ (ÊîæÂ§ßÁ∏ÆÂ∞èÊôÇÁöÑÊ∑°Âá∫Ê∑°ÂÖ•)
                    });
                    this.dotsGroup.add(dot);
                });

                // Ë®≠ÂÆöÈªûÈªûÂÆπÂô®ÁöÑÊ∏≤ÊüìÈ†ÜÂ∫è
                this.dotsGroup.renderOrder = 1; // ÊØî‰∏ªÂúñÂ±§ÁµÑ(0)È´òÔºåÊØîËºâÂÖ•Â±§‰Ωé
                
                // ÂàùÂßãÂåñÈªûÈªûÂ∏ÉÂ±Ä
                this.updateInteractiveDotsLayout();
                
                // Ë®≠ÂÆöÈªûÊìä‰∫ã‰ª∂
                this.setupDotInteractions();
                
                console.log(`‚úÖ ÊàêÂäüÂâµÂª∫ ${this.interactiveDots.length} ÂÄã‰∫íÂãïÈªûÈªû`);
            }

            createDotMesh(config) {
                // ÂâµÂª∫ÂÖ∑ÊúâÈô∞ÂΩ±ÊïàÊûúÁöÑ‰∫íÂãïÈªûÈªûÊùêË≥™
                const canvas = document.createElement('canvas');
                const size = 128; // Â¢ûÂä†Áï´Â∏ÉÂ§ßÂ∞è‰ª•ÂÆπÁ¥çÊõ¥Â§ßÁöÑÈô∞ÂΩ±
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                const outerRadius = size * 0.2; // Ë™øÊï¥ÈªûÈªûÂ§ßÂ∞èÊØî‰æã
                const innerRadius = size * 0.1;  
                const shadowRadius = size * 0.32;  // Èô∞ÂΩ±ÁØÑÂúç
                
                // Ê∏ÖÈô§Áï´Â∏É
                ctx.clearRect(0, 0, size, size);
                
                // Áπ™Ë£ΩÂ§ßÁØÑÂúçÊì¥Êï£Èô∞ÂΩ± - Âæû‰∏≠ÂøÉÂêëÂ§ñÊ®°Á≥ä
                const shadowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, shadowRadius);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');     // ‰∏≠ÂøÉËºÉÊ∑±
                shadowGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.25)');  // Êº∏ËÆä
                shadowGradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');   // Êõ¥Ê∑°
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');       // ÈÇäÁ∑£ÈÄèÊòé
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, shadowRadius, 0, Math.PI * 2);
                ctx.fillStyle = shadowGradient;
                ctx.fill();
                
                // Ë®≠ÂÆöÈªûÈªûÊú¨Ë∫´ÁöÑÈô∞ÂΩ±ÊïàÊûú
                ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 2;
                
                // Áπ™Ë£ΩÂ§ñÂúà - ÂçäÈÄèÊòéÈÇäÊ°Ü
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // ÈáçÁΩÆÈô∞ÂΩ±
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Áπ™Ë£ΩÂÖßÂúà - ÂØ¶ÂøÉ‰∏≠ÂøÉ
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                
                // ÂÖßÂúàÊº∏ËÆäÂ°´ÂÖÖ
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                innerGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)');
                
                ctx.fillStyle = innerGradient;
                ctx.fill();
                
                // Ê∑ªÂä†Á≤æÁ¥∞ÁöÑÁôΩËâ≤ÂÖâÊöàÊïàÊûú
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius + 3, 0, Math.PI * 2);
                const glowGradient = ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, outerRadius + 3);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // ÂâµÂª∫Á¥ãÁêÜ
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // ÂâµÂª∫ÊùêË≥™
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,  // ÂàùÂßãÁÇ∫ÈÄèÊòéÔºåÁ≠âÂæÖÊ∑°ÂÖ•
                    blending: THREE.NormalBlending
                });
                
                // ÂâµÂª∫Âπæ‰ΩïÈ´î - Ë™øÊï¥Â§ßÂ∞è‰ª•ÂåÖÂê´Èô∞ÂΩ±ÁØÑÂúç
                const geometry = new THREE.PlaneGeometry(0.32, 0.32); // Â¢ûÂ§ß‰ª•ÂÆπÁ¥çÈô∞ÂΩ±
                
                // ÂâµÂª∫Á∂≤Ê†º
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    isDot: true,
                    dotId: config.id,
                    depthValue: config.depth,
                    baseOpacity: 0.85, // Á®çÈ´òÁöÑÂü∫Á§éÈÄèÊòéÂ∫¶Á¢∫‰øùÂèØË¶ãÊÄß
                    isVisible: false
                };
                
                return mesh;
            }

            updateInteractiveDotsLayout() {
                if (!this.layers.length || !this.interactiveDots.length) return;
                
                // Áç≤Âèñ‰∏ªÂúñÁöÑÂ∞∫ÂØ∏Ôºà‰ΩøÁî®Á¨¨‰∏ÄÂÄãÂúñÂ±§ÁöÑ‰∏ªÁ¥ãÁêÜÔºâ
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // Êõ¥Êñ∞ÊØèÂÄãÈªûÁöÑÂü∫Á§é‰ΩçÁΩÆ
                this.interactiveDots.forEach(dotData => {
                    const { config } = dotData;
                    
                    // Ë®àÁÆóÂú®‰∏ªÂúñÁØÑÂúçÂÖßÁöÑ‰ΩçÁΩÆ
                    // relativeX/Y Âæû 0~1 ËΩâÊèõÁÇ∫ -width/2 ~ +width/2 ÁöÑÂ∫ßÊ®ô
                    const x = (config.x - 0.5) * width;
                    const y = (0.5 - config.y) * height; // YËª∏ÁøªËΩâ
                    
                    dotData.basePosition.x = x;
                    dotData.basePosition.y = y;
                    dotData.mesh.position.x = x;
                    dotData.mesh.position.y = y;
                    dotData.mesh.position.z = 0.1; // Á¢∫‰øùÂú®‰∏ªÂúñÂ±§‰πã‰∏ä
                });
                
                console.log('üî¥ ‰∫íÂãïÈªûÈªûÂ∏ÉÂ±ÄÂ∑≤Êõ¥Êñ∞');
            }

            updateInteractiveDotsParallax(inputX, inputY) {
                if (!this.interactiveDots.length) return;
                
                this.interactiveDots.forEach(dotData => {
                    const { mesh, basePosition, config } = dotData;
                    
                    // Ê†πÊìöÈªûÁöÑÊ∑±Â∫¶ÂÄºË®àÁÆóË¶ñÂ∑ÆÂÅèÁßª
                    const depthOffset = (config.depth - 0.625); // Ëàá shader ‰∏≠Áõ∏ÂêåÁöÑÂü∫Ê∫ñÈªû
                    const parallaxX = inputX * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    const parallaxY = inputY * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    
                    // ÊáâÁî®Ë¶ñÂ∑ÆÂÅèÁßªÂà∞Âü∫Á§é‰ΩçÁΩÆ
                    mesh.position.x = basePosition.x + parallaxX;
                    mesh.position.y = basePosition.y + parallaxY;
                });
            }

            setupDotInteractions() {
                // Âª∫Á´ãraycasterÁî®ÊñºÈªûÊìäÊ™¢Ê∏¨
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // ÊªëÈº†Êåâ‰∏ã‰∫ã‰ª∂
                this.renderer.domElement.addEventListener('pointerdown', (event) => {
                    this.handleDotPointerDown(event);
                });
                
                // ÊªëÈº†ÊîæÈñã‰∫ã‰ª∂
                this.renderer.domElement.addEventListener('pointerup', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // ÊªëÈº†Èõ¢ÈñãÊôÇ‰πüË¶ÅÊîæÈñãÔºàÈÅøÂÖçÊãñÊãΩÈõ¢ÈñãÂæåÂç°‰ΩèÔºâ
                this.renderer.domElement.addEventListener('pointerleave', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // Ê°åÊ©üÁâàÔºöÊªëÈº†hoverÊïàÊûúÂíåË∑ùÈõ¢‰∫íÂãï
                if (!this.isMobile) {
                    this.renderer.domElement.addEventListener('pointermove', (event) => {
                        this.handleDotHover(event);
                        // ÂêåÊôÇÊõ¥Êñ∞Ë∑ùÈõ¢‰∫íÂãï
                        if (this.DISTANCE_INTERACTION_ENABLED) {
                            this.updateDistanceInteraction(event);
                        }
                    });
                    
                    // Ë®≠ÂÆöÊªëÈº†Ê®£Âºè
                    this.renderer.domElement.style.cursor = 'default';
                } else {
                    // Ë°åÂãïÁâàÔºöË∑ùÈõ¢‰∫íÂãïÂ∑≤Âú®Âª∫ÊßãÂáΩÊï∏‰∏≠ÈóúÈñâÔºåÁÑ°ÈúÄÈ°çÂ§ñ‰∫ã‰ª∂Áõ£ËÅΩÂô®
                    console.log('Ë°åÂãïÁâàÔºöË∑ùÈõ¢ÊÑüÊáâ‰∫íÂãïÂ∑≤ÈóúÈñâ');
                }
                // Ê≥®ÊÑèÔºöË°åÂãïÁâàÁöÑÂãïÁï´ÁèæÂú®Áµ±‰∏ÄÂú® fadeInInteractiveDots ÂÆåÊàêÂæåÂïüÂãï
            }

            handleDotPointerDown(event) {
                // Â¶ÇÊûúÊ≠£Âú®ÈÅéÊ∏°ÂãïÁï´‰∏≠ÔºåÂøΩÁï•ÈªûÊìä
                if (this.isTransitioning) return;
                
                // ËΩâÊèõÊªëÈº†Â∫ßÊ®ô
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Ë®≠ÂÆöraycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                if (this.viewState === 'main') {
                    // ‰∏ªË¶ñËßíÔºöÊ™¢Êü•ÈªûÈªûÈªûÊìä
                    const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                    const intersects = this.raycaster.intersectObjects(dotMeshes);
                    
                    if (intersects.length > 0) {
                        const pressedDot = intersects[0].object;
                        const dotData = this.interactiveDots.find(d => d.mesh === pressedDot);
                        const dotId = pressedDot.userData.dotId;
                        console.log(`üî¥ ${dotId} pressed down`);
                        
                        if (dotData) {
                            // Ë®≠ÂÆöÊåâ‰∏ãÁãÄÊÖã
                            dotData.isPressed = true;
                            this.animateDotPress(dotData, true);
                        }
                    }
                } else if (this.viewState === 'detail') {
                    // Â±ÄÈÉ®Ë¶ñËßíÔºöÈªûÊìä‰ªªÊÑè‰ΩçÁΩÆËøîÂõû‰∏ªË¶ñËßí
                    console.log('üîÑ ÈªûÊìäÁï´Èù¢ËøîÂõû‰∏ªË¶ñËßí');
                    this.returnToMainView();
                }
            }

            handleDotPointerUp(event) {
                // Â¶ÇÊûúÊ≠£Âú®ÈÅéÊ∏°ÂãïÁï´‰∏≠ÔºåÂøΩÁï•ÈªûÊìä
                if (this.isTransitioning) return;
                
                if (this.viewState === 'main') {
                    // ‰∏ªË¶ñËßíÔºöÊ™¢Êü•ÊòØÂê¶ÊúâÈªûÈªûË¢´Êåâ‰∏ã‰∏¶Ëß∏ÁôºÊîæÂ§ß
                    let clickedDot = null;
                    this.interactiveDots.forEach(dotData => {
                        if (dotData.isPressed) {
                            console.log(`üî¥ ${dotData.mesh.userData.dotId} released`);
                            clickedDot = dotData;
                            dotData.isPressed = false;
                            this.animateDotPress(dotData, false);
                        }
                    });
                    
                    // Â¶ÇÊûúÊúâÈªûÈªûË¢´ÈªûÊìäÔºåÊîæÂ§ßÂà∞Â±ÄÈÉ®Ë¶ñËßí
                    if (clickedDot) {
                        console.log(`üéØ ÊîæÂ§ßÂà∞Â±ÄÈÉ®Ë¶ñËßí: ${clickedDot.config.id}`);
                        this.zoomToDetailView(clickedDot);
                    }
                }
            }

            handleDotHover(event) {
                if (this.isMobile) return;
                
                // ËΩâÊèõÊªëÈº†Â∫ßÊ®ô
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Ë®≠ÂÆöraycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                // Ê™¢Êü•ËàáÈªûÈªûÁöÑ‰∫§ÈõÜ
                const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                const intersects = this.raycaster.intersectObjects(dotMeshes);
                
                let currentHoveredDot = null;
                
                if (intersects.length > 0) {
                    currentHoveredDot = intersects[0].object;
                }
                
                // Êõ¥Êñ∞hoverÁãÄÊÖã - Âè™ËôïÁêÜÁãÄÊÖãÊîπËÆäÁöÑÈªû
                this.interactiveDots.forEach(dotData => {
                    const shouldBeHovered = dotData.mesh === currentHoveredDot;
                    
                    if (shouldBeHovered && !dotData.isHovered) {
                        // ÈñãÂßãhover
                        dotData.isHovered = true;
                        this.animateDotHover(dotData.mesh, true);
                    } else if (!shouldBeHovered && dotData.isHovered) {
                        // ÁµêÊùühover
                        dotData.isHovered = false;
                        this.animateDotHover(dotData.mesh, false);
                    }
                });
                
                // Êõ¥Êñ∞ÊªëÈº†Ê®£Âºè
                this.renderer.domElement.style.cursor = currentHoveredDot ? 'pointer' : 'default';
            }

            animateDotPress(dotData, isPressed) {
                // Êåâ‰∏ã/ÊîæÈñãÂãïÁï´
                const duration = isPressed ? 80 : 200; // Êåâ‰∏ãÂø´ÔºåÊîæÈñãÊÖ¢
                const targetScale = isPressed ? 0.8 : 1.0; // Êåâ‰∏ãÁ∏ÆÂ∞è30%
                const targetOpacityBoost = isPressed ? 1.6 : 1.0; // Êåâ‰∏ãÊôÇÊõ¥‰∫Æ
                
                const startScale = dotData.pressedScale;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Á∑©ÂãïÂáΩÊï∏ÔºöÊåâ‰∏ãÊôÇÂø´ÈÄüÔºåÊîæÈñãÊôÇÂΩàÊÄß
                    const easeProgress = isPressed ? 
                        Math.pow(progress, 1.5) : // Êåâ‰∏ãÔºöease-in Âø´ÈÄü
                        1 - Math.pow(1 - progress, 1.8); // ÊîæÈñãÔºöease-out ÂΩàÊÄß
                    
                    // Êõ¥Êñ∞Á∏ÆÊîæ‰øÇÊï∏
                    dotData.pressedScale = startScale + (targetScale - startScale) * easeProgress;
                    
                    // Êõ¥Êñ∞ÈÄèÊòéÂ∫¶ÔºàÊåâ‰∏ãÊôÇËÆä‰∫ÆÔºâ
                    const targetMultiplier = dotData.isHovered ? 1.4 * targetOpacityBoost : targetOpacityBoost;
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            animateDotHover(dotMesh, isHovering) {
                // ÊâæÂà∞Â∞çÊáâÁöÑÈªûË≥áÊñô
                const dotData = this.interactiveDots.find(d => d.mesh === dotMesh);
                if (!dotData) return;
                
                // ÈÅøÂÖçÈáçË§áÂãïÁï´
                if (dotMesh.userData.isAnimating) return;
                dotMesh.userData.isAnimating = true;
                
                // Ë®≠ÂÆöÁõÆÊ®ôÈÄèÊòéÂ∫¶‰πòÊï∏
                const targetOpacityMultiplier = isHovering ? 1.4 : 1.0;
                const duration = 200;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ‰ΩøÁî®Êõ¥Âø´ÁöÑÁ∑©ÂãïÂáΩÊï∏ÔºåËÆìhoverÂèçÊáâÊõ¥Âç≥ÊôÇ
                    const easeProgress = 1 - Math.pow(1 - progress, 2); // ease-out quad
                    
                    // Êõ¥Êñ∞ÈÄèÊòéÂ∫¶‰πòÊï∏
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetOpacityMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        dotMesh.userData.isAnimating = false;
                    }
                };
                animate();
            }

            // üéØ ================== Ë∑ùÈõ¢ÊÑüÊáâ‰∫íÂãïÁ≥ªÁµ± ==================

            updateDistanceInteraction(event) {
                if (!this.loadingComplete || !this.layers.length) return;
                
                // Áç≤ÂèñÊªëÈº†Âú®Áï´Èù¢‰∏≠ÁöÑ‰ΩçÁΩÆ
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                // Áç≤Âèñ‰∏ªÂúñÁöÑÂ∞∫ÂØ∏Âíå‰ΩçÁΩÆ‰ø°ÊÅØ
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // Ë®àÁÆóËû¢Âπï‰∏≠ÂøÉÈªû
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // Ë®àÁÆóÊúÄÂ§ßÊÑüÊáâË∑ùÈõ¢ÔºàÂü∫Êñº‰∏ªÂúñÂØ¨Â∫¶Ôºâ
                const maxDistancePixels = width * this.MAX_DISTANCE * (window.innerWidth / (width * this.IMAGE_SCALE));
                
                this.interactiveDots.forEach(dotData => {
                    // Ë®àÁÆóÈªûÈªûÂú®Ëû¢Âπï‰∏äÁöÑÂØ¶Èöõ‰ΩçÁΩÆ
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    
                    // Ë®àÁÆóÊªëÈº†ËàáÈªûÈªûÁöÑË∑ùÈõ¢
                    const deltaX = mouseX - dotScreenX;
                    const deltaY = mouseY - dotScreenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Ë®àÁÆóË∑ùÈõ¢‰øÇÊï∏ (0 = ÊúÄËøë, 1 = ÊúÄÈÅ†/Ë∂ÖÂá∫ÁØÑÂúç)
                    let distanceFactor = Math.min(distance / maxDistancePixels, 1.0);
                    
                    // ‰ΩøÁî®Á∑©ÂãïÊõ≤Á∑öËÆìË∑ùÈõ¢ËÆäÂåñÊõ¥Ëá™ÁÑ∂
                    distanceFactor = this.easeOutQuad(distanceFactor);
                    
                    // Ë®≠ÂÆöÁõÆÊ®ôË∑ùÈõ¢‰øÇÊï∏
                    dotData.targetMouseDistance = distanceFactor;
                });
            }

            updateDistanceInteractionAnimation() {
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // Ë∑ùÈõ¢‰∫íÂãïÂïüÁî®ÔºöÂπ≥ÊªëÈÅéÊ∏°Âà∞ÁõÆÊ®ôË∑ùÈõ¢‰øÇÊï∏
                        const delta = dotData.targetMouseDistance - dotData.mouseDistance;
                        dotData.mouseDistance += delta * this.DISTANCE_LERP_SPEED;
                        
                        // Ë®àÁÆóÂü∫ÊñºË∑ùÈõ¢ÁöÑÁ∏ÆÊîæÂíåÈÄèÊòéÂ∫¶
                        // ‰ΩøÁî®ÂèçËΩâÁöÑË∑ùÈõ¢‰øÇÊï∏ÔºöË∑ùÈõ¢ËøëÊôÇ‰øÇÊï∏Â§ßÔºåË∑ùÈõ¢ÈÅ†ÊôÇ‰øÇÊï∏Â∞è
                        const proximityFactor = 1.0 - dotData.mouseDistance;
                        
                        // Á∏ÆÊîæ‰øÇÊï∏ÔºöÂæûÊúÄÂ∞èÁ∏ÆÊîæÂà∞1.0
                        dotData.distanceScale = this.MIN_SCALE_FACTOR + (1.0 - this.MIN_SCALE_FACTOR) * proximityFactor;
                        
                        // ÈÄèÊòéÂ∫¶‰øÇÊï∏ÔºöÂæûÊúÄÂ∞èÈÄèÊòéÂ∫¶Âà∞1.0
                        dotData.distanceOpacity = this.MIN_OPACITY_FACTOR + (1.0 - this.MIN_OPACITY_FACTOR) * proximityFactor;
                    } else {
                        // Ë∑ùÈõ¢‰∫íÂãïÈóúÈñâÔºö‰øùÊåÅÊ≠£Â∏∏Â§ßÂ∞èÂíåÈÄèÊòéÂ∫¶
                        dotData.mouseDistance = 0.0;
                        dotData.targetMouseDistance = 0.0;
                        dotData.distanceScale = 1.0;
                        dotData.distanceOpacity = 1.0;
                    }
                });
            }

            resetDistanceInteraction() {
                // ÈáçÁΩÆÊâÄÊúâÈªûÈªûÁöÑË∑ùÈõ¢‰øÇÊï∏
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // Ë∑ùÈõ¢‰∫íÂãïÂïüÁî®ÔºöÈáçÁΩÆÂà∞ÊúÄÈÅ†ÁãÄÊÖã
                        dotData.targetMouseDistance = 1.0;
                    } else {
                        // Ë∑ùÈõ¢‰∫íÂãïÈóúÈñâÔºöÈáçÁΩÆÂà∞Ê≠£Â∏∏ÁãÄÊÖã
                        dotData.targetMouseDistance = 0.0;
                    }
                });
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            // üéØ ================== Ë∑ùÈõ¢ÊÑüÊáâ‰∫íÂãïÁ≥ªÁµ±ÁµêÊùü ==================

            fadeInInteractiveDots() {
                // ‰∫íÂãïÈªûÈªûÁöÑÊ∑°ÂÖ•ÂãïÁï´
                const fadeInDuration = 1500; // 1.5ÁßíÊ∑°ÂÖ•
                const startTime = Date.now();
                
                this.interactiveDots.forEach((dotData, index) => {
                    const delay = index * 300; // ÊØèÂÄãÈªûÈåØÈñã0.3Áßí
                    
                    setTimeout(() => {
                        dotData.mesh.userData.isVisible = true;
                        // ÁÇ∫ÊØèÂÄãÈªûË®≠ÂÆöÁç®Á´ãÁöÑÂãïÁï´ÈñãÂßãÊôÇÈñì
                        dotData.mesh.userData.animationStartTime = Date.now();
                        
                        const animate = () => {
                            const elapsed = Date.now() - startTime - delay;
                            const progress = Math.max(0, Math.min(elapsed / fadeInDuration, 1));
                            
                            if (progress > 0) {
                                // Á∑©ÂãïÂáΩÊï∏Ôºöease-out
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                
                                // Âú®Ê∑°ÂÖ•ÈÅéÁ®ã‰∏≠Â∞±ÈñãÂßãË®àÁÆóÂëºÂê∏ÂãïÁï´ÔºåÁ¢∫‰øùÁµ≤ÊªëÈäúÊé•
                                const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                                const phase = index * Math.PI * 0.8;
                                const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                                
                                // üéØ Êõ¥Êñ∞Ë∑ùÈõ¢‰∫íÂãïÂãïÁï´ÔºàÊ∑°ÂÖ•ÊúüÈñì‰πüÈúÄË¶ÅÔºâ
                                this.updateDistanceInteractionAnimation();
                                
                                // Ê∑°ÂÖ•ÊúüÈñìÔºöÈÄèÊòéÂ∫¶ = Ê∑°ÂÖ•ÈÄ≤Â∫¶ √ó Âü∫Á§éÈÄèÊòéÂ∫¶ √ó ÂëºÂê∏‰øÇÊï∏ √ó hover‰πòÊï∏ √ó Ë∑ùÈõ¢ÈÄèÊòéÂ∫¶ √ó ÈÅéÊ∏°ÈÄèÊòéÂ∫¶
                                const targetOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                                const opacity = targetOpacity * easeProgress;
                                dotData.mesh.material.opacity = opacity;
                                
                                // Â§ßÂ∞èÂëºÂê∏ÊïàÊûúÔºåÂú®Ê∑°ÂÖ•ÊúüÈñì‰πüÂêåÊ≠•ÈñãÂßãÔºå‰∏¶ËÄÉÊÖÆÊâÄÊúâÁ∏ÆÊîæÊïàÊûú
                                const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                                // ÁµÑÂêàÊâÄÊúâÁ∏ÆÊîæÊïàÊûúÔºöÂëºÂê∏ √ó hover √ó Êåâ‰∏ã √ó Ë∑ùÈõ¢
                                const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                                const finalScale = hoverScale * dotData.pressedScale * dotData.distanceScale;
                                const scaleFactor = finalScale * easeProgress + (1 - easeProgress);
                                dotData.mesh.scale.setScalar(scaleFactor);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else {
                                // Ê∑°ÂÖ•ÂÆåÊàêÔºåÂàáÊèõÂà∞Á¥îÂëºÂê∏ÂãïÁï´
                                this.startBreathingAnimation(dotData, index);
                            }
                        };
                        animate();
                    }, delay);
                });
            }

            startBreathingAnimation(dotData, index) {
                // Ê°åÊ©üÁâàÂíåË°åÂãïÁâàÁöÑÁµ±‰∏ÄÂëºÂê∏ÂãïÁï´Ôºå‰ΩøÁî®ÊØèÂÄãÈªûÁç®Á´ãÁöÑÊôÇÈñìÂü∫Ê∫ñ
                const breathAnimate = () => {
                    if (!dotData.mesh.userData.isVisible) return;
                    
                    // üéØ Êõ¥Êñ∞Ë∑ùÈõ¢‰∫íÂãïÂãïÁï´
                    this.updateDistanceInteractionAnimation();
                    
                    // ‰ΩøÁî®ÊØèÂÄãÈªûÁç®Á´ãÁöÑÂãïÁï´ÈñãÂßãÊôÇÈñìÔºåÁ¢∫‰øùÁµ≤ÊªëÈäúÊé•
                    const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                    const phase = index * Math.PI * 0.8; // ÊØèÂÄãÈªûÊúâ‰∏çÂêåÁöÑÁõ∏‰Ωç
                    
                    // ÈÄèÊòéÂ∫¶ÂëºÂê∏ÊïàÊûúÔºöÂü∫Á§éÂëºÂê∏ √ó hover‰πòÊï∏ √ó Ë∑ùÈõ¢ÈÄèÊòéÂ∫¶ √ó ÈÅéÊ∏°ÈÄèÊòéÂ∫¶
                    const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                    const currentOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                    dotData.mesh.material.opacity = currentOpacity;
                    
                    // Â§ßÂ∞èÂëºÂê∏ÊïàÊûúÔºöÁµÑÂêàÂëºÂê∏„ÄÅhover„ÄÅÊåâ‰∏ãÂíåË∑ùÈõ¢ÊïàÊûú
                    const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                    const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                    const scaleFactor = hoverScale * dotData.pressedScale * dotData.distanceScale;
                    dotData.mesh.scale.setScalar(scaleFactor);
                    
                    requestAnimationFrame(breathAnimate);
                };
                breathAnimate();
            }

            // üî¥ ================== ‰∫íÂãïÈªûÈªûÁ≥ªÁµ±ÁµêÊùü ==================

            // üîç ================== Â±ÄÈÉ®ÂúñÁ≥ªÁµ± ==================

            // üïπÔ∏è Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂ÊñπÊ≥ï
            updateDetailViewControl(inputX, inputY) {
                // Êõ¥Êñ∞Â±ÄÈÉ®Ë¶ñËßíÁöÑÊªëÈº†‰ΩçÁΩÆ
                this.detailViewMouse.x = inputX;
                this.detailViewMouse.y = inputY;
                
                // Ë®àÁÆóÈÇäÁïåË∂ÖÂá∫ÊïàÊûúÁöÑÂÅèÁßªÈáè - Áõ∏ÂèçÊñπÂêë
                const offsetX = -inputX * this.DETAIL_VIEW_INTENSITY;  // XËª∏Áõ∏Âèç
                const offsetY = -inputY * this.DETAIL_VIEW_INTENSITY;  // YËª∏Áõ∏Âèç
                
                // ÊáâÁî®ÈÇäÁïåÈôêÂà∂
                const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                this.detailViewOffset.x = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
                this.detailViewOffset.y = Math.max(-maxOffset, Math.min(maxOffset, offsetY));
                
                // Êõ¥Êñ∞Â†¥ÊôØ‰ΩçÁΩÆ‰ª•ÂØ¶ÁèæÈÇäÁïåË∂ÖÂá∫ÊïàÊûú
                if (this.currentDetailDot) {
                    const detailLayer = this.detailLayers.find(layer => 
                        layer.detailInfo.dotId === this.currentDetailDot.config.id
                    );
                    
                    if (detailLayer) {
                        const detailMesh = detailLayer.mesh;
                        
                        // Ë®àÁÆóÂü∫Á§éÂ†¥ÊôØ‰ΩçÁΩÆÔºàÂ±ÄÈÉ®Âúñ‰∏≠ÂøÉÂ∞çÈΩäÁï´Èù¢‰∏≠ÂøÉÔºâ
                        const baseSceneX = -detailMesh.position.x;
                        const baseSceneY = -detailMesh.position.y;
                        
                        // ÊáâÁî®ÈÇäÁïåË∂ÖÂá∫ÂÅèÁßª
                        this.scene.position.x = baseSceneX + this.detailViewOffset.x;
                        this.scene.position.y = baseSceneY + this.detailViewOffset.y;
                        
                        // ÂèØÈÅ∏ÔºöÊ∑ªÂä†Ë™øË©¶Ë≥áË®ä
                        // console.log(`üïπÔ∏è Â±ÄÈÉ®Ë¶ñËßíÊéßÂà∂: offset(${this.detailViewOffset.x.toFixed(3)}, ${this.detailViewOffset.y.toFixed(3)})`);
                    }
                }
            }

            resetDetailViewControl() {
                // ÈáçÁΩÆÂ±ÄÈÉ®Ë¶ñËßíÊéßÂà∂
                this.detailViewMouse.x = 0;
                this.detailViewMouse.y = 0;
                this.detailViewOffset.x = 0;
                this.detailViewOffset.y = 0;
            }

            // üî¥ ================== ÈªûÈªûÈÅéÊ∏°ÈÄèÊòéÂ∫¶ÊéßÂà∂Á≥ªÁµ± ==================

            updateDotsTransitionOpacity(animationType, progress) {
                // Êõ¥Êñ∞ÈªûÈªûÂú®ÊîæÂ§ßÁ∏ÆÂ∞èÈÅéÁ®ã‰∏≠ÁöÑÈÄèÊòéÂ∫¶
                if (!this.interactiveDots.length) return;

                let transitionOpacity = 1.0;

                if (animationType === 'zoomIn') {
                    // ÊîæÂ§ßÊôÇÊ∑°Âá∫ÔºöÈÄ≤Â∫¶ 0.0‚Üí0.5 ÈÄèÊòéÂ∫¶ 100%‚Üí0%ÔºåÈÄ≤Â∫¶ 0.5‚Üí1.0 ÈÄèÊòéÂ∫¶‰øùÊåÅ 0%
                    if (progress <= 0.5) {
                        transitionOpacity = 1.0 - (progress / 0.5); // Âæû1.0ÈÅéÊ∏°Âà∞0.0
                    } else {
                        transitionOpacity = 0.0; // ‰øùÊåÅÈÄèÊòé
                    }
                } else if (animationType === 'zoomOut') {
                    // Á∏ÆÂ∞èÊôÇÊ∑°ÂÖ•ÔºöÈÄ≤Â∫¶ 0.0‚Üí0.5 ÈÄèÊòéÂ∫¶‰øùÊåÅ 0%ÔºåÈÄ≤Â∫¶ 0.5‚Üí1.0 ÈÄèÊòéÂ∫¶ 0%‚Üí100%
                    if (progress <= 0.5) {
                        transitionOpacity = 0.0; // ‰øùÊåÅÈÄèÊòé
                    } else {
                        transitionOpacity = (progress - 0.5) / 0.5; // Âæû0.0ÈÅéÊ∏°Âà∞1.0
                    }
                }

                // ÊáâÁî®Âà∞ÊâÄÊúâÈªûÈªû
                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = transitionOpacity;
                });

                // ÂèØÈÅ∏ÔºöÊ∑ªÂä†Ë™øË©¶Ë≥áË®ä
                // console.log(`üî¥ ÈªûÈªûÈÅéÊ∏°ÈÄèÊòéÂ∫¶: ${animationType}, progress=${progress.toFixed(3)}, opacity=${transitionOpacity.toFixed(3)}`);
            }

            resetDotsTransitionOpacity(opacity) {
                // ÈáçÁΩÆÊâÄÊúâÈªûÈªûÁöÑÈÅéÊ∏°ÈÄèÊòéÂ∫¶
                if (!this.interactiveDots.length) return;

                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = opacity;
                });

                console.log(`üî¥ ÈáçÁΩÆÈªûÈªûÈÄèÊòéÂ∫¶: ${(opacity * 100).toFixed(0)}%`);
            }

            // üî¥ ================== ÈªûÈªûÈÅéÊ∏°ÈÄèÊòéÂ∫¶ÊéßÂà∂Á≥ªÁµ±ÁµêÊùü ==================
        }

        // ÂÖ®ÂüüËÆäÊï∏Áî®ÊñºÂ≠òÂèñParallaxViewerÂØ¶‰æã
        let parallaxViewerInstance = null;

        // ËøîÂõûÊåâÈàïËôïÁêÜÂáΩÊï∏
        function handleBackButton() {
            if (parallaxViewerInstance) {
                if (parallaxViewerInstance.viewState === 'detail') {
                    // Â±ÄÈÉ®Ë¶ñËßíÔºöËøîÂõû‰∏ªË¶ñËßí
                    parallaxViewerInstance.returnToMainView();
                } else {
                    // ‰∏ªË¶ñËßíÔºöËøîÂõûÈ¶ñÈ†Å
                    window.location.href = '#';
                }
            } else {
                // È†êË®≠Ë°åÁÇ∫
                window.location.href = '#';
            }
        }

        // üéÆ ÈôÄËû∫ÂÑÄÊ¨äÈôêËôïÁêÜÂáΩÊï∏
        async function handleGyroPermission() {
            if (parallaxViewerInstance) {
                console.log('üéÆ ‰ΩøÁî®ËÄÖÈªûÊìäÈôÄËû∫ÂÑÄÊ¨äÈôêÊåâÈàï');
                
                const success = await parallaxViewerInstance.startGyroControl();
                if (success) {
                    // Èö±ËóèÊ¨äÈôêÊåâÈàï
                    const button = document.getElementById('gyro-permission-button');
                    if (button) {
                        button.style.display = 'none';
                    }
                    
                    // ÂàáÊèõÂà∞ÈôÄËû∫ÂÑÄÊéßÂà∂Ê®°Âºè
                    parallaxViewerInstance.currentControlMode = 'gyro';
                    console.log('üéÆ ÊàêÂäüÂïüÁî®ÈôÄËû∫ÂÑÄÊéßÂà∂');
                    
                    // È°ØÁ§∫ÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï
                    parallaxViewerInstance.showResetGyroButton();
                } else {
                    // Ê¨äÈôêË¢´ÊãíÁµïÔºå‰øùÊåÅÊåáÈáùÊéßÂà∂Ê®°Âºè
                    parallaxViewerInstance.currentControlMode = 'pointer';
                    console.log('üéÆ ÈôÄËû∫ÂÑÄÊ¨äÈôêË¢´ÊãíÁµïÔºå‰ΩøÁî®ÊåáÈáùÊéßÂà∂Ê®°Âºè');
                }
            }
        }

        // üéÆ ÈáçÁΩÆÈôÄËû∫ÂÑÄËôïÁêÜÂáΩÊï∏
        function handleResetGyro() {
            if (parallaxViewerInstance) {
                console.log('üéÆ ‰ΩøÁî®ËÄÖÈªûÊìäÈáçÁΩÆÈôÄËû∫ÂÑÄÊåâÈàï');
                
                const success = parallaxViewerInstance.resetGyroBase();
                if (success) {
                    // È°ØÁ§∫ÊàêÂäüÊèêÁ§∫ÔºàÂèØÈÅ∏Ôºâ
                    console.log('üéÆ ÈôÄËû∫ÂÑÄÂü∫Ê∫ñÂÄºÈáçÁΩÆÊàêÂäü');
                } else {
                    // È°ØÁ§∫ÈåØË™§ÊèêÁ§∫ÔºàÂèØÈÅ∏Ôºâ
                    console.log('üéÆ ÈôÄËû∫ÂÑÄÈáçÁΩÆÂ§±ÊïóÔºåË´ãÁ¢∫‰øùÈôÄËû∫ÂÑÄÂ∑≤ÂïüÁî®');
                }
            }
        }

        // ÂàùÂßãÂåñÊáâÁî®Á®ãÂºè
        document.addEventListener('DOMContentLoaded', () => {
            parallaxViewerInstance = new ParallaxViewer();
            
            // üéÆ Ê†πÊìöË£ùÁΩÆÈ°ûÂûãÊ±∫ÂÆöÊòØÂê¶È°ØÁ§∫ÈôÄËû∫ÂÑÄÊ¨äÈôêÊåâÈàï
            if (parallaxViewerInstance.isMobile && 
                'DeviceOrientationEvent' in window && 
                parallaxViewerInstance.needsGyroPermission()) {
                
                const button = document.getElementById('gyro-permission-button');
                if (button) {
                    // Âª∂ÈÅ≤È°ØÁ§∫ÔºåËÆì‰ΩøÁî®ËÄÖÂÖàÈ´îÈ©óÂü∫Êú¨ÂäüËÉΩ
                    setTimeout(() => {
                        button.style.display = 'flex';
                    }, 3000); // 3ÁßíÂæåÈ°ØÁ§∫
                }
            } else if (parallaxViewerInstance.isMobile && 
                       'DeviceOrientationEvent' in window) {
                // ‰∏çÈúÄË¶ÅÊ¨äÈôêË´ãÊ±ÇÁöÑË£ùÁΩÆÔºåÁõ¥Êé•ÂïüÁî®ÈôÄËû∫ÂÑÄ
                parallaxViewerInstance.startGyroControl().then(success => {
                    if (success) {
                        parallaxViewerInstance.currentControlMode = 'gyro';
                        console.log('üéÆ Ëá™ÂãïÂïüÁî®ÈôÄËû∫ÂÑÄÊéßÂà∂ÔºàÁÑ°ÈúÄÊ¨äÈôêÔºâ');
                        
                        // Ëá™ÂãïÂïüÁî®ÈôÄËû∫ÂÑÄÂæåÔºåÂú®ËºâÂÖ•ÂÆåÊàêÊôÇÈ°ØÁ§∫ÈáçÁΩÆÊåâÈàï
                        // ÈáçÁΩÆÊåâÈàïÊúÉÂú® startLoadingFadeOutAndParallaxTransition ‰∏≠ËôïÁêÜ
                    }
                });
            }
        });


    </script>
</body>
</html>