<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>互動式視差網頁</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            /* 📱 確保html在方向變化時正確處理 */
            width: 100vw;
            height: 100vh;
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            overflow: hidden;
        }
        
        /* 📱 高解析螢幕支援：確保元素在高解析螢幕上清晰顯示 */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            /* 高解析螢幕優化 */
            * {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-rendering: optimizeLegibility;
            }
            
            /* 確保按鈕在高解析螢幕上邊緣清晰 */
            #back-button, #fullscreen-button, #reset-view-button {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
            
            /* 確保載入動畫在高解析螢幕上流暢 */
            .elegant-spinner, .spinner-ring {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
            
            /* 確保粒子效果在高解析螢幕上清晰 */
            .particle {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a1a);
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* 📱 確保body在方向變化時正確處理 */
            width: 100vw;
            height: 100vh;
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            /* 📱 確保容器在方向變化時正確處理 */
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* 🎭 三層級架構 Z-Index 定義 */
        /* 層級 3: UI 層 (z-index: 3000+) */
        #back-button {
            position: fixed;
            top: 25px;
            left: 25px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI 層：最上層 */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #back-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #back-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #back-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #back-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: translateX(-1px);
        }

        #back-button:active svg {
            stroke: #f4e3d4;
            transform: translateX(-1px) scale(0.95);
        }

        /* 全螢幕按鈕 - 在所有裝置顯示 */
        #fullscreen-button {
            position: fixed;
            top: 25px;
            right: 25px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI 層：最上層 */
            display: flex; /* 在所有裝置顯示 */
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #fullscreen-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #fullscreen-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #fullscreen-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #fullscreen-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: scale(1.1);
        }

        #fullscreen-button:active svg {
            stroke: #f4e3d4;
            transform: scale(0.95);
        }

        /* 重置視角按鈕 - 與其他按鈕保持一致的風格 */
        #reset-view-button {
            position: fixed;
            top: 25px;
            right: 80px; /* 在全螢幕按鈕左邊 */
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI 層：最上層 */
            display: none; /* 預設隱藏，與全螢幕按鈕邏輯一致 */
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #reset-view-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #reset-view-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #reset-view-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #reset-view-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: rotate(180deg);
        }

        #reset-view-button:active svg {
            stroke: #f4e3d4;
            transform: rotate(180deg) scale(0.95);
        }

        /* 層級 2: 載入層 (z-index: 2000+) */
        #loading-cover {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 2000; /* 載入層：中間層 */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #loading-cover.fade-in {
            opacity: 1;
            transition: opacity 0.5s ease; /* 明確設定淡入時間 */
        }

        @keyframes fadeOut { 
            0% { opacity: 1; } 
            80% { opacity: 0.15; } 
            100% { opacity: 0; } 
        }
        
        #loading-cover.fade-out { 
            animation: fadeOut 0.9s ease-out forwards; 
            will-change: opacity;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2001; /* 載入層：載入動畫 */
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        #loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-container {
            position: relative;
            padding: 40px;
        }



        .elegant-spinner {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
        }

        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
        }

        .spinner-ring:nth-child(1) {
            border-top: 2px solid #dc9c3b;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .spinner-ring:nth-child(2) {
            border-right: 2px solid #d1936b;
            transform: scale(0.8);
            filter: drop-shadow(0 0 6px rgba(209, 147, 107, 0.4));
        }

        .spinner-ring:nth-child(3) {
            border-bottom: 2px solid #f4e3d4;
            transform: scale(0.6);
            filter: drop-shadow(0 0 4px rgba(244, 227, 212, 0.3));
        }

        .loading-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 20px;
        }

        .dot {
            width: 5px;
            height: 5px;
            background: #dc9c3b;
            border-radius: 50%;
            animation: dotPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(220, 156, 59, 0.5);
        }

        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.3s; }
        .dot:nth-child(3) { animation-delay: 0.6s; }

        .loading-particles {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 200px;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            opacity: 0;
            animation: particleFloat 4s linear infinite, particleGlow 2s ease-in-out infinite alternate;
            bottom: 5px; /* 初始位置在容器底部外面 */
            filter: brightness(1.2);
        }

        @keyframes titleGlow {
            0% { 
                text-shadow: 0 0 20px rgba(244, 227, 212, 0.5);
                transform: scale(1) translateZ(0);
            }
            100% { 
                text-shadow: 0 0 30px rgba(244, 227, 212, 0.8), 0 0 40px rgba(220, 156, 59, 0.3);
                transform: scale(1.02) translateZ(0);
            }
        }

        @keyframes elegantSpin {
            0% { transform: rotate(0deg) translateZ(0); }
            100% { transform: rotate(360deg) translateZ(0); }
        }

        @keyframes dotPulse {
            0%, 100% { 
                transform: scale(1) translateZ(0); 
                opacity: 0.3; 
            }
            50% { 
                transform: scale(1.3) translateZ(0); 
                opacity: 1; 
                box-shadow: 0 0 15px rgba(220, 156, 59, 0.8);
            }
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(0) scale(0) translateZ(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(-20px) scale(1) translateZ(0);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-250px) scale(1) translateZ(0);
                opacity: 0;
            }
        }



        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2002; /* 載入層：錯誤訊息 */
        }

        /* 🎮 陀螺儀授權按鈕樣式 - 極簡風格 */
        .gyro-permission {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 3001; /* 在返回按鈕之上，但在載入層之下 */
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            pointer-events: none; /* 修正：隱藏時不阻擋互動 */
        }

        .gyro-permission.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* 顯示時才可互動 */
        }

        .gyro-permission-content {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            max-width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .gyro-permission-icon {
            font-size: 24px;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .gyro-permission-title {
            font-size: 16px;
            font-weight: bold;
            color: #f4e3d4;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(244, 227, 212, 0.3);
        }

        .gyro-permission-desc {
            font-size: 12px;
            color: rgba(244, 227, 212, 0.7);
            line-height: 1.4;
            margin-bottom: 16px;
        }

        .gyro-permission-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .gyro-permission-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #f4e3d4;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            min-width: 60px;
        }

        .gyro-permission-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(220, 156, 59, 0.4);
        }

        .gyro-permission-btn.primary {
            background: rgba(220, 156, 59, 0.2);
            border-color: rgba(220, 156, 59, 0.5);
        }

        .gyro-permission-btn.primary:hover {
            background: rgba(220, 156, 59, 0.3);
            border-color: rgba(220, 156, 59, 0.7);
            box-shadow: 0 0 20px rgba(220, 156, 59, 0.6);
        }

        /* 行動裝置適配 */
        @media (max-width: 768px) {
            .gyro-permission {
                bottom: 20px;
                right: 20px;
                left: 20px;
            }
            
            .gyro-permission-content {
                max-width: none;
                padding: 16px;
            }
            
            .gyro-permission-buttons {
                flex-direction: column;
                gap: 6px;
            }
            
            .gyro-permission-btn {
                padding: 10px 16px;
                font-size: 14px;
            }
        }

        #error-message {
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            max-width: 80%;
            display: none;
        }



        /* 層級 1: 內容層 (z-index: 1000+) */
        #canvas {
            display: block;
            z-index: 1000; /* 內容層：最下層 */
            width: 100vw;
            height: 100vh;
            /* 📱 高解析螢幕支援：確保canvas在高解析螢幕上清晰 */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        #loading-canvas {
            display: block;
            z-index: 2000; /* 載入層 */
            width: 100vw;
            height: 100vh;
            /* 📱 高解析螢幕支援：確保載入canvas在高解析螢幕上清晰 */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* 純觸控裝置：禁用hover效果（僅限於沒有滑鼠的裝置） */
        @media (hover: none) and (pointer: coarse) and (max-width: 1024px) {
            /* 觸控裝置：調整過渡動畫時間，讓點擊效果更明顯 */
            #back-button, #fullscreen-button, #reset-view-button {
                transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            }
            
            #back-button svg, #fullscreen-button svg, #reset-view-button svg {
                transition: transform 0.15s ease, filter 0.2s ease;
            }
            

            
            /* 觸控裝置：加強active狀態的視覺回饋，更明顯的效果 */
            #back-button:active, #fullscreen-button:active, #reset-view-button:active {
                background: rgba(255, 255, 255, 0.35);
                border-color: rgba(244, 227, 212, 0.7);
                transform: translateY(1px) scale(0.85);
                box-shadow: 
                    0 1px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 3px rgba(244, 227, 212, 0.3),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.1s ease;
            }
            
            #back-button:active svg, #fullscreen-button:active svg, #reset-view-button:active svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
                transform: scale(0.85);
                transition: all 0.1s ease;
            }
        }

        /* 手機裝置：額外的觸控優化 */
        @media (max-width: 480px) {
            #back-button, #fullscreen-button, #reset-view-button {
                transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            }
            
            #back-button svg, #fullscreen-button svg, #reset-view-button svg {
                transition: transform 0.15s ease, filter 0.2s ease;
            }
            
            #back-button:active, #fullscreen-button:active, #reset-view-button:active {
                background: rgba(255, 255, 255, 0.35);
                border-color: rgba(244, 227, 212, 0.7);
                transform: translateY(1px) scale(0.85);
                box-shadow: 
                    0 1px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 3px rgba(244, 227, 212, 0.3),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.1s ease;
            }
            
            #back-button:active svg, #fullscreen-button:active svg, #reset-view-button:active svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
                transform: scale(0.85);
                transition: all 0.1s ease;
            }
        }

        /* JavaScript檢測的觸控裝置優化 */
        .touch-device #back-button,
        .touch-device #fullscreen-button,
        .touch-device #reset-view-button {
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
        }
        
        .touch-device #back-button svg,
        .touch-device #fullscreen-button svg,
        .touch-device #reset-view-button svg {
            transition: transform 0.15s ease, filter 0.2s ease;
        }
        
        .touch-device #back-button:hover,
        .touch-device #fullscreen-button:hover,
        .touch-device #reset-view-button:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: none;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
        }
        
        .touch-device #back-button:hover svg,
        .touch-device #fullscreen-button:hover svg,
        .touch-device #reset-view-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
            transform: none;
        }
        
        .touch-device #back-button:active,
        .touch-device #fullscreen-button:active,
        .touch-device #reset-view-button:active {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(244, 227, 212, 0.7);
            transform: translateY(1px) scale(0.85);
            box-shadow: 
                0 1px 4px rgba(0, 0, 0, 0.3),
                0 0 0 3px rgba(244, 227, 212, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.1s ease;
        }
        
        .touch-device #back-button:active svg,
        .touch-device #fullscreen-button:active svg,
        .touch-device #reset-view-button:active svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
            transform: scale(0.85);
            transition: all 0.1s ease;
        }



        @media (max-width: 768px) {
            #back-button {
                width: 40px;
                height: 40px;
                top: 20px;
                left: 20px;
                border-radius: 50%;
            }
            
            #back-button svg {
                width: 18px;
                height: 18px;
            }
            
            #reset-view-button {
                width: 40px;
                height: 40px;
                bottom: 20px;
                left: 20px;
            }
            
            #reset-view-button svg {
                width: 18px;
                height: 18px;
            }
        }

        /* 行動裝置：調整全螢幕按鈕大小 */
        @media (max-width: 1024px) {
            #fullscreen-button {
                width: 44px;
                height: 44px;
                top: 25px;
                right: 25px;
            }
            
            #fullscreen-button svg {
                width: 20px;
                height: 20px;
            }
        }

        /* 小螢幕行動裝置：調整全螢幕按鈕大小 */
        @media (max-width: 768px) {
            #fullscreen-button {
                width: 40px;
                height: 40px;
                top: 20px;
                right: 20px;
            }
            
            #fullscreen-button svg {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 768px) {
            .loading-container {
                padding: 20px;
            }
            
            .elegant-spinner {
                width: 60px;
                height: 60px;
                margin: 0 auto 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading-cover">
            <canvas id="loading-canvas"></canvas>
        </div>
        
        <div id="loading">
            <div class="loading-container">
                <div class="loading-particles" id="particles"></div>
                <div class="elegant-spinner">
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                </div>
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>
        
        <div id="error-message">
            <h3>⚠️ 載入錯誤</h3>
            <p>請使用本地伺服器開啟此網頁以避免 CORS 問題</p>
            <br>
            <p><strong>建議解決方案：</strong></p>
            <p>1. 使用 Python: <code>python -m http.server 8000</code></p>
            <p>2. 使用 Node.js: <code>npx http-server</code></p>
            <p>3. 使用 VS Code Live Server 擴充功能</p>
        </div>
        
        <button id="back-button" onclick="handleBackButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
        </button>

        <!-- 全螢幕按鈕 - 所有裝置可用 -->
        <button id="fullscreen-button" onclick="handleFullscreenButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
        </button>

        <!-- 重置視角按鈕 -->
        <button id="reset-view-button" onclick="handleResetViewButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                <path d="M21 3v5h-5"/>
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                <path d="M3 21v-5h5"/>
            </svg>
        </button>

        <!-- 🎮 iOS陀螺儀授權按鈕 - 極簡風格 -->
        <div id="gyro-permission" class="gyro-permission">
            <div class="gyro-permission-content">
                <div class="gyro-permission-icon">🎮</div>
                <div class="gyro-permission-title">陀螺儀控制</div>
                <div class="gyro-permission-desc">點擊啟用以獲得最佳互動體驗</div>
                <div class="gyro-permission-buttons">
                    <button id="enable-gyro-btn" class="gyro-permission-btn primary">啟用</button>
                </div>
            </div>
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ParallaxViewer {
            constructor() {
                // 🎭 三層級架構系統
                this.uiLayer = null;           // 最上層：UI 控制元素
                this.loadingLayer = null;      // 中間層：封面圖與載入動畫
                this.contentLayer = null;      // 最下層：主要內容圖層組
                
                // Three.js 場景系統
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.loadingScene = null;
                this.loadingCamera = null;
                this.loadingRenderer = null;
                
                // 圖層管理
                this.layers = [];              // 主要內容圖層 (7_BG~1_RabbitFornt)
                this.mainLayerGroup = null;    // 主要圖層組容器
                this.dotsGroup = null;         // 互動點點容器
                this.detailGroup1 = null;      // 局部圖容器1
                this.detailGroup2 = null;      // 局部圖容器2
                this.detailGroup3 = null;      // 局部圖容器3
                this.detailLayers = [];        // 局部圖層陣列
                
                // 🎯 視角狀態管理
                this.viewState = 'main';       // 'main' | 'detail'
                this.currentDetailDot = null;  // 當前放大的點點
                this.isTransitioning = false;  // 是否正在過渡動畫中
                
                // 🎯 相機變換參數
                this.originalCameraPosition = { x: 0, y: 0, z: 5 };
                // targetCameraPosition 將在需要時動態計算，不再使用固定值
                this.originalScenePosition = { x: 0, y: 0, z: 0 };
                this.targetScenePosition = { x: 0, y: 0, z: 0 };
                
                // 🕹️ 局部視角控制參數
                this.DETAIL_VIEW_INTENSITY = 0.16;    // 局部視角移動強度 (建議範圍: 0.05-0.3)
                this.DETAIL_VIEW_BOUNDARY = 0.26;      // 邊界超出範圍 (相對於圖片大小)
                this.detailViewMouse = { x: 0, y: 0 }; // 局部視角的滑鼠位置
                this.detailViewOffset = { x: 0, y: 0 }; // 局部視角的偏移量
                
                // 🌟 局部圖羽化效果參數
                this.FEATHER_MAIN_VIEW = 5.0;          // 主視角羽化強度 (建議範圍: 0.5-1.0)
                this.FEATHER_DETAIL_VIEW = 0.1;        // 局部視角羽化強度 (建議範圍: 0.0-0.3)
                this.FEATHER_TRANSITION_RANGE = 0.5;   // 羽化影響範圍 (建議範圍: 0.2-0.5)
                
                // 🌫️ 過渡模糊效果參數
                this.TRANSITION_BLUR_STRENGTH = 3;      // 過渡模糊強度 (0-20，建議值：5-15)
                
                // 🔍 局部視角放大設定
                this.DETAIL_ZOOM_SCALE = 4.5;           // 局部視角放大倍率 (建議範圍: 2.0-10.0，預設5.0=500%)
                this.interactiveDots = [];     // 互動點點陣列
                this.raycaster = null;         // 點擊檢測器
                this.mouseVector = null;       // 滑鼠向量
                this.mouse = { x: 0, y: 0 };
                this.targetMouse = { x: 0, y: 0 }; // 目標滑鼠位置
                this.currentMouse = { x: 0, y: 0 }; // 當前插值後的滑鼠位置
                this.mouseInsidePage = true; // 滑鼠是否在頁面內
                this.mouseJustReentered = false; // 滑鼠是否剛重新進入頁面
                this.mouseVelocity = { x: 0, y: 0 }; // 滑鼠移動速度
                this.inertiaTarget = { x: 0, y: 0 }; // 慣性目標位置
                this.isInertiaActive = false; // 是否正在執行慣性緩衝
                this.orientation = { x: 0, y: 0 };
                // 🎛️ 螢幕方向自動轉換機制
                this.currentOrientation = this.getScreenOrientation();
                this.initialOrientation = this.currentOrientation; // 儲存初始方向
                this.baseX = null;           // 統一的X軸基準值（保留向後相容）
                this.baseY = null;           // 統一的Y軸基準值（保留向後相容）
                
                // 新的陀螺儀基準值（原始角度）
                this.baseAlpha = null;       // 水平旋轉基準值
                this.baseBeta = null;        // 前後俯仰基準值  
                this.baseGamma = null;       // 左右傾斜基準值
                this.smoothedDelta = { x: 0, y: 0 }; // 平滑後的差值
                this.SMOOTH_ALPHA = 0.15;    // 低通濾波係數
                
                // 🎮 混合控制系統
                this.currentControlMode = 'gyro';     // 'gyro' | 'pointer'
                this.gyroActive = false;              // 陀螺儀是否已啟用
                this.lastPointerTime = 0;             // 最後滑鼠活動時間
                this.currentOffsetX = 0;              // 當前X軸偏移
                this.currentOffsetY = 0;              // 當前Y軸偏移
                this.controlTransitionProgress = 0;   // 控制模式切換進度
                this.requiresPermission = false;      // 是否需要iOS授權
                this.isMobile = this.detectMobile();
                this.loadingComplete = false;
                this.loadedImages = 0;
                this.totalImages = 0;
                this.errorCount = 0;
                this.loadingCoverLoaded = false;
                this.coverFadeOutComplete = false;
                this.parallaxTransitionProgress = 0; // 0 = 中心位置, 1 = 滑鼠位置
                
                // 🎛️ 統一視差強度控制 - 調整這些數值來改變整體視差效果
                this.PARALLAX_INTENSITY = 0.27; // 主要控制參數：控制滑鼠/傾斜輸入的影響程度 (建議範圍: 0.05-0.3)
                this.DEPTH_SENSITIVITY = 0.5;  // 深度圖敏感度：控制深度差異的視差幅度 (建議範圍: 0.1-0.5)
                
                // 📱 行動裝置陀螺儀控制
                this.GYRO_SENSITIVITY = 5.0;    // 陀螺儀靈敏度：控制裝置旋轉的敏感程度 (建議範圍: 0.5-2.0)
                // 移除 GYRO_INVERT_X，改用α控制水平旋轉，若需反向可在最終 deltaX 取負值
                
                // 🖼️ 統一圖片大小控制
                this.IMAGE_SCALE = 1.02;        // 圖片縮放比例：控制封面圖和主圖的大小 (建議範圍: 0.5-1.5)
                
                // 🫁 呼吸動畫控制
                this.BREATH_SPEED = 0.003;      // 呼吸速度係數：數值越大呼吸越快 (建議範圍: 0.001-0.005)
                
                // 🎯 距離感應互動控制
                this.DISTANCE_INTERACTION_ENABLED = !this.isMobile;  // 桌機版啟用，行動版關閉
                this.MAX_DISTANCE = 0.3;                   // 最大感應距離（相對於主圖寬度）
                this.MIN_SCALE_FACTOR = 0.6;               // 最遠時的最小縮放（60%）
                this.MIN_OPACITY_FACTOR = 0.5;             // 最遠時的最小透明度（50%）
                this.DISTANCE_LERP_SPEED = 0.5;            // 距離動畫過渡速度
                
                // 🔄 重置視角功能
                this.isResetting = false;                  // 是否正在重置視角
                this.lastRawX = 0;                         // 最新的原始X值
                this.lastRawY = 0;                         // 最新的原始Y值

                /*
                 * 📖 參數說明：
                 * 
                 * PARALLAX_INTENSITY (parallaxOffset 的乘數)：
                 * - 控制滑鼠移動或裝置傾斜對視差的影響程度
                 * - 數值越大，滑鼠移動時視差效果越明顯
                 * - 影響整體視差的"靈敏度"
                 * 
                 * DEPTH_SENSITIVITY (parallaxStrength)：
                 * - 控制深度圖中不同灰階值之間的視差差異
                 * - 數值越大，深度圖的白色和黑色區域視差差異越大
                 * - 影響視差的"深度感"
                 * 
                 * GYRO_SENSITIVITY：
                 * - 控制行動裝置陀螺儀的敏感程度
                 * - 數值越大，裝置旋轉時視差效果越明顯
                 * - 新版使用α(水平旋轉)控制X軸，β/γ(俯仰)控制Y軸
                 * 
                 * 新版陀螺儀控制說明：
                 * - 水平旋轉(α)：左右轉身 → X軸視差
                 * - 前後俯仰(β)：直立模式 → Y軸視差
                 * - 左右傾斜(γ)：橫向模式 → Y軸視差
                 * 
                 * 🎯 調整建議：
                 * - 想要更敏感的滑鼠控制 → 增加 PARALLAX_INTENSITY
                 * - 想要更敏感的陀螺儀控制 → 增加 GYRO_SENSITIVITY
                 * - 想要更強烈的深度效果 → 增加 DEPTH_SENSITIVITY  
                 * - 想要更細膩的效果 → 同時降低所有數值
                 */
                
                // 圖層資訊 - 按照從後到前的順序（7最後面，1最前面）
                this.layerInfo = [
                    { name: '0_7_BG' },        // 最底層背景
                    { name: '0_6_RabbitBack' }, // 後方兔子
                    { name: '0_5_Volume' },     // 體積霧
                    { name: '0_4_RabbitMain' }, // 主要兔子
                    { name: '0_3_Text' },       // 文字
                    { name: '0_2_Dust' },       // 塵埃（現在在文字之上）
                    { name: '0_1_RabbitFornt' } // 最前層兔子
                ];
                
                // 🔍 局部圖配置資料 - 與點點對應
                this.detailLayerInfo = [
                    { name: '1_0_All', dotId: 'dot1', group: 'detailGroup1' },
                    { name: '2_0_All', dotId: 'dot2', group: 'detailGroup2' },
                    { name: '3_0_All', dotId: 'dot3', group: 'detailGroup3' }
                ];
                
                this.init();
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       window.innerWidth <= 768;
            }

            // 🎛️ 簡化螢幕方向偵測（實時更新）
            updateScreenOrientation() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const isPortrait = h >= w;
                this.currentOrientation = isPortrait ? 'portrait-primary' : 'landscape-primary';
            }

            // 🎛️ 計算最短角度差（避免0↔360跳值）
            shortestAngleDiff(a, b) {
                let diff = (a - b + 540) % 360 - 180; // 取最短路徑
                return diff;
            }

            // 🎛️ 簡化陀螺儀映射邏輯（α控制水平旋轉）
            transformGyroData(dAlpha, dBeta, dGamma) {
                let x, y;
                
                if (this.currentOrientation.startsWith('portrait')) {
                    // 直立：α→X, β→Y
                    x = dAlpha;
                    y = dBeta;
                } else {
                    // 橫向：α→X, γ→Y（取反轉避免上下相反）
                    x = dAlpha;
                    y = -dGamma;
                }
                
                return { x, y };
            }

            // 🎮 檢測是否需要iOS授權
            checkPermissionRequired() {
                this.requiresPermission = typeof DeviceOrientationEvent !== 'undefined' && 
                                        typeof DeviceOrientationEvent.requestPermission === 'function';
                
                // 檢查是否已經授權過
                if (this.requiresPermission) {
                    const hasGranted = localStorage.getItem('gyroPermissionGranted');
                    if (hasGranted === 'true') {
                        console.log('📱 陀螺儀已授權，直接啟用');
                        return false; // 不需要顯示授權介面
                    }
                }
                
                return this.requiresPermission;
            }

            // 🎮 啟動陀螺儀控制
            async startGyroControl() {
                // 檢查是否需要授權
                if (this.checkPermissionRequired()) {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            console.log('❌ 陀螺儀授權被拒絕，使用滑鼠模式');
                            this.currentControlMode = 'pointer';
                            return false;
                        }
                        console.log('✅ 陀螺儀授權成功');
                        // 儲存授權狀態到本地
                        localStorage.setItem('gyroPermissionGranted', 'true');
                    } catch (error) {
                        console.error('❌ 陀螺儀授權失敗:', error);
                        this.currentControlMode = 'pointer';
                        return false;
                    }
                }

                // 註冊陀螺儀事件
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.gyroUpdate.bind(this));
                    this.gyroActive = true;
                    console.log('🎮 陀螺儀控制已啟用');
                    return true;
                }
                
                return false;
            }

            // 🎮 啟動滑鼠控制
            startPointerControl() {
                if (this.currentControlMode !== 'pointer') {
                    this.currentControlMode = 'pointer';
                    console.log('🖱️ 切換到滑鼠控制模式');
                }
                this.lastPointerTime = Date.now();
            }

            // 🎮 陀螺儀更新（新版：使用原始角度基準）
            gyroUpdate(event) {
                if (this.currentControlMode !== 'gyro') return;
                if (this.isResetting) return;   // 動畫期間完全忽略 gyro
                
                // 獲取原始陀螺儀數值
                const alpha = event.alpha || 0;
                const beta = event.beta || 0;
                const gamma = event.gamma || 0;

                // 第一次進來時或方向變化後建立基準值
                if (this.baseAlpha === null) {
                    this.baseAlpha = alpha;
                    this.baseBeta = beta;
                    this.baseGamma = gamma;
                    console.log('🎛️ 建立原始角度基準值:', {
                        orientation: this.currentOrientation,
                        baseAlpha: this.baseAlpha.toFixed(2),
                        baseBeta: this.baseBeta.toFixed(2),
                        baseGamma: this.baseGamma.toFixed(2)
                    });
                    return; // 建基準不輸出
                }

                // 計算角度差值（使用最短路徑避免跳值）
                const dAlpha = this.shortestAngleDiff(alpha, this.baseAlpha);
                const dBeta = beta - this.baseBeta;
                const dGamma = gamma - this.baseGamma;

                // 根據螢幕方向轉換為統一的X/Y軸
                const { x, y } = this.transformGyroData(dAlpha, dBeta, dGamma);

                // 設定靈敏度與 clamp
                let deltaX = THREE.MathUtils.clamp(x / 45 * this.GYRO_SENSITIVITY, -1, 1);
                let deltaY = THREE.MathUtils.clamp(y / 45 * this.GYRO_SENSITIVITY, -1, 1);

                // 低通濾波平滑處理
                this.smoothedDelta.x = this.smoothedDelta.x * (1 - this.SMOOTH_ALPHA) + deltaX * this.SMOOTH_ALPHA;
                this.smoothedDelta.y = this.smoothedDelta.y * (1 - this.SMOOTH_ALPHA) + deltaY * this.SMOOTH_ALPHA;

                // 更新當前偏移值
                this.currentOffsetX = this.smoothedDelta.x;
                this.currentOffsetY = this.smoothedDelta.y;
                
                // 🔍 調試資訊：每100次輸出一次，避免過多日誌
                if (!this.debugCounter) this.debugCounter = 0;
                this.debugCounter++;
                if (this.debugCounter % 100 === 0) {
                    console.log('🎛️ 陀螺儀調試 (新版):', {
                        orientation: this.currentOrientation,
                        raw: { alpha: alpha.toFixed(1), beta: beta.toFixed(1), gamma: gamma.toFixed(1) },
                        diff: { dAlpha: dAlpha.toFixed(1), dBeta: dBeta.toFixed(1), dGamma: dGamma.toFixed(1) },
                        transformed: { x: x.toFixed(1), y: y.toFixed(1) },
                        delta: { deltaX: deltaX.toFixed(3), deltaY: deltaY.toFixed(3) },
                        smoothed: { x: this.smoothedDelta.x.toFixed(3), y: this.smoothedDelta.y.toFixed(3) }
                    });
                }
            }

            // 🎮 滑鼠更新
            pointerUpdate(x, y) {
                if (this.currentControlMode !== 'pointer') return;
                if (this.isResetting) return; // 🔄 重置期間不處理滑鼠輸入

                // 使用原本的滑鼠位置計算公式：產生 -1 到 +1 的範圍
                const newX = (x / window.innerWidth) * 2 - 1;
                const newY = -(y / window.innerHeight) * 2 + 1; // Y軸反轉

                // 更新目標滑鼠位置（用於插值系統）
                this.targetMouse.x = newX;
                this.targetMouse.y = newY;
                
                // 🔧 修正：不要直接更新currentOffsetX/Y，讓updateMousePosition處理插值
                // this.currentOffsetX = newX;
                // this.currentOffsetY = newY;
            }

            // 🎮 控制模式監控
            monitorControlMode() {
                // 🔄 重置期間禁止強制切換模式
                if (this.isResetting) return;
                
                const now = Date.now();
                
                // 如果是指針模式且超過300ms無活動，切回陀螺儀
                if (this.currentControlMode === 'pointer' && 
                    now - this.lastPointerTime > 300 && 
                    this.gyroActive) {
                    this.currentControlMode = 'gyro';
                    console.log('🔄 自動切換回陀螺儀控制');
                }
                
                // 📱 行動裝置按鈕顯示邏輯
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // 全螢幕按鈕在所有裝置都顯示
                document.getElementById('fullscreen-button').style.display = 'flex';
                
                // 重置視角按鈕只在行動裝置且橫向時顯示
                if (isMobile && isLandscape) {
                    document.getElementById('reset-view-button').style.display = 'flex';
                } else {
                    document.getElementById('reset-view-button').style.display = 'none';
                }
            }

            // 統一的圖片尺寸計算函數
            calculateImageSize(texture = null) {
                // 如果有傳入 texture，使用其原始比例；否則使用預設比例
                let aspectRatio;
                if (texture && texture.image) {
                    aspectRatio = texture.image.width / texture.image.height;
                    // console.log(`使用圖片原始比例: ${texture.image.width}x${texture.image.height} (比例: ${aspectRatio.toFixed(3)})`);
                } else {
                    aspectRatio = 1920 / 1080; // 新的預設比例
                    // console.log(`使用預設比例: 1920x1080 (比例: ${aspectRatio.toFixed(3)})`);
                }
                
                const distance = 5;
                const fov = 75 * Math.PI / 180;
                const worldHeight = 2 * Math.tan(fov / 2) * distance;
                const worldWidth = worldHeight * (window.innerWidth / window.innerHeight);
                
                // 計算視窗長寬比
                const windowAspectRatio = window.innerWidth / window.innerHeight;
                
                let width, height;
                
                // 自動比較視窗長寬比與圖片長寬比，決定以寬度或高度為主
                if (windowAspectRatio >= aspectRatio) {
                    // 視窗比圖片寬（或相等），以寬度為主
                    width = worldWidth * this.IMAGE_SCALE;
                    height = width / aspectRatio;
                } else {
                    // 視窗比圖片窄，以高度為主
                    height = worldHeight * this.IMAGE_SCALE;
                    width = height * aspectRatio;
                }
                
                return { width, height };
            }

            setupLoadingScene() {
                // 建立載入場景
                this.loadingScene = new THREE.Scene();
                
                // 建立載入相機
                this.loadingCamera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.loadingCamera.position.z = 5;
                
                // 建立載入渲染器
                this.loadingRenderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('loading-canvas'),
                    antialias: true,
                    alpha: true
                });
                
                // 📱 高解析螢幕支援：設定像素比例
                const maxRatio = 2; // 兼顧效能的上限
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.loadingRenderer.setPixelRatio(pixelRatio);
                
                this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // 📱 確保載入canvas元素在DOM中的顯示尺寸正確
                const loadingCanvas = document.getElementById('loading-canvas');
                if (loadingCanvas) {
                    loadingCanvas.style.width = window.innerWidth + 'px';
                    loadingCanvas.style.height = window.innerHeight + 'px';
                }
                this.loadingRenderer.setClearColor(0x000000, 1);
            }

            loadLoadingCover() {
                console.log('開始載入封面圖片...');
                const loader = new THREE.TextureLoader();
                loader.load(
                    'images/Loading.png',
                    (texture) => {
                        console.log('封面圖片載入成功，開始淡入動畫');
                        this.createLoadingMesh(texture);
                        this.loadingCoverLoaded = true;
                        
                        // 封面圖載入完成後才開始淡入動畫
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            // 淡入動畫完成後開始載入其他圖片
                            setTimeout(() => {
                                console.log('封面圖淡入完成，開始載入其他圖片');
                                this.loadLayers();
                            }, 500); // 等待0.5秒淡入完成
                        }, 50); // 短暫延遲確保渲染完成
                    },
                    undefined,
                    (error) => {
                        console.warn('封面圖片載入失敗，使用黑色背景並開始載入其他圖片');
                        this.loadingCoverLoaded = true;
                        
                        // 即使載入失敗也要開始淡入和載入其他圖片
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            setTimeout(() => {
                                this.loadLayers();
                            }, 500);
                        }, 50);
                    }
                );
            }

            createLoadingMesh(texture) {
                // 使用統一的尺寸計算函數，傳入 texture 以獲取原始比例
                const { width, height } = this.calculateImageSize(texture);

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                // 存儲 texture 引用以便 resize 時重新計算
                mesh.userData.texture = texture;
                this.loadingScene.add(mesh);
            }

            init() {
                this.setupLoadingScene();
                this.setupScene();
                this.setupEventListeners();
                this.createLoadingParticles(); // 創建載入粒子效果
                this.randomizeSpinnerRings(); // 設定隨機旋轉效果
                
                // 🎛️ 初始化螢幕方向偵測
                this.updateScreenOrientation();
                
                // 🎭 設定層級引用
                this.loadingLayer = this.loadingScene; // 載入層：Three.js 場景
                this.uiLayer = document.getElementById('back-button'); // UI層：DOM 元素
                
                // 🎮 初始化混合控制系統
                this.initControlSystem();
                
                // 🔄 重置視角按鈕事件監聽器
                document.getElementById('reset-view-button').addEventListener('click', this.resetView.bind(this));
                
                this.loadLoadingCover(); // 優先載入封面圖
                this.animate();
            }

            // 🎮 初始化控制系統
            async initControlSystem() {
                if (this.isMobile) {
                    // 行動裝置：檢查是否需要iOS授權
                    if (this.checkPermissionRequired()) {
                        console.log('📱 檢測到iOS裝置，需要陀螺儀授權');
                        // 延遲顯示，避免擋住載入動畫
                        setTimeout(() => {
                            const gyroPermission = document.getElementById('gyro-permission');
                            gyroPermission.classList.add('show');
                        }, 2000); // 2秒後顯示
                    } else {
                        // Android或其他裝置：直接啟用陀螺儀
                        console.log('📱 直接啟用陀螺儀控制');
                        await this.startGyroControl();
                    }
                } else {
                    // 桌面裝置：使用滑鼠控制
                    console.log('🖥️ 桌面裝置，使用滑鼠控制');
                    this.currentControlMode = 'pointer';
                }
            }

            createLoadingParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;

                // 定義載入動畫的顏色調色板
                const colorPalette = [
                    {
                        bg: '#dc9c3b',
                        rgba: '220, 156, 59'
                    },
                    {
                        bg: '#d1936b', 
                        rgba: '209, 147, 107'
                    },
                    {
                        bg: '#f4e3d4',
                        rgba: '244, 227, 212'
                    }
                ];

                // 創建 10 個粒子
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // 隨機選擇顏色
                    const colorIndex = Math.floor(Math.random() * colorPalette.length);
                    const selectedColor = colorPalette[colorIndex];
                    
                    // 隨機大小 (1-2px)
                    const size = Math.random() * 1.6 + 0.8;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // 設定背景顏色
                    particle.style.background = selectedColor.bg;
                    
                    // 設定基礎發光效果
                    particle.style.boxShadow = `
                        0 0 6px rgba(${selectedColor.rgba}, 0.8),
                        0 0 12px rgba(${selectedColor.rgba}, 0.6),
                        0 0 18px rgba(${selectedColor.rgba}, 0.4),
                        0 0 24px rgba(${selectedColor.rgba}, 0.2)
                    `;
                    
                    // 隨機水平位置 (10%-90%)，避免貼邊
                    particle.style.left = (Math.random() * 80 + 10) + '%';
                    
                    // 隨機飄浮動畫延遲和持續時間
                    const floatDelay = Math.random() * 1.5;
                    const floatDuration = Math.random() * 3 + 2.5;
                    
                    // 隨機發光動畫延遲
                    const glowDelay = Math.random() * 0.5;
                    
                    // 創建唯一的發光動畫名稱
                    const glowAnimationName = `particleGlow${i}`;
                    
                    // 動態創建發光動畫的CSS規則
                    const glowKeyframes = `
                        @keyframes ${glowAnimationName} {
                            0% {
                                box-shadow: 
                                    0 0 6px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 12px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 18px rgba(${selectedColor.rgba}, 0.4),
                                    0 0 24px rgba(${selectedColor.rgba}, 0.2);
                                filter: brightness(1.2);
                            }
                            100% {
                                box-shadow: 
                                    0 0 10px rgba(${selectedColor.rgba}, 1),
                                    0 0 20px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 30px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 40px rgba(${selectedColor.rgba}, 0.3);
                                filter: brightness(1.5);
                            }
                        }
                    `;
                    
                    // 將動畫規則添加到頁面
                    const style = document.createElement('style');
                    style.textContent = glowKeyframes;
                    document.head.appendChild(style);
                    
                    // 設定複合動畫：飄浮 + 個別發光
                    particle.style.animation = `
                        particleFloat ${floatDuration}s linear infinite ${floatDelay}s,
                        ${glowAnimationName} 2s ease-in-out infinite alternate ${glowDelay}s
                    `;
                    
                    particlesContainer.appendChild(particle);
                }
            }

            randomizeSpinnerRings() {
                const spinnerRings = document.querySelectorAll('.spinner-ring');
                
                spinnerRings.forEach((ring, index) => {
                    // 隨機旋轉速度 (1.5s - 4s)
                    const duration = Math.random() * 2 + 1.5;
                    
                    // 隨機起始角度 (0° - 360°)
                    const startAngle = Math.random() * 360;
                    
                    // 隨機方向 (順時針或逆時針)
                    const direction = Math.random() > 0.5 ? 'normal' : 'reverse';
                    
                    // 創建唯一的旋轉動畫名稱
                    const spinAnimationName = `spinnerSpin${index}`;
                    
                    // 動態創建旋轉動畫的CSS規則
                    const spinKeyframes = `
                        @keyframes ${spinAnimationName} {
                            0% { transform: rotate(${startAngle}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                            100% { transform: rotate(${startAngle + 360}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                        }
                    `;
                    
                    // 將動畫規則添加到頁面
                    const style = document.createElement('style');
                    style.textContent = spinKeyframes;
                    document.head.appendChild(style);
                    
                    // 設定動畫
                    ring.style.animation = `${spinAnimationName} ${duration}s linear infinite`;
                    ring.style.animationDirection = direction;
                });
            }

            // 🔄 重置視角功能
            resetView() {
                // 1. 不要在 resetView() 設 parallaxFreeze = true；改為只凍結輸入：
                this.isResetting = true;  // 保留
                // 不設 this.parallaxFreeze
                
                // 取目前 smoothedDelta 當作 offset 起點
                const startX = this.smoothedDelta.x;
                const startY = this.smoothedDelta.y;
                const duration = 400; // ms
                const startTime = performance.now();
                
                const animate = (now) => {
                    const t = Math.min(1, (now - startTime) / duration);
                    const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // easeInOutQuad
                    const offsetX = THREE.MathUtils.lerp(startX, 0, ease);
                    const offsetY = THREE.MathUtils.lerp(startY, 0, ease);

                    // 3. 在 resetView() 的動畫迴圈內直接呼叫 applyMainParallax()：
                    // 將平滑後的 offset 立即套上主視差
                    this.applyMainParallax(offsetX, offsetY);

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 1. 在 resetView() 動畫結束區段 **不要**重新賦值 baseX / baseY，
                        // 而是清空並等待下一筆 gyro 事件自動重建基準：
                        this.currentOffsetX = 0;
                        this.currentOffsetY = 0;
                        this.smoothedDelta = { x: 0, y: 0 };
                        this.baseX = null;        // 保留向後相容
                        this.baseY = null;
                        this.baseAlpha = null;    // 重設角度基準
                        this.baseBeta = null;
                        this.baseGamma = null;
                        this.isResetting = false;
                        console.log('🔄 視角重置完成');
                    }
                };
                
                requestAnimationFrame(animate);
            }

            // 更新所有圖層的尺寸
            updateAllLayerSizes() {
                // 更新載入場景中的網格
                if (this.loadingScene) {
                    this.loadingScene.children.forEach(mesh => {
                        if (mesh.userData.texture) {
                            const { width, height } = this.calculateImageSize(mesh.userData.texture);
                            mesh.geometry.dispose(); // 釋放舊的幾何體
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        }
                    });
                }

                // 更新主場景中的圖層
                this.layers.forEach(layerGroup => {
                    if (layerGroup.userData.mainTexture) {
                        const { width, height } = this.calculateImageSize(layerGroup.userData.mainTexture);
                        
                        layerGroup.children.forEach(mesh => {
                            mesh.geometry.dispose(); // 釋放舊的幾何體
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        });
                    }
                });

                // 🔴 更新互動點點的位置和縮放
                this.updateInteractiveDotsLayout();
                
                // 🔍 更新局部圖層的位置和縮放
                this.updateDetailLayersLayout();
            }

            setupScene() {
                // 建立場景
                this.scene = new THREE.Scene();
                
                // 建立相機
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 5;
                
                // 建立渲染器
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                
                // 📱 高解析螢幕支援：設定像素比例
                const maxRatio = 2; // 兼顧效能的上限
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.renderer.setPixelRatio(pixelRatio);
                
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // 📱 確保canvas元素在DOM中的顯示尺寸正確
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.width = window.innerWidth + 'px';
                    canvas.style.height = window.innerHeight + 'px';
                }
                this.renderer.setClearColor(0x000000, 1);
                
                // 啟用深度測試以確保正確的圖層順序
                this.renderer.sortObjects = true;
                
                // 🎭 創建主要圖層組容器 (7_BG~1_RabbitFornt)
                this.mainLayerGroup = new THREE.Group();
                this.mainLayerGroup.name = 'MainContentLayers';
                this.scene.add(this.mainLayerGroup);
                
                // 🔴 創建互動點點容器
                this.dotsGroup = new THREE.Group();
                this.dotsGroup.name = 'InteractiveDots';
                this.scene.add(this.dotsGroup);
                
                // 🔍 創建局部圖容器
                this.detailGroup1 = new THREE.Group();
                this.detailGroup1.name = 'DetailLayer1';
                this.detailGroup1.renderOrder = 0.08;
                this.scene.add(this.detailGroup1);
                
                this.detailGroup2 = new THREE.Group();
                this.detailGroup2.name = 'DetailLayer2';
                this.detailGroup2.renderOrder = 0.07;
                this.scene.add(this.detailGroup2);
                
                this.detailGroup3 = new THREE.Group();
                this.detailGroup3.name = 'DetailLayer3';
                this.detailGroup3.renderOrder = 0.06;
                this.scene.add(this.detailGroup3);
                
                // 設定圖層組引用
                this.contentLayer = this.mainLayerGroup;
                console.log('✅ 多層級架構初始化完成');
                console.log('📱 UI層: z-index 3000+ (返回按鈕等)');
                console.log('🎬 載入層: z-index 2000+ (封面圖與載入動畫)');
                console.log('🖼️ 內容層: z-index 1000+ (主要圖層組)');
                console.log('🔴 互動點點: renderOrder 1 (最上層)');
                console.log('🔍 局部圖層: z軸 0.06~0.08 (dot1:0.06, dot2:0.07, dot3:0.08), depthWrite:false');
                console.log('🖼️ 主要圖層: renderOrder 0 (最下層)');
            }

            setupEventListeners() {
                // 🎮 混合控制系統事件監聽器
                
                // 1. 螢幕方向變化監聽（所有裝置）
                const handleOrientationChange = () => {
                    this.updateScreenOrientation(); // 實時更新方向
                    // 重設基準值，避免翻轉時跳動
                    this.baseX = null;
                    this.baseY = null;
                    this.baseAlpha = null;
                    this.baseBeta = null;
                    this.baseGamma = null;
                    this.smoothedDelta = { x: 0, y: 0 };
                    
                    // 📱 修正：螢幕方向變化時強制重新計算容器大小
                    // 延遲執行，確保瀏覽器完成方向變化
                    setTimeout(() => {
                        console.log('🔄 方向變化後重新計算容器大小');
                        // 強制觸發resize事件處理邏輯
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        
                        // 📱 高解析螢幕支援：重新設定像素比例和大小
                        const maxRatio = 2;
                        const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                        this.renderer.setPixelRatio(pixelRatio);
                        this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // 📱 確保canvas元素在DOM中的顯示尺寸正確
                        const canvas = document.getElementById('canvas');
                        if (canvas) {
                            canvas.style.width = window.innerWidth + 'px';
                            canvas.style.height = window.innerHeight + 'px';
                        }
                        
                        // 同時調整載入場景
                        if (this.loadingCamera && this.loadingRenderer) {
                            this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                            this.loadingCamera.updateProjectionMatrix();
                            this.loadingRenderer.setPixelRatio(pixelRatio);
                            this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                            
                            // 📱 確保載入canvas元素在DOM中的顯示尺寸正確
                            const loadingCanvas = document.getElementById('loading-canvas');
                            if (loadingCanvas) {
                                loadingCanvas.style.width = window.innerWidth + 'px';
                                loadingCanvas.style.height = window.innerHeight + 'px';
                            }
                        }
                        
                        // 重新計算所有圖層尺寸
                        this.updateAllLayerSizes();
                    }, 100); // 延遲100ms確保方向變化完成
                };

                // 監聽方向變化事件
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', handleOrientationChange);
                } else {
                    window.addEventListener('orientationchange', handleOrientationChange);
                }

                // 2. 滑鼠/觸控事件（所有裝置）
                document.addEventListener('pointermove', (event) => {
                    // 只有真實滑鼠移動才切換到pointer模式
                    if (event.pointerType === 'mouse' || (!event.pointerType && event.type === 'mousemove')) {
                        this.startPointerControl();
                        
                        // 更新滑鼠位置
                        const newX = (event.clientX / window.innerWidth) * 2 - 1;
                        const newY = -(event.clientY / window.innerHeight) * 2 + 1;
                        
                        // 計算滑鼠移動速度（用於慣性效果）
                        this.mouseVelocity.x = newX - this.targetMouse.x;
                        this.mouseVelocity.y = newY - this.targetMouse.y;
                        
                        this.targetMouse.x = newX;
                        this.targetMouse.y = newY;
                        this.mouseInsidePage = true;
                        this.isInertiaActive = false;
                        
                        // 更新pointer偏移
                        this.pointerUpdate(event.clientX, event.clientY);
                    }
                });

                // 3. 滑鼠離開/進入事件（桌面版慣性效果）
                if (!this.isMobile) {
                    document.addEventListener('mouseleave', () => {
                        this.mouseInsidePage = false;
                        this.mouseJustReentered = false;
                        
                        // 啟動慣性緩衝效果
                        const inertiaMultiplier = 1.5;
                        this.inertiaTarget.x = this.currentMouse.x + this.mouseVelocity.x * inertiaMultiplier;
                        this.inertiaTarget.y = this.currentMouse.y + this.mouseVelocity.y * inertiaMultiplier;
                        this.isInertiaActive = true;
                        
                        console.log('滑鼠離開頁面，啟動慣性緩衝效果');
                    });
                    
                    document.addEventListener('mouseenter', () => {
                        if (!this.mouseInsidePage) {
                            this.mouseInsidePage = true;
                            this.mouseJustReentered = true;
                            console.log('滑鼠重新進入頁面，開始平滑過渡到新位置');
                        }
                    });
                }

                // 4. 陀螺儀事件（行動裝置）
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.gyroUpdate.bind(this));
                }

                // 5. 陀螺儀授權按鈕事件
                const enableGyroBtn = document.getElementById('enable-gyro-btn');
                
                if (enableGyroBtn) {
                    enableGyroBtn.addEventListener('click', async () => {
                        const success = await this.startGyroControl();
                        // 無論成功與否都隱藏介面
                        const gyroPermission = document.getElementById('gyro-permission');
                        gyroPermission.classList.remove('show');
                        setTimeout(() => {
                            gyroPermission.style.display = 'none';
                        }, 500); // 等待淡出動畫完成
                        
                        if (!success) {
                            // 如果授權失敗，切換到滑鼠模式
                            this.currentControlMode = 'pointer';
                            console.log('陀螺儀授權失敗，使用滑鼠模式');
                        }
                    });
                }

                // 視窗大小調整
                window.addEventListener('resize', () => {
                    // 🎛️ 實時更新螢幕方向
                    this.updateScreenOrientation();
                    
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    
                    // 📱 高解析螢幕支援：重新設定像素比例和大小
                    const maxRatio = 2;
                    const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                    this.renderer.setPixelRatio(pixelRatio);
                    this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                    
                    // 📱 確保canvas元素在DOM中的顯示尺寸正確
                    const canvas = document.getElementById('canvas');
                    if (canvas) {
                        canvas.style.width = window.innerWidth + 'px';
                        canvas.style.height = window.innerHeight + 'px';
                    }
                    
                    // 同時調整載入場景
                    if (this.loadingCamera && this.loadingRenderer) {
                        this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                        this.loadingCamera.updateProjectionMatrix();
                        this.loadingRenderer.setPixelRatio(pixelRatio);
                        this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // 📱 確保載入canvas元素在DOM中的顯示尺寸正確
                        const loadingCanvas = document.getElementById('loading-canvas');
                        if (loadingCanvas) {
                            loadingCanvas.style.width = window.innerWidth + 'px';
                            loadingCanvas.style.height = window.innerHeight + 'px';
                        }
                    }

                    // 自動重新計算並調整所有圖層的 PlaneGeometry
                    this.updateAllLayerSizes();
                    
                    // 📱 更新按鈕顯示狀態（螢幕方向變化時）
                    this.monitorControlMode();
                });
            }

            loadLayers() {
                // 只計算主圖，因為深度圖和發光圖可能不存在（封面圖不計入）
                this.totalImages = this.layerInfo.length;
                console.log(`開始載入 ${this.totalImages} 張主要圖片`);
                
                this.layerInfo.forEach((layerData, index) => {
                    this.loadLayer(layerData, index);
                });
            }

            loadLayer(layerData, index) {
                const loader = new THREE.TextureLoader();
                const layerGroup = new THREE.Group();
                
                // 載入主圖
                console.log(`正在載入: ${layerData.name}.png`);
                loader.load(
                    `images/${layerData.name}.png`,
                    (mainTexture) => {
                        console.log(`成功載入主圖: ${layerData.name}.png`);
                        // 載入深度圖
                        loader.load(
                            `images/${layerData.name}_depth.png`,
                            (depthTexture) => {
                                // 載入發光圖
                                loader.load(
                                    `images/${layerData.name}_glow.png`,
                                    (glowTexture) => {
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index);
                                        this.onImageLoaded();
                                    },
                                    undefined,
                                    () => {
                                        // 發光圖載入失敗，只使用主圖和深度圖
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, null, layerData, index);
                                        this.onImageLoaded();
                                    }
                                );
                            },
                            undefined,
                            (error) => {
                                console.warn(`深度圖載入失敗: ${layerData.name}_depth.png`);
                                this.createLayerMesh(layerGroup, mainTexture, null, null, layerData, index);
                                this.onImageLoaded();
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`主圖載入失敗: ${layerData.name}.png`, error);
                        this.onImageLoaded(); // 修正：載入失敗也要計數
                    }
                );
            }

            createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index) {
                // 使用統一的尺寸計算函數，傳入 mainTexture 以獲取原始比例
                const { width, height } = this.calculateImageSize(mainTexture);

                // 如果有深度圖，使用自定義 Shader 來實現基於深度圖的視差
                if (depthTexture) {
                    const vertexShader = `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;
                    
                    const fragmentShader = `
                        uniform sampler2D mainTexture;
                        uniform sampler2D depthTexture;
                        uniform vec2 parallaxOffset;
                        uniform float parallaxStrength;
                        varying vec2 vUv;
                        
                        void main() {
                            // 讀取深度圖的灰階值
                            float depth = texture2D(depthTexture, vUv).r;
                            
                            // 根據深度值計算視差偏移 - 修正計算方式
                            vec2 offset = parallaxOffset * (depth - 0.625) * parallaxStrength;
                            vec2 parallaxUV = vUv + offset;
                            
                            // 檢查是否超出邊界
                            if (parallaxUV.x < 0.0 || parallaxUV.x > 1.0 || parallaxUV.y < 0.0 || parallaxUV.y > 1.0) {
                                // 超出邊界時，使用原始UV取樣
                                parallaxUV = vUv;
                            }
                            
                            // 取樣主紋理
                            vec4 color = texture2D(mainTexture, parallaxUV);
                            gl_FragColor = color;
                        }
                    `;

                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                    // 建立發光圖層（如果存在）- 必須在主圖層之前加入
                    if (glowTexture) {
                        console.log(`載入發光圖層: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                mainTexture: { value: glowTexture },
                                depthTexture: { value: depthTexture },
                                parallaxOffset: { value: new THREE.Vector2(0, 0) },
                                parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                            },
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // 重要：避免深度衝突
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // 稍微往後放，在主圖下層
                        layerGroup.add(glowMesh);
                    }

                    // 建立主圖層
                    const mainMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            mainTexture: { value: mainTexture },
                            depthTexture: { value: depthTexture },
                            parallaxOffset: { value: new THREE.Vector2(0, 0) },
                            parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                } else {
                    // 沒有深度圖，使用基本材質
                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                                                                if (glowTexture) {
                        console.log(`載入發光圖層（無深度圖）: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            map: glowTexture,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // 避免深度衝突
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // 在主圖下層
                        layerGroup.add(glowMesh);
                    }

                    const mainMaterial = new THREE.MeshBasicMaterial({
                        map: mainTexture,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                }

                // 根據圖層編號設定Z位置 - 編號越小越在前面
                const layerNumber = parseInt(layerData.name.split('_')[1]); // 取 Main_7_BG 中的 "7"
                layerGroup.position.z = (7 - layerNumber) * 0.01; // 1號最前面(z=0.06)，7號最後面(z=0)
                layerGroup.userData = {
                    depthTexture: depthTexture,
                    hasDepth: !!depthTexture,
                    mainTexture: mainTexture // 存儲主紋理引用以便 resize 時重新計算
                };

                this.layers.push(layerGroup);
                this.mainLayerGroup.add(layerGroup); // 添加到主要圖層組容器
            }

            onImageLoaded() {
                this.loadedImages++;
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // 🌫️ 確保初始狀態沒有模糊效果
                    this.resetTransitionBlur();
                    
                    // 🔴 載入完成後創建互動點點
                    this.createInteractiveDots();
                    
                    // 🔍 載入局部圖層
                    this.loadDetailLayers();
                    
                    // 📱 確保所有圖層尺寸正確（解決手機初始載入大小異常問題）
                    this.updateAllLayerSizes();
                    
                    // 載入完成後，開始淡出封面
                    setTimeout(() => {
                        this.startFadeOut();
                    }, 1000); // 延遲1秒開始淡出
                }
            }

            startFadeOut() {
                const cover = document.getElementById('loading-cover');
                console.log('開始封面淡出動畫');
                
                // 移除淡入 class
                cover.classList.remove('fade-in');
                
                // 使用兩次 requestAnimationFrame 確保流暢淡出
                requestAnimationFrame(() => {       // 讓第一幀呈現 opacity:1
                    requestAnimationFrame(() => {     // 第二幀再加動畫 class
                        cover.classList.add('fade-out');
                    });
                });
                
                // 監聽動畫結束事件
                cover.addEventListener('animationend', () => {
                    cover.style.display = 'none';
                    this.coverFadeOutComplete = true;
                    console.log('封面淡出完成');
                }, { once: true });
                
                // 封面開始淡出後0.5秒，開始載入中動畫淡出和視差過渡
                setTimeout(() => {
                    console.log('開始載入中淡出和視差過渡動畫');
                    this.startLoadingFadeOutAndParallaxTransition();
                }, 100); // 封面開始淡出後0.5秒觸發
                
                // 🔴 封面開始淡出後1秒，互動點點淡入
                setTimeout(() => {
                    console.log('🔴 開始互動點點淡入動畫');
                    this.fadeInInteractiveDots();
                }, 1000); // 封面開始淡出後1秒觸發
            }

            onImageError() {
                this.errorCount++;
                this.loadedImages++;
                
                // 如果錯誤太多，顯示錯誤訊息
                if (this.errorCount >= 3) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error-message').style.display = 'block';
                }
                
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // 🌫️ 確保初始狀態沒有模糊效果
                    this.resetTransitionBlur();
                    
                    // 📱 確保所有圖層尺寸正確（解決手機初始載入大小異常問題）
                    this.updateAllLayerSizes();
                    
                    document.getElementById('loading').style.display = 'none';
                }
            }

            startLoadingFadeOutAndParallaxTransition() {
                // 分別處理載入中動畫淡出和視差過渡
                const loadingFadeDuration = 1000; // 載入中淡出：1秒
                const parallaxTransitionDuration = 1500; // 視差過渡：1.5秒
                
                // 開始載入中動畫的淡出
                const loadingElement = document.getElementById('loading');
                loadingElement.classList.add('fade-out');
                
                // 1秒後完全隱藏載入中元素
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, loadingFadeDuration);
                
                // 同時開始視差過渡動畫（1.5秒）
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / parallaxTransitionDuration, 1);
                    
                    // 自定義緩動函數：70%緩進 + 30%緩出
                    let easedProgress;
                    if (progress <= 0.7) {
                        // 前70%使用緩進 (ease-in)
                        const t = progress / 0.7; // 將0-0.7映射到0-1
                        easedProgress = Math.pow(t, 3) * 0.7; // cubic ease-in，結果映射到0-0.7
                    } else {
                        // 後30%使用緩出 (ease-out)
                        const t = (progress - 0.7) / 0.3; // 將0.7-1映射到0-1
                        easedProgress = 0.7 + (1 - Math.pow(1 - t, 3)) * 0.3; // cubic ease-out，結果映射到0.7-1
                    }
                    
                    this.parallaxTransitionProgress = easedProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.parallaxTransitionProgress = 1; // 確保完全過渡到滑鼠位置
                    }
                };
                
                animate();
            }

            updateMousePosition() {
                if (this.isMobile) return; // 行動裝置不需要滑鼠插值
                
                if (this.mouseInsidePage) {
                    // 滑鼠在頁面內的正常跟隨邏輯
                    const deltaX = this.targetMouse.x - this.currentMouse.x;
                    const deltaY = this.targetMouse.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    let dynamicLerpFactor;
                    
                    if (this.mouseJustReentered) {
                        // 滑鼠剛重新進入頁面：使用慢速過渡（60%緩入，40%緩出）
                        const maxLerpFactor = 0.12;
                        const minLerpFactor = 0.02;
                        dynamicLerpFactor = Math.max(minLerpFactor, maxLerpFactor / (1 + distance * 3.5));
                        
                        // 當距離足夠小時，切換到正常跟隨模式
                        if (distance < 0.1) {
                            this.mouseJustReentered = false;
                            console.log('過渡完成，切換到正常跟隨模式');
                        }
                    } else {
                        // 滑鼠正常在頁面內移動：使用快速跟隨
                        dynamicLerpFactor = 0.25; // 快速響應的固定係數
                    }
                    
                    this.currentMouse.x += deltaX * dynamicLerpFactor;
                    this.currentMouse.y += deltaY * dynamicLerpFactor;
                    
                } else if (this.isInertiaActive) {
                    // 滑鼠離開頁面時的慣性緩衝邏輯
                    const deltaX = this.inertiaTarget.x - this.currentMouse.x;
                    const deltaY = this.inertiaTarget.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // 慣性緩衝的優雅減速係數（基於距離的動態減速）
                    const baseInertiaFactor = 0.025; // 基礎減速係數（更慢）
                    const distanceBoost = Math.min(distance * 0.8, 0.06); // 距離越遠，減速越慢
                    const inertiaLerpFactor = baseInertiaFactor + distanceBoost;
                    
                    this.currentMouse.x += deltaX * inertiaLerpFactor;
                    this.currentMouse.y += deltaY * inertiaLerpFactor;
                    
                    // 更寬鬆的停止條件，讓動畫更優雅地結束
                    if (distance < 0.005) {
                        this.isInertiaActive = false;
                        console.log('慣性緩衝完成');
                    }
                }
                // 其他情況：滑鼠離開頁面且無慣性時，currentMouse 保持不變
                
                // 更新 mouse 為當前插值後的位置
                this.mouse.x = this.currentMouse.x;
                this.mouse.y = this.currentMouse.y;
                
                // 🔧 修正：同時更新currentOffsetX/Y以供混合控制系統使用
                this.currentOffsetX = this.currentMouse.x;
                this.currentOffsetY = this.currentMouse.y;
            }

            updateParallax() {
                if (!this.loadingComplete) return;
                
                // 重置期間不更新視差，讓動畫迴圈處理
                if (this.isResetting) return;

                // 更新滑鼠位置插值
                this.updateMousePosition();

                // 🎮 統一輸入源：使用currentOffsetX/Y，確保行動裝置和滑鼠的邏輯一致
                const inputX = this.currentOffsetX * this.parallaxTransitionProgress;
                const inputY = this.currentOffsetY * this.parallaxTransitionProgress;
                
                // 🔧 修正：在過渡期間和不同視角下都要處理滑鼠輸入
                if (this.viewState === 'detail' && !this.isTransitioning) {
                    // 🕹️ 純局部視角：只應用局部視角控制
                    this.updateDetailViewControl(inputX, inputY);
                } else if (this.viewState === 'main' && !this.isTransitioning) {
                    // 🖼️ 純主視角：只應用主視差效果
                    this.applyMainParallax(inputX, inputY);
                } else if (this.isTransitioning) {
                    // 🔄 過渡期間：同時應用兩種效果，但權重不同
                    // 這個邏輯會在動畫函數中處理
                    return;
                }
            }

            // 🌫️ 過渡模糊效果控制方法
            applyTransitionBlur(progress) {
                // 🔧 三段式非對稱模糊曲線：
                // 進度 0.0 → 模糊 0%
                // 進度 0.33 → 模糊 100%
                // 進度 0.66 → 模糊 25%
                // 進度 1.0 → 模糊 0%
                
                let blurFactor;
                
                if (progress <= 0.33) {
                    // 前33%：從0%緩進到100% (使用ease-in曲線)
                    const t = progress / 0.33; // 映射到0-1
                    blurFactor = t * t; // quadratic ease-in
                } else if (progress <= 0.66) {
                    // 33%-66%：從100%快速下降到25% (線性)
                    const t = (progress - 0.33) / 0.33; // 映射到0-1
                    blurFactor = 1.0 - (t * 0.75); // 從1.0下降到0.25
                } else {
                    // 66%-100%：從25%緩出到0% (使用ease-out曲線)
                    const t = (progress - 0.66) / 0.34; // 映射到0-1 (0.34 = 1.0 - 0.66)
                    const easeOutT = 1 - Math.pow(1 - t, 2); // quadratic ease-out
                    blurFactor = 0.25 * (1 - easeOutT); // 從0.25下降到0
                }
                
                const blurIntensity = blurFactor * this.TRANSITION_BLUR_STRENGTH;
                
                // 應用模糊到canvas元素
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = `blur(${blurIntensity}px)`;
                }
                
                // 可選：添加調試資訊
                console.log(`🌫️ 過渡模糊: progress=${progress.toFixed(3)}, factor=${(blurFactor*100).toFixed(1)}%, blur=${blurIntensity.toFixed(2)}px`);
            }
            
            // 🌫️ 重置模糊效果
            resetTransitionBlur() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = 'none';
                }
            }
            
            // 🔍 動態設定局部視角放大倍率
            setDetailZoomScale(scale) {
                if (scale < 1.0) {
                    console.warn('⚠️ 放大倍率不能小於1.0，已設定為1.0');
                    scale = 1.0;
                } else if (scale > 20.0) {
                    console.warn('⚠️ 放大倍率不能大於20.0，已設定為20.0');
                    scale = 20.0;
                }
                
                this.DETAIL_ZOOM_SCALE = scale;
                console.log(`🔍 局部視角放大倍率已設定為: ${scale}x (${(scale*100).toFixed(0)}%)`);
            }
            
            // 🔍 動態獲取目標相機位置
            getTargetCameraPosition() {
                return {
                    x: 0,
                    y: 0,
                    z: this.originalCameraPosition.z / this.DETAIL_ZOOM_SCALE
                };
            }

            // 🔧 新增：獨立的主視差應用方法
            applyMainParallax(inputX, inputY) {
                
                this.layers.forEach((layer) => {
                    const userData = layer.userData;
                    
                    if (userData.hasDepth) {
                        // 對於有深度圖的圖層，更新 Shader 的 parallaxOffset 參數
                        layer.children.forEach((mesh) => {
                            if (mesh.material && mesh.material.uniforms) {
                                mesh.material.uniforms.parallaxOffset.value.set(
                                    inputX * this.PARALLAX_INTENSITY, 
                                    inputY * this.PARALLAX_INTENSITY
                                );
                            }
                        });
                    }
                    // 沒有深度圖的圖層保持靜止，位置不變
                });

                // 🔴 更新互動點點的視差效果
                this.updateInteractiveDotsParallax(inputX, inputY);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 🎮 控制模式監控
                this.monitorControlMode();
                
                // 如果載入封面還在顯示，渲染載入場景
                if (!this.loadingComplete && this.loadingCoverLoaded && this.loadingRenderer) {
                    this.loadingRenderer.render(this.loadingScene, this.loadingCamera);
                }
                
                // 渲染主場景
                if (this.loadingComplete) {
                    this.updateParallax();
                }
                this.renderer.render(this.scene, this.camera);
            }

            // 🔍 ================== 局部圖系統 ==================

            zoomToDetailView(clickedDot) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                this.viewState = 'detail';
                this.currentDetailDot = clickedDot;
                
                // 🕹️ 重置局部視角控制
                this.resetDetailViewControl();
                
                // 找到對應的局部圖
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === clickedDot.config.id
                );
                
                if (!detailLayer) {
                    console.error(`🔍 找不到對應的局部圖: ${clickedDot.config.id}`);
                    this.isTransitioning = false;
                    return;
                }
                
                console.log(`🎯 開始放大動畫到 ${clickedDot.config.id}，放大倍率: ${this.DETAIL_ZOOM_SCALE}x (${(this.DETAIL_ZOOM_SCALE*100).toFixed(0)}%)`);
                
                // 計算目標位置 - 將局部圖的中心移動到畫面中心
                const detailMesh = detailLayer.mesh;
                const targetSceneX = -detailMesh.position.x;  // 反向移動場景
                const targetSceneY = -detailMesh.position.y;
                
                // 設定動畫參數
                const duration = 1500; // 1.5秒
                const startTime = Date.now();
                
                // 記錄起始狀態
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // 目標狀態 - 根據設定的放大倍率計算相機位置
                // 放大倍率 = 初始距離 / 目標距離，所以目標距離 = 初始距離 / 放大倍率
                const targetCameraZ = startCameraZ / this.DETAIL_ZOOM_SCALE; // 可配置放大倍率
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 緩動函數：ease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // 🔧 過渡期間的滑鼠控制：同時應用主視差和局部視角控制
                    // 統一使用currentOffsetX/Y，確保行動裝置和滑鼠的邏輯一致
                    const rawInputX = this.currentOffsetX;
                    const rawInputY = this.currentOffsetY;
                    
                    // 主視差權重：從1過渡到0
                    const mainParallaxWeight = 1.0 - easeProgress;
                    // 局部視角權重：從0過渡到1  
                    const detailViewWeight = easeProgress;
                    
                    // 計算混合的場景位置
                    let finalSceneX = startSceneX + (targetSceneX - startSceneX) * easeProgress;
                    let finalSceneY = startSceneY + (targetSceneY - startSceneY) * easeProgress;
                    
                    // 應用主視差效果（權重遞減）
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // 應用局部視角控制（權重遞增）
                    if (detailViewWeight > 0) {
                        const detailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        const detailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        
                        // 應用邊界限制
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedOffsetX = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetX));
                        const limitedOffsetY = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetY));
                        
                        // 疊加局部視角偏移
                        finalSceneX += limitedOffsetX;
                        finalSceneY += limitedOffsetY;
                    }
                    
                    // 更新相機位置 (放大效果)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // 更新場景位置 (移動到局部圖中心 + 滑鼠偏移)
                    this.scene.position.x = finalSceneX;
                    this.scene.position.y = finalSceneY;
                    
                    // 🌟 局部圖淡入 - 在放大過程中逐漸顯示，同時調整羽化強度
                    if (detailMesh.material.uniforms) {
                        // 透明度過渡：使用稍快的速度但不要太快
                        const targetOpacity = Math.min(1.0, easeProgress * 1.1);
                        detailMesh.material.uniforms.opacity.value = targetOpacity;
                        
                        // 🔧 修正羽化過渡：使用線性進度而非緩動進度，確保平滑過渡
                        const linearProgress = progress; // 使用線性進度而非easeProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_MAIN_VIEW - (linearProgress * featherRange);
                        detailMesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // 可選：添加調試資訊
                        // console.log(`🌟 羽化過渡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // 🔴 點點淡出效果 - 放大時
                    this.updateDotsTransitionOpacity('zoomIn', progress);
                    
                    // 🌫️ 應用過渡模糊效果
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 動畫完成
                        this.camera.position.z = targetCameraZ;
                        // 🔧 最終位置需要包含當前的局部視角偏移
                        const finalDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const finalDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        const finalLimitedOffsetX = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetX));
                        const finalLimitedOffsetY = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetY));
                        
                        this.scene.position.x = targetSceneX + finalLimitedOffsetX;
                        this.scene.position.y = targetSceneY + finalLimitedOffsetY;
                        
                        // 🌟 設定最終狀態：完全不透明，羽化最弱
                        if (detailMesh.material.uniforms) {
                            detailMesh.material.uniforms.opacity.value = 1.0;
                            detailMesh.material.uniforms.featherStrength.value = this.FEATHER_DETAIL_VIEW;  // 局部視角羽化最弱
                        }
                        
                        // 🌫️ 重置模糊效果
                        this.resetTransitionBlur();
                        
                        // 🔴 重置點點透明度為0%（局部視角時完全隱藏）
                        this.resetDotsTransitionOpacity(0.0);
                        
                        this.isTransitioning = false;
                        
                        console.log(`🎯 放大動畫完成，進入局部視角: ${clickedDot.config.id}`);
                    }
                };
                
                animate();
            }

            returnToMainView() {
                if (this.isTransitioning || this.viewState === 'main') return;
                
                this.isTransitioning = true;
                
                // 🕹️ 重置局部視角控制
                this.resetDetailViewControl();
                
                console.log('🔄 開始返回主視角動畫');
                
                // 找到當前的局部圖
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === this.currentDetailDot.config.id
                );
                
                // 設定動畫參數
                const duration = 1500; // 1.5秒
                const startTime = Date.now();
                
                // 記錄起始狀態
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // 🔧 分離起始位置的基礎位置和滑鼠偏移
                const detailMesh = detailLayer.mesh;
                const baseSceneX = -detailMesh.position.x;  // 局部圖中心對應的基礎場景位置
                const baseSceneY = -detailMesh.position.y;
                const startOffsetX = startSceneX - baseSceneX;  // 起始時的滑鼠偏移
                const startOffsetY = startSceneY - baseSceneY;
                
                // 目標狀態 (回到原始位置) - 使用初始相機位置
                const targetCameraZ = 5; // 固定回到初始位置
                const targetSceneX = 0;
                const targetSceneY = 0;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 緩動函數：ease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // 🔧 過渡期間的滑鼠控制：同時應用局部視角和主視差控制
                    // 統一使用currentOffsetX/Y，確保行動裝置和滑鼠的邏輯一致
                    const rawInputX = this.currentOffsetX;
                    const rawInputY = this.currentOffsetY;
                    
                    // 局部視角權重：從1過渡到0
                    const detailViewWeight = 1.0 - easeProgress;
                    // 主視差權重：從0過渡到1
                    const mainParallaxWeight = easeProgress;
                    
                    // 🔧 修正：計算基礎場景位置的過渡
                    const baseTransitionX = baseSceneX + (targetSceneX - baseSceneX) * easeProgress;
                    const baseTransitionY = baseSceneY + (targetSceneY - baseSceneY) * easeProgress;
                    
                    // 計算混合的滑鼠偏移
                    let finalOffsetX = 0;
                    let finalOffsetY = 0;
                    
                    // 應用局部視角控制（權重遞減）
                    if (detailViewWeight > 0) {
                        const currentDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const currentDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        
                        // 應用邊界限制
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedCurrentOffsetX = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetX));
                        const limitedCurrentOffsetY = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetY));
                        
                        // 🔧 修正：從起始偏移平滑過渡到0（回到主視角中心）
                        // 起始偏移隨著權重減少而減少，最終變為0
                        const transitionOffsetX = startOffsetX * detailViewWeight;
                        const transitionOffsetY = startOffsetY * detailViewWeight;
                        
                        // 當前滑鼠偏移也隨著權重減少而減少
                        const currentOffsetX = limitedCurrentOffsetX * detailViewWeight;
                        const currentOffsetY = limitedCurrentOffsetY * detailViewWeight;
                        
                        // 混合兩種偏移，但都會隨著權重減少
                        finalOffsetX = transitionOffsetX * 0.3 + currentOffsetX * 0.7;
                        finalOffsetY = transitionOffsetY * 0.3 + currentOffsetY * 0.7;
                    } else {
                        // 🔧 權重為0時，偏移也應該為0（完全回到主視角）
                        finalOffsetX = 0;
                        finalOffsetY = 0;
                    }
                    
                    // 🔧 修正：場景基礎位置平滑過渡到(0,0)
                    const sceneBaseX = baseTransitionX + finalOffsetX;
                    const sceneBaseY = baseTransitionY + finalOffsetY;
                    
                    // 更新相機位置 (縮小效果)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // 🔧 設定場景基礎位置
                    this.scene.position.x = sceneBaseX;
                    this.scene.position.y = sceneBaseY;
                    
                    // 🔧 在場景基礎位置之上應用主視差效果（權重遞增）
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // 🌟 局部圖淡出 - 同時調整羽化強度
                    if (detailLayer && detailLayer.mesh.material.uniforms) {
                        detailLayer.mesh.material.uniforms.opacity.value = 1.0 - easeProgress;
                        
                        // 🔧 修正羽化過渡：使用線性進度確保平滑過渡
                        const linearProgress = progress; // 使用線性進度而非easeProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_DETAIL_VIEW + (linearProgress * featherRange);
                        detailLayer.mesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // 可選：添加調試資訊
                        // console.log(`🌟 羽化過渡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // 🔴 點點淡入效果 - 縮小時
                    this.updateDotsTransitionOpacity('zoomOut', progress);
                    
                    // 🌫️ 應用過渡模糊效果
                    this.applyTransitionBlur(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 動畫完成
                        this.camera.position.z = targetCameraZ;
                        
                        // 🔧 場景位置已經在動畫過程中平滑過渡到目標位置(0,0)
                        // 不需要再次設定，避免突跳
                        // this.scene.position.x = targetSceneX;
                        // this.scene.position.y = targetSceneY;
                        
                        // 🔧 確保最終狀態：場景位置為(0,0)，主視差效果疊加
                        this.scene.position.x = 0;
                        this.scene.position.y = 0;
                        const finalMainInputX = rawInputX * this.parallaxTransitionProgress;
                        const finalMainInputY = rawInputY * this.parallaxTransitionProgress;
                        this.applyMainParallax(finalMainInputX, finalMainInputY);
                        
                        // 🌟 重置局部圖狀態：透明度為0，羽化強度最強
                        if (detailLayer && detailLayer.mesh.material.uniforms) {
                            detailLayer.mesh.material.uniforms.opacity.value = 0.0;
                            detailLayer.mesh.material.uniforms.featherStrength.value = this.FEATHER_MAIN_VIEW;  // 主視角羽化最強
                        }
                        
                        // 🌫️ 重置模糊效果
                        this.resetTransitionBlur();
                        
                        // 🔴 重置點點透明度為100%（主視角時完全顯示）
                        this.resetDotsTransitionOpacity(1.0);
                        
                        // 重置狀態
                        this.viewState = 'main';
                        this.currentDetailDot = null;
                        this.isTransitioning = false;
                        
                        console.log('🔄 返回主視角動畫完成');
                    }
                };
                
                animate();
            }

            loadDetailLayers() {
                console.log('🔍 開始載入局部圖層');
                
                this.detailLayerInfo.forEach((detailInfo, index) => {
                    this.loadDetailLayer(detailInfo, index);
                });
            }

            loadDetailLayer(detailInfo, index) {
                const loader = new THREE.TextureLoader();
                
                console.log(`🔍 正在載入局部圖: ${detailInfo.name}.png`);
                loader.load(
                    `images/${detailInfo.name}.png`,
                    (texture) => {
                        console.log(`🔍 成功載入局部圖: ${detailInfo.name}.png`);
                        this.createDetailLayerMesh(texture, detailInfo, index);
                    },
                    undefined,
                    (error) => {
                        console.error(`🔍 局部圖載入失敗: ${detailInfo.name}.png`, error);
                    }
                );
            }

            createDetailLayerMesh(texture, detailInfo, index) {
                // 🔧 修正：使用主圖層的尺寸作為基準，而不是局部圖自己的尺寸
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) {
                    console.error('🔍 無法獲取主圖層尺寸，局部圖建立失敗');
                    return;
                }
                
                const { width: mainWidth, height: mainHeight } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 🔧 建立與主圖層相同大小的幾何體，稍後用縮放控制實際大小
                const geometry = new THREE.PlaneGeometry(mainWidth, mainHeight);
                
                // 🌟 建立具有邊緣羽化效果的自定義Shader材質
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform sampler2D mainTexture;
                    uniform float opacity;
                    uniform float featherStrength;  // 羽化強度 (0.0-1.0)
                    uniform float featherRange;     // 羽化影響範圍 (0.0-1.0)
                    varying vec2 vUv;
                    
                    void main() {
                        // 取樣主紋理
                        vec4 color = texture2D(mainTexture, vUv);
                        
                        // 計算到邊緣的距離
                        vec2 center = vec2(0.5, 0.5);
                        vec2 edgeDistance = abs(vUv - center) * 2.0;  // 轉換為0-1範圍
                        float maxEdgeDistance = max(edgeDistance.x, edgeDistance.y);
                        
                        // 羽化計算：從邊緣開始淡化
                        float actualFeatherRange = featherStrength * featherRange;  // 實際羽化範圍
                        float featherStart = 1.0 - actualFeatherRange;              // 羽化開始位置
                        float featherEnd = 1.0;                                     // 羽化結束位置（邊緣）
                        
                        float edgeAlpha = 1.0;
                        if (maxEdgeDistance > featherStart && actualFeatherRange > 0.0) {
                            // 在羽化區域內，計算透明度漸變
                            float featherProgress = (maxEdgeDistance - featherStart) / (featherEnd - featherStart);
                            // 使用更平滑的曲線
                            edgeAlpha = 1.0 - smoothstep(0.0, 1.0, featherProgress * featherProgress);
                        }
                        
                        // 最終透明度 = 材質透明度 × 邊緣透明度
                        color.a *= opacity * edgeAlpha;
                        
                        gl_FragColor = color;
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        mainTexture: { value: texture },
                        opacity: { value: 0.0 },  // 初始透明度為0
                        featherStrength: { value: this.FEATHER_MAIN_VIEW },  // 初始羽化強度：主視角時最強
                        featherRange: { value: this.FEATHER_TRANSITION_RANGE }  // 羽化影響範圍
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false  // 🔧 關鍵修正：避免透明物件寫入深度緩衝區造成遮擋
                });
                
                // 建立網格
                const mesh = new THREE.Mesh(geometry, material);
                
                // 🔧 修正：使用點點配置直接計算位置，確保坐標系統完全一致
                const correspondingDot = this.interactiveDots.find(dot => 
                    dot.config.id === detailInfo.dotId
                );
                
                if (correspondingDot) {
                    // 🔧 修正：與點點相同的坐標計算邏輯
                    const x = (correspondingDot.config.x - 0.5) * mainWidth;
                    const y = (0.5 - correspondingDot.config.y) * mainHeight; // Y軸翻轉
                    
                    mesh.position.x = x;
                    mesh.position.y = y;
                    // 🔧 Z軸位置：現在有了depthWrite: false，順序不再重要
                    mesh.position.z = 0.06 + index * 0.01; // Z軸位置 0.06~0.08 (index 0,1,2 對應 0.06,0.07,0.08)
                    
                    console.log(`🔍 局部圖 ${detailInfo.name} 位置設定為與點點 ${detailInfo.dotId} 相同的計算結果:`, 
                               `(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
                } else {
                    console.warn(`🔍 找不到對應的點點: ${detailInfo.dotId}`);
                    mesh.position.z = 0.06 + index * 0.01;
                }
                
                // 設定初始縮放25%
                mesh.scale.setScalar(0.25);
                
                // 儲存相關資訊
                mesh.userData = {
                    isDetailLayer: true,
                    detailInfo: detailInfo,
                    originalTexture: texture,  // 局部圖本身的紋理
                    mainTexture: firstLayer.userData.mainTexture,  // 🔧 新增：主圖層紋理引用，用於尺寸計算
                    baseScale: 0.25,
                    dotId: detailInfo.dotId
                };
                
                // 添加到對應的圖層組
                const targetGroup = this[detailInfo.group];
                if (targetGroup) {
                    targetGroup.add(mesh);
                    console.log(`🔍 局部圖 ${detailInfo.name} 已添加到 ${detailInfo.group}`);
                } else {
                    console.error(`🔍 找不到目標圖層組: ${detailInfo.group}`);
                }
                
                // 添加到局部圖層陣列
                this.detailLayers.push({
                    mesh: mesh,
                    group: targetGroup,
                    detailInfo: detailInfo,
                    isVisible: true,
                    basePosition: {
                        x: mesh.position.x,
                        y: mesh.position.y,
                        z: mesh.position.z
                    }
                });
            }

            updateDetailLayersLayout() {
                // 當視窗大小改變時，更新局部圖層位置和尺寸
                if (!this.detailLayers.length || !this.interactiveDots.length) return;
                
                // 獲取主圖的尺寸用於計算
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                this.detailLayers.forEach(detailLayer => {
                    const correspondingDot = this.interactiveDots.find(dot => 
                        dot.config.id === detailLayer.detailInfo.dotId
                    );
                    
                    if (correspondingDot) {
                        // 🔧 修正：使用與點點相同的坐標計算邏輯，確保完全一致
                        const x = (correspondingDot.config.x - 0.5) * width;
                        const y = (0.5 - correspondingDot.config.y) * height; // Y軸翻轉
                        
                        detailLayer.mesh.position.x = x;
                        detailLayer.mesh.position.y = y;
                        
                        // 🔧 修正：更新幾何體尺寸以匹配主圖層
                        detailLayer.mesh.geometry.dispose(); // 釋放舊的幾何體
                        detailLayer.mesh.geometry = new THREE.PlaneGeometry(width, height);
                        
                        // 更新基礎位置記錄
                        detailLayer.basePosition.x = x;
                        detailLayer.basePosition.y = y;
                        
                        console.log(`🔍 更新局部圖 ${detailLayer.detailInfo.name} 位置到 (${x.toFixed(2)}, ${y.toFixed(2)})，尺寸: ${width.toFixed(1)}x${height.toFixed(1)}`);
                    }
                });
            }

            // 🔴 ================== 互動點點系統 ==================

            createInteractiveDots() {
                console.log('🔴 開始創建互動點點');
                
                // 點點配置資料 - 位置以百分比表示 (0-1)
                const dotsConfig = [
                    { id: 'dot1', x: 0.6385, y: 0.394, depth: 0.56 },
                    { id: 'dot2', x: 0.486, y: 0.647, depth: 0.57 },
                    { id: 'dot3', x: 0.71, y: 0.628, depth: 0.65 }
                ];

                // 為每個點創建網格
                dotsConfig.forEach((config, index) => {
                    const dot = this.createDotMesh(config);
                    this.interactiveDots.push({
                        mesh: dot,
                        config: config,
                        originalPosition: { x: config.x, y: config.y },
                        basePosition: { x: 0, y: 0 }, // 基礎位置（不含視差）
                        isHovered: false,
                        hoverMultiplier: 1.0,         // hover透明度乘數
                        isPressed: false,             // 是否被按下
                        pressedScale: 1.0,            // 按下狀態的縮放
                        // 距離互動相關
                        mouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // 滑鼠距離係數 (0=最近, 1=最遠/超出範圍)
                        targetMouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // 目標距離係數
                        distanceScale: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_SCALE_FACTOR : 1.0,      // 基於距離的縮放係數
                        distanceOpacity: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_OPACITY_FACTOR : 1.0,   // 基於距離的透明度係數
                        // 🌫️ 過渡動畫相關
                        transitionOpacity: 1.0  // 過渡動畫透明度乘數 (放大縮小時的淡出淡入)
                    });
                    this.dotsGroup.add(dot);
                });

                // 設定點點容器的渲染順序
                this.dotsGroup.renderOrder = 1; // 比主圖層組(0)高，比載入層低
                
                // 初始化點點布局
                this.updateInteractiveDotsLayout();
                
                // 設定點擊事件
                this.setupDotInteractions();
                
                console.log(`✅ 成功創建 ${this.interactiveDots.length} 個互動點點`);
            }

            createDotMesh(config) {
                // 創建具有陰影效果的互動點點材質
                const canvas = document.createElement('canvas');
                const size = 128; // 增加畫布大小以容納更大的陰影
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                const outerRadius = size * 0.2; // 調整點點大小比例
                const innerRadius = size * 0.1;  
                const shadowRadius = size * 0.32;  // 陰影範圍
                
                // 清除畫布
                ctx.clearRect(0, 0, size, size);
                
                // 繪製大範圍擴散陰影 - 從中心向外模糊
                const shadowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, shadowRadius);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');     // 中心較深
                shadowGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.25)');  // 漸變
                shadowGradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');   // 更淡
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');       // 邊緣透明
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, shadowRadius, 0, Math.PI * 2);
                ctx.fillStyle = shadowGradient;
                ctx.fill();
                
                // 設定點點本身的陰影效果
                ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 2;
                
                // 繪製外圈 - 半透明邊框
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 重置陰影
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // 繪製內圈 - 實心中心
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                
                // 內圈漸變填充
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                innerGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)');
                
                ctx.fillStyle = innerGradient;
                ctx.fill();
                
                // 添加精細的白色光暈效果
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius + 3, 0, Math.PI * 2);
                const glowGradient = ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, outerRadius + 3);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // 創建紋理
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // 創建材質
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,  // 初始為透明，等待淡入
                    blending: THREE.NormalBlending
                });
                
                // 計算點點大小 - 使用與主圖相同的縮放邏輯
                let dotSize;
                if (this.layers.length > 0 && this.layers[0].userData.mainTexture) {
                    // 獲取主圖的尺寸
                    const { width, height } = this.calculateImageSize(this.layers[0].userData.mainTexture);
                    // 點點大小設為主圖較小邊的 1/35，保持與主圖的視覺比例
                    dotSize = Math.min(width, height) * 0.05;
                } else {
                    // 如果主圖還沒載入，使用預設大小
                    dotSize = 0.32;
                }
                
                // 創建幾何體 - 使用計算出的大小
                const geometry = new THREE.PlaneGeometry(dotSize, dotSize);
                
                // 創建網格
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    isDot: true,
                    dotId: config.id,
                    depthValue: config.depth,
                    baseOpacity: 0.85, // 稍高的基礎透明度確保可見性
                    isVisible: false,
                    baseSize: dotSize // 存儲基礎大小以便後續調整
                };
                
                return mesh;
            }

            updateInteractiveDotsLayout() {
                if (!this.layers.length || !this.interactiveDots.length) return;
                
                // 獲取主圖的尺寸（使用第一個圖層的主紋理）
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 更新每個點的基礎位置和大小
                this.interactiveDots.forEach(dotData => {
                    const { config } = dotData;
                    
                    // 計算在主圖範圍內的位置
                    // relativeX/Y 從 0~1 轉換為 -width/2 ~ +width/2 的座標
                    const x = (config.x - 0.5) * width;
                    const y = (0.5 - config.y) * height; // Y軸翻轉
                    
                    dotData.basePosition.x = x;
                    dotData.basePosition.y = y;
                    dotData.mesh.position.x = x;
                    dotData.mesh.position.y = y;
                    dotData.mesh.position.z = 0.1; // 確保在主圖層之上
                    
                    // 重新計算點點大小
                    const dotSize = Math.min(width, height) * 0.028;
                    dotData.mesh.userData.baseSize = dotSize;
                    
                    // 更新幾何體大小
                    dotData.mesh.geometry.dispose();
                    dotData.mesh.geometry = new THREE.PlaneGeometry(dotSize, dotSize);
                });
                
                console.log('🔴 互動點點布局已更新');
            }

            updateInteractiveDotsParallax(inputX, inputY) {
                if (!this.interactiveDots.length) return;
                
                this.interactiveDots.forEach(dotData => {
                    const { mesh, basePosition, config } = dotData;
                    
                    // 根據點的深度值計算視差偏移
                    const depthOffset = (config.depth - 0.625); // 與 shader 中相同的基準點
                    const parallaxX = inputX * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    const parallaxY = inputY * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    
                    // 應用視差偏移到基礎位置
                    mesh.position.x = basePosition.x + parallaxX;
                    mesh.position.y = basePosition.y + parallaxY;
                });
            }

            setupDotInteractions() {
                // 建立raycaster用於點擊檢測
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // 滑鼠按下事件
                this.renderer.domElement.addEventListener('pointerdown', (event) => {
                    this.handleDotPointerDown(event);
                });
                
                // 滑鼠放開事件
                this.renderer.domElement.addEventListener('pointerup', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // 滑鼠離開時也要放開（避免拖拽離開後卡住）
                this.renderer.domElement.addEventListener('pointerleave', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // 桌機版：滑鼠hover效果和距離互動
                if (!this.isMobile) {
                    this.renderer.domElement.addEventListener('pointermove', (event) => {
                        this.handleDotHover(event);
                        // 同時更新距離互動
                        if (this.DISTANCE_INTERACTION_ENABLED) {
                            this.updateDistanceInteraction(event);
                        }
                    });
                    
                    // 設定滑鼠樣式
                    this.renderer.domElement.style.cursor = 'default';
                } else {
                    // 行動版：距離互動已在建構函數中關閉，無需額外事件監聽器
                    console.log('行動版：距離感應互動已關閉');
                }
                // 注意：行動版的動畫現在統一在 fadeInInteractiveDots 完成後啟動
            }

            handleDotPointerDown(event) {
                // 如果正在過渡動畫中，忽略點擊
                if (this.isTransitioning) return;
                
                // 轉換滑鼠座標
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // 設定raycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                if (this.viewState === 'main') {
                    // 主視角：檢查點點點擊
                    const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                    let intersects = this.raycaster.intersectObjects(dotMeshes);
                    
                    // 如果是行動裝置且沒有精確命中，使用擴展的碰撞檢測
                    if (this.isMobile && intersects.length === 0) {
                        intersects = this.checkExtendedDotCollision(event.clientX, event.clientY);
                    }
                    
                    if (intersects.length > 0) {
                        const pressedDot = intersects[0].object;
                        const dotData = this.interactiveDots.find(d => d.mesh === pressedDot);
                        const dotId = pressedDot.userData.dotId;
                        console.log(`🔴 ${dotId} pressed down`);
                        
                        if (dotData) {
                            // 設定按下狀態
                            dotData.isPressed = true;
                            this.animateDotPress(dotData, true);
                        }
                    }
                } else if (this.viewState === 'detail') {
                    // 局部視角：點擊任意位置返回主視角
                    console.log('🔄 點擊畫面返回主視角');
                    this.returnToMainView();
                }
            }

            handleDotPointerUp(event) {
                // 如果正在過渡動畫中，忽略點擊
                if (this.isTransitioning) return;
                
                if (this.viewState === 'main') {
                    // 主視角：檢查是否有點點被按下並觸發放大
                    let clickedDot = null;
                    this.interactiveDots.forEach(dotData => {
                        if (dotData.isPressed) {
                            console.log(`🔴 ${dotData.mesh.userData.dotId} released`);
                            clickedDot = dotData;
                            dotData.isPressed = false;
                            this.animateDotPress(dotData, false);
                        }
                    });
                    
                    // 如果有點點被點擊，放大到局部視角
                    if (clickedDot) {
                        console.log(`🎯 放大到局部視角: ${clickedDot.config.id}`);
                        this.zoomToDetailView(clickedDot);
                    }
                }
            }

            // 檢查擴展的點點碰撞（行動裝置專用）
            checkExtendedDotCollision(clientX, clientY) {
                if (!this.layers.length) return [];
                
                // 獲取主圖的尺寸
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return [];
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 計算螢幕中心點
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // 計算點點在螢幕上的實際位置
                const dotScreenPositions = this.interactiveDots.map(dotData => {
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    return {
                        dotData: dotData,
                        screenX: dotScreenX,
                        screenY: dotScreenY
                    };
                });
                
                // 計算擴展的碰撞範圍（點點大小的2倍）
                const baseDotSize = Math.min(width, height) * 0.05; // 使用與createDotMesh相同的計算
                const extendedRadius = baseDotSize * (window.innerWidth / (width * this.IMAGE_SCALE)) * 2; // 2倍大小
                
                // 檢查觸控點是否在任何點點的擴展範圍內
                for (let i = 0; i < dotScreenPositions.length; i++) {
                    const pos = dotScreenPositions[i];
                    const deltaX = clientX - pos.screenX;
                    const deltaY = clientY - pos.screenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance <= extendedRadius) {
                        // 返回模擬的intersect結果
                        return [{
                            object: pos.dotData.mesh,
                            distance: distance
                        }];
                    }
                }
                
                return [];
            }

            handleDotHover(event) {
                if (this.isMobile) return;
                
                // 轉換滑鼠座標
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // 設定raycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                // 檢查與點點的交集
                const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                const intersects = this.raycaster.intersectObjects(dotMeshes);
                
                let currentHoveredDot = null;
                
                if (intersects.length > 0) {
                    currentHoveredDot = intersects[0].object;
                }
                
                // 更新hover狀態 - 只處理狀態改變的點
                this.interactiveDots.forEach(dotData => {
                    const shouldBeHovered = dotData.mesh === currentHoveredDot;
                    
                    if (shouldBeHovered && !dotData.isHovered) {
                        // 開始hover
                        dotData.isHovered = true;
                        this.animateDotHover(dotData.mesh, true);
                    } else if (!shouldBeHovered && dotData.isHovered) {
                        // 結束hover
                        dotData.isHovered = false;
                        this.animateDotHover(dotData.mesh, false);
                    }
                });
                
                // 更新滑鼠樣式
                this.renderer.domElement.style.cursor = currentHoveredDot ? 'pointer' : 'default';
            }

            animateDotPress(dotData, isPressed) {
                // 按下/放開動畫
                const duration = isPressed ? 80 : 200; // 按下快，放開慢
                const targetScale = isPressed ? 0.8 : 1.0; // 按下縮小30%
                const targetOpacityBoost = isPressed ? 1.6 : 1.0; // 按下時更亮
                
                const startScale = dotData.pressedScale;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 緩動函數：按下時快速，放開時彈性
                    const easeProgress = isPressed ? 
                        Math.pow(progress, 1.5) : // 按下：ease-in 快速
                        1 - Math.pow(1 - progress, 1.8); // 放開：ease-out 彈性
                    
                    // 更新縮放係數
                    dotData.pressedScale = startScale + (targetScale - startScale) * easeProgress;
                    
                    // 更新透明度（按下時變亮）
                    const targetMultiplier = dotData.isHovered ? 1.4 * targetOpacityBoost : targetOpacityBoost;
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            animateDotHover(dotMesh, isHovering) {
                // 找到對應的點資料
                const dotData = this.interactiveDots.find(d => d.mesh === dotMesh);
                if (!dotData) return;
                
                // 避免重複動畫
                if (dotMesh.userData.isAnimating) return;
                dotMesh.userData.isAnimating = true;
                
                // 設定目標透明度乘數
                const targetOpacityMultiplier = isHovering ? 1.4 : 1.0;
                const duration = 200;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 使用更快的緩動函數，讓hover反應更即時
                    const easeProgress = 1 - Math.pow(1 - progress, 2); // ease-out quad
                    
                    // 更新透明度乘數
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetOpacityMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        dotMesh.userData.isAnimating = false;
                    }
                };
                animate();
            }

            // 🎯 ================== 距離感應互動系統 ==================

            updateDistanceInteraction(event) {
                if (!this.loadingComplete || !this.layers.length) return;
                
                // 獲取滑鼠在畫面中的位置
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                // 獲取主圖的尺寸和位置信息
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 計算螢幕中心點
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // 計算最大感應距離（基於主圖寬度）
                const maxDistancePixels = width * this.MAX_DISTANCE * (window.innerWidth / (width * this.IMAGE_SCALE));
                
                this.interactiveDots.forEach(dotData => {
                    // 計算點點在螢幕上的實際位置
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    
                    // 計算滑鼠與點點的距離
                    const deltaX = mouseX - dotScreenX;
                    const deltaY = mouseY - dotScreenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // 計算距離係數 (0 = 最近, 1 = 最遠/超出範圍)
                    let distanceFactor = Math.min(distance / maxDistancePixels, 1.0);
                    
                    // 使用緩動曲線讓距離變化更自然
                    distanceFactor = this.easeOutQuad(distanceFactor);
                    
                    // 設定目標距離係數
                    dotData.targetMouseDistance = distanceFactor;
                });
            }

            updateDistanceInteractionAnimation() {
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // 距離互動啟用：平滑過渡到目標距離係數
                        const delta = dotData.targetMouseDistance - dotData.mouseDistance;
                        dotData.mouseDistance += delta * this.DISTANCE_LERP_SPEED;
                        
                        // 計算基於距離的縮放和透明度
                        // 使用反轉的距離係數：距離近時係數大，距離遠時係數小
                        const proximityFactor = 1.0 - dotData.mouseDistance;
                        
                        // 縮放係數：從最小縮放到1.0
                        dotData.distanceScale = this.MIN_SCALE_FACTOR + (1.0 - this.MIN_SCALE_FACTOR) * proximityFactor;
                        
                        // 透明度係數：從最小透明度到1.0
                        dotData.distanceOpacity = this.MIN_OPACITY_FACTOR + (1.0 - this.MIN_OPACITY_FACTOR) * proximityFactor;
                    } else {
                        // 距離互動關閉：保持正常大小和透明度
                        dotData.mouseDistance = 0.0;
                        dotData.targetMouseDistance = 0.0;
                        dotData.distanceScale = 1.0;
                        dotData.distanceOpacity = 1.0;
                    }
                });
            }

            resetDistanceInteraction() {
                // 重置所有點點的距離係數
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // 距離互動啟用：重置到最遠狀態
                        dotData.targetMouseDistance = 1.0;
                    } else {
                        // 距離互動關閉：重置到正常狀態
                        dotData.targetMouseDistance = 0.0;
                    }
                });
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            // 🎯 ================== 距離感應互動系統結束 ==================

            fadeInInteractiveDots() {
                // 互動點點的淡入動畫
                const fadeInDuration = 1500; // 1.5秒淡入
                const startTime = Date.now();
                
                this.interactiveDots.forEach((dotData, index) => {
                    const delay = index * 300; // 每個點錯開0.3秒
                    
                    setTimeout(() => {
                        dotData.mesh.userData.isVisible = true;
                        // 為每個點設定獨立的動畫開始時間
                        dotData.mesh.userData.animationStartTime = Date.now();
                        
                        const animate = () => {
                            const elapsed = Date.now() - startTime - delay;
                            const progress = Math.max(0, Math.min(elapsed / fadeInDuration, 1));
                            
                            if (progress > 0) {
                                // 緩動函數：ease-out
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                
                                // 在淡入過程中就開始計算呼吸動畫，確保絲滑銜接
                                const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                                const phase = index * Math.PI * 0.8;
                                const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                                
                                // 🎯 更新距離互動動畫（淡入期間也需要）
                                this.updateDistanceInteractionAnimation();
                                
                                // 淡入期間：透明度 = 淡入進度 × 基礎透明度 × 呼吸係數 × hover乘數 × 距離透明度 × 過渡透明度
                                const targetOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                                const opacity = targetOpacity * easeProgress;
                                dotData.mesh.material.opacity = opacity;
                                
                                // 大小呼吸效果，在淡入期間也同步開始，並考慮所有縮放效果
                                const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                                // 組合所有縮放效果：呼吸 × hover × 按下 × 距離
                                const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                                const finalScale = hoverScale * dotData.pressedScale * dotData.distanceScale;
                                const scaleFactor = finalScale * easeProgress + (1 - easeProgress);
                                dotData.mesh.scale.setScalar(scaleFactor);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else {
                                // 淡入完成，切換到純呼吸動畫
                                this.startBreathingAnimation(dotData, index);
                            }
                        };
                        animate();
                    }, delay);
                });
            }

            startBreathingAnimation(dotData, index) {
                // 桌機版和行動版的統一呼吸動畫，使用每個點獨立的時間基準
                const breathAnimate = () => {
                    if (!dotData.mesh.userData.isVisible) return;
                    
                    // 🎯 更新距離互動動畫
                    this.updateDistanceInteractionAnimation();
                    
                    // 使用每個點獨立的動畫開始時間，確保絲滑銜接
                    const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                    const phase = index * Math.PI * 0.8; // 每個點有不同的相位
                    
                    // 透明度呼吸效果：基礎呼吸 × hover乘數 × 距離透明度 × 過渡透明度
                    const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                    const currentOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                    dotData.mesh.material.opacity = currentOpacity;
                    
                    // 大小呼吸效果：組合呼吸、hover、按下和距離效果
                    const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                    const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                    const scaleFactor = hoverScale * dotData.pressedScale * dotData.distanceScale;
                    dotData.mesh.scale.setScalar(scaleFactor);
                    
                    requestAnimationFrame(breathAnimate);
                };
                breathAnimate();
            }

            // 🔴 ================== 互動點點系統結束 ==================

            // 🔍 ================== 局部圖系統 ==================

            // 🕹️ 局部視角控制方法
            updateDetailViewControl(inputX, inputY) {
                
                // 更新局部視角的滑鼠位置
                this.detailViewMouse.x = inputX;
                this.detailViewMouse.y = inputY;
                
                // 計算邊界超出效果的偏移量 - 相反方向
                const offsetX = -inputX * this.DETAIL_VIEW_INTENSITY;  // X軸相反
                const offsetY = -inputY * this.DETAIL_VIEW_INTENSITY;  // Y軸相反
                
                // 應用邊界限制
                const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                this.detailViewOffset.x = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
                this.detailViewOffset.y = Math.max(-maxOffset, Math.min(maxOffset, offsetY));
                
                // 更新場景位置以實現邊界超出效果
                if (this.currentDetailDot) {
                    const detailLayer = this.detailLayers.find(layer => 
                        layer.detailInfo.dotId === this.currentDetailDot.config.id
                    );
                    
                    if (detailLayer) {
                        const detailMesh = detailLayer.mesh;
                        
                        // 計算基礎場景位置（局部圖中心對齊畫面中心）
                        const baseSceneX = -detailMesh.position.x;
                        const baseSceneY = -detailMesh.position.y;
                        
                        // 應用邊界超出偏移
                        this.scene.position.x = baseSceneX + this.detailViewOffset.x;
                        this.scene.position.y = baseSceneY + this.detailViewOffset.y;
                        
                        // 可選：添加調試資訊
                        // console.log(`🕹️ 局部視角控制: offset(${this.detailViewOffset.x.toFixed(3)}, ${this.detailViewOffset.y.toFixed(3)})`);
                    }
                }
            }

            resetDetailViewControl() {
                // 重置局部視角控制
                this.detailViewMouse.x = 0;
                this.detailViewMouse.y = 0;
                this.detailViewOffset.x = 0;
                this.detailViewOffset.y = 0;
            }

            // 🔴 ================== 點點過渡透明度控制系統 ==================

            updateDotsTransitionOpacity(animationType, progress) {
                // 更新點點在放大縮小過程中的透明度
                if (!this.interactiveDots.length) return;

                let transitionOpacity = 1.0;

                if (animationType === 'zoomIn') {
                    // 放大時淡出：進度 0.0→0.5 透明度 100%→0%，進度 0.5→1.0 透明度保持 0%
                    if (progress <= 0.5) {
                        transitionOpacity = 1.0 - (progress / 0.5); // 從1.0過渡到0.0
                    } else {
                        transitionOpacity = 0.0; // 保持透明
                    }
                } else if (animationType === 'zoomOut') {
                    // 縮小時淡入：進度 0.0→0.5 透明度保持 0%，進度 0.5→1.0 透明度 0%→100%
                    if (progress <= 0.5) {
                        transitionOpacity = 0.0; // 保持透明
                    } else {
                        transitionOpacity = (progress - 0.5) / 0.5; // 從0.0過渡到1.0
                    }
                }

                // 應用到所有點點
                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = transitionOpacity;
                });

                // 可選：添加調試資訊
                // console.log(`🔴 點點過渡透明度: ${animationType}, progress=${progress.toFixed(3)}, opacity=${transitionOpacity.toFixed(3)}`);
            }

            resetDotsTransitionOpacity(opacity) {
                // 重置所有點點的過渡透明度
                if (!this.interactiveDots.length) return;

                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = opacity;
                });

                console.log(`🔴 重置點點透明度: ${(opacity * 100).toFixed(0)}%`);
            }

            // 🔴 ================== 點點過渡透明度控制系統結束 ==================
        }

        // 全域變數用於存取ParallaxViewer實例
        let parallaxViewerInstance = null;

        // 返回按鈕處理函數
        function handleBackButton() {
            if (parallaxViewerInstance) {
                if (parallaxViewerInstance.viewState === 'detail') {
                    // 局部視角：返回主視角
                    parallaxViewerInstance.returnToMainView();
                } else {
                    // 主視角：返回首頁
                    window.location.href = '#';
                }
            } else {
                // 預設行為
                window.location.href = '#';
            }
        }

        // 全螢幕按鈕處理函數
        function handleFullscreenButton() {
            if (!document.fullscreenElement) {
                // 進入全螢幕
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // 退出全螢幕
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // 重置視角按鈕處理函數
        function handleResetViewButton() {
            if (parallaxViewerInstance) {
                parallaxViewerInstance.resetView();
            }
        }

        // 初始化應用程式
        document.addEventListener('DOMContentLoaded', () => {
            parallaxViewerInstance = new ParallaxViewer();
            
            // 全螢幕狀態監聽
            const fullscreenButton = document.getElementById('fullscreen-button');
            const fullscreenIcon = fullscreenButton.querySelector('svg');
            
            function updateFullscreenIcon() {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                    // 全螢幕狀態：顯示退出圖示
                    fullscreenIcon.innerHTML = '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>';
                } else {
                    // 非全螢幕狀態：顯示進入圖示
                    fullscreenIcon.innerHTML = '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>';
                }
            }
            
            // 監聽全螢幕狀態變化
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
            document.addEventListener('msfullscreenchange', updateFullscreenIcon);
            
            // 初始化圖示
            updateFullscreenIcon();
            
            // 觸控裝置檢測和優化
            function detectTouchDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (isMobile) {
                    document.body.classList.add('touch-device');
                    console.log('📱 檢測到行動裝置，啟用觸控優化');
                } else {
                    document.body.classList.add('desktop-device');
                    console.log('🖥️ 檢測到桌面裝置');
                }
            }
            
            // 行動裝置按鈕顯示控制
            function controlMobileButtons() {
                const fullscreenButton = document.getElementById('fullscreen-button');
                const resetViewButton = document.getElementById('reset-view-button');
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // 全螢幕按鈕在所有裝置都顯示
                fullscreenButton.style.display = 'flex';
                
                // 重置視角按鈕只在行動裝置且橫向時顯示
                if (isMobile && isLandscape) {
                    resetViewButton.style.display = 'flex';
                    console.log('📱 行動裝置橫向：顯示重置視角按鈕');
                } else {
                    resetViewButton.style.display = 'none';
                    console.log('🖥️ 桌面裝置或直向：隱藏重置視角按鈕');
                }
            }
            
            // 執行觸控裝置檢測
            detectTouchDevice();
            
            // 執行行動裝置按鈕控制
            controlMobileButtons();
            
            // 監聽視窗大小變化
            window.addEventListener('resize', controlMobileButtons);
        });

        // 開發模式：重置陀螺儀授權狀態（按兩下返回按鈕）
        let backButtonClickCount = 0;
        let backButtonClickTimer = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            const backButton = document.getElementById('back-button');
            if (backButton) {
                backButton.addEventListener('click', () => {
                    backButtonClickCount++;
                    
                    if (backButtonClickTimer) {
                        clearTimeout(backButtonClickTimer);
                    }
                    
                    backButtonClickTimer = setTimeout(() => {
                        if (backButtonClickCount === 2) {
                            // 雙擊重置授權狀態
                            localStorage.removeItem('gyroPermissionGranted');
                            console.log('🔄 陀螺儀授權狀態已重置');
                            location.reload(); // 重新載入頁面
                        }
                        backButtonClickCount = 0;
                    }, 300);
                });
            }
        });
    </script>
</body>
</html>