<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- SEO Basic Settings -->
    <title>Parallax Rabbit - dj0903</title>
    <meta name="description" content="Trying to create a bit of immersive narrative space with web technology~ Supports interactive operations on computers, phones, tablets and other devices.">
    <meta name="keywords" content="parallax effect,interactive web,immersive experience,dj0903,web design,Three.js">
    <meta name="author" content="dj0903">
    
    <!-- Multi-language Support -->
    <link rel="alternate" hreflang="zh" href="https://dj0903-parallax-rabbit.vercel.app/zh/">
    <link rel="alternate" hreflang="en" href="https://dj0903-parallax-rabbit.vercel.app/en/">
    <link rel="alternate" hreflang="ja" href="https://dj0903-parallax-rabbit.vercel.app/ja/">
    <link rel="alternate" hreflang="x-default" href="https://dj0903-parallax-rabbit.vercel.app/zh/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../images/icon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../images/icon/favicon.svg" />
    <link rel="shortcut icon" href="../images/icon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../images/icon/apple-touch-icon.png" />
    <link rel="manifest" href="../images/icon/site.webmanifest" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:title" content="Parallax Rabbit | dj0903's First Interactive Web Project!">
    <meta property="og:description" content="Trying to create a bit of immersive narrative space with web technology~ Supports interactive operations on computers, phones, tablets and other devices.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://dj0903-parallax-rabbit.vercel.app/en/">
    <meta property="og:image" content="https://dj0903-parallax-rabbit.vercel.app/images/1_0_All.png">
    <meta property="og:site_name" content="Parallax Rabbit">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Parallax Rabbit | dj0903's First Interactive Web Project!">
    <meta name="twitter:description" content="Trying to create a bit of immersive narrative space with web technology~ Supports interactive operations on computers, phones, tablets and other devices.">
    <meta name="twitter:image" content="https://dj0903-parallax-rabbit.vercel.app/images/1_0_All.png">
    
    <!-- 字體載入 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&family=Noto+Serif+TC:wght@200;300;400;500&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            /* 📱 確保html在方向變化時正確處理 */
            width: 100vw;
            height: 100vh;
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            overflow: hidden;
        }
        
        /* 📱 高解析螢幕支援：確保元素在高解析螢幕上清晰顯示 */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            /* 高解析螢幕優化 */
            * {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-rendering: optimizeLegibility;
            }
            
            /* 確保按鈕在高解析螢幕上邊緣清晰 */
            #back-button, #fullscreen-button, #reset-view-button {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
            
            /* 確保載入動畫在高解析螢幕上流暢 */
            .elegant-spinner, .spinner-ring {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
            
            /* 確保粒子效果在高解析螢幕上清晰 */
            .particle {
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                transform: translateZ(0);
            }
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a1a);
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* 📱 確保body在方向變化時正確處理 */
            width: 100vw;
            height: 100vh;
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            /* 📱 確保容器在方向變化時正確處理 */
            min-width: 100vw;
            min-height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* 🖥️ 全螢幕模式處理 */
        :fullscreen {
            background: #000000;
        }
        
        :-webkit-full-screen {
            background: #000000;
        }
        
        :-moz-full-screen {
            background: #000000;
        }
        
        :-ms-fullscreen {
            background: #000000;
        }
        
        /* 全螢幕模式下的容器處理 */
        :fullscreen #container {
            width: 100vw;
            height: 100vh;
        }
        
        :-webkit-full-screen #container {
            width: 100vw;
            height: 100vh;
        }
        
        :-moz-full-screen #container {
            width: 100vw;
            height: 100vh;
        }
        
        :-ms-fullscreen #container {
            width: 100vw;
            height: 100vh;
        }

        /* 🎭 三層級架構 Z-Index 定義 */
        /* 層級 3: UI 層 (z-index: 3000+) */
        #back-button {
            position: fixed;
            top: 25px;
            left: 25px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI 層：最上層 */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #back-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #back-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #back-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #back-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: translateX(-1px);
        }

        #back-button:active svg {
            stroke: #f4e3d4;
            transform: translateX(-1px) scale(0.95);
        }

        /* 全螢幕按鈕 - 在所有裝置顯示 */
        #fullscreen-button {
            position: fixed;
            top: 25px;
            right: 25px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI 層：最上層 */
            display: flex; /* 在所有裝置顯示 */
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #fullscreen-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #fullscreen-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #fullscreen-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #fullscreen-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: scale(1.1);
        }

        #fullscreen-button:active svg {
            stroke: #f4e3d4;
            transform: scale(0.95);
        }

        /* 重置視角按鈕 - 與其他按鈕保持一致的風格 */
        #reset-view-button {
            position: fixed;
            top: 25px;
            right: 92px; /* 在全螢幕按鈕左邊 */
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000; /* UI 層：最上層 */
            display: none; /* 預設隱藏，與全螢幕按鈕邏輯一致 */
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #reset-view-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #reset-view-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #reset-view-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #reset-view-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: rotate(180deg);
        }

        #reset-view-button:active svg {
            stroke: #f4e3d4;
            transform: rotate(180deg) scale(0.95);
        }

        /* 語言切換按鈕 */
        #language-switch-button {
            position: fixed;
            top: 25px;
            right: 92px; /* 預設在全螢幕按鈕左邊 */
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease, right 0.3s ease;
            backdrop-filter: blur(12px);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        /* 當重置視角按鈕顯示時，語言按鈕向左移動 */
        .touch-device #language-switch-button {
            right: 159px; /* 在重置視角按鈕左邊 */
        }

        #language-switch-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(244, 227, 212, 0.4);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(244, 227, 212, 0.1);
        }

        #language-switch-button:active {
            transform: translateY(0) scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        #language-switch-button svg {
            width: 20px;
            height: 20px;
            stroke: #f4e3d4;
            fill: none;
            transition: transform 0.3s ease, filter 0.15s ease;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
        }

        #language-switch-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 12px rgba(244, 227, 212, 0.6));
            transform: scale(1.1);
        }

        #language-switch-button:active svg {
            stroke: #f4e3d4;
            transform: scale(0.95);
        }

        /* 語言選單 */
        #language-menu {
            position: fixed;
            top: 80px;
            right: 92px; /* 預設對齊語言按鈕 */
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px 0;
            z-index: 3001;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(-10px) scale(0.9);
            transition: all 0.3s ease, right 0.3s ease;
            pointer-events: none;
            min-width: 120px;
        }

        /* 當重置視角按鈕顯示時，語言選單向左移動 */
        .touch-device #language-menu {
            right: 159px;
        }

        #language-menu.show {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .language-option {
            display: flex;
            align-items: center;
            justify-content: center; /* 置中排列 */
            padding: 10px 16px;
            color: #f4e3d4;
            text-decoration: none;
            font-size: 14px;
            font-weight: 400;
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: center; /* 文字置中 */
        }

        /* 📱 觸控裝置語言選單適配 */
        @media (hover: none) and (pointer: coarse) {
            #language-menu {
                min-width: 100px !important; /* 縮小框框寬度 */
                padding: 6px 0 !important; /* 縮小框框內距 */
                top: 70px !important; /* 調整位置適配按鈕縮小 */
            }
            
            .language-option {
                font-size: 12px !important; /* 行動裝置文字大小 */
                padding: 8px 12px !important; /* 縮小選項內距 */
            }
        }

        .language-option:hover {
            background: rgba(244, 227, 212, 0.2); /* 更亮的hover底色 */
            color: #f4e3d4;
        }

        .language-option.current {
            background: rgba(244, 227, 212, 0.1); /* 較暗的選中底色 */
            color: #f4e3d4;
            cursor: default;
            opacity: 0.9;
        }

        .language-option.current:hover {
            background: rgba(244, 227, 212, 0.1); /* 選中狀態hover不變色 */
        }

        .language-flag {
            margin-right: 8px;
            font-size: 16px;
        }

        /* 響應式調整 - 移除語言按鈕的max-width設定，改用觸控裝置統一設定 */

        /* 層級 2: 載入層 (z-index: 2000+) */
        #loading-cover {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 2000; /* 載入層：中間層 */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #loading-cover.fade-in {
            opacity: 1;
            transition: opacity 0.5s ease; /* 明確設定淡入時間 */
        }

        @keyframes fadeOut { 
            0% { opacity: 1; } 
            80% { opacity: 0.15; } 
            100% { opacity: 0; } 
        }
        
        #loading-cover.fade-out { 
            animation: fadeOut 0.9s ease-out forwards; 
            will-change: opacity;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2001; /* 載入層：載入動畫 */
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        #loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-container {
            position: relative;
            padding: 40px;
        }



        .elegant-spinner {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
        }

        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
        }

        .spinner-ring:nth-child(1) {
            border-top: 2px solid #dc9c3b;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .spinner-ring:nth-child(2) {
            border-right: 2px solid #d1936b;
            transform: scale(0.8);
            filter: drop-shadow(0 0 6px rgba(209, 147, 107, 0.4));
        }

        .spinner-ring:nth-child(3) {
            border-bottom: 2px solid #f4e3d4;
            transform: scale(0.6);
            filter: drop-shadow(0 0 4px rgba(244, 227, 212, 0.3));
        }

        .loading-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 20px;
        }

        .dot {
            width: 5px;
            height: 5px;
            background: #dc9c3b;
            border-radius: 50%;
            animation: dotPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(220, 156, 59, 0.5);
        }

        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.3s; }
        .dot:nth-child(3) { animation-delay: 0.6s; }

        .loading-particles {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 200px;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            opacity: 0;
            animation: particleFloat 4s linear infinite, particleGlow 2s ease-in-out infinite alternate;
            bottom: 5px; /* 初始位置在容器底部外面 */
            filter: brightness(1.2);
        }

        @keyframes titleGlow {
            0% { 
                text-shadow: 0 0 20px rgba(244, 227, 212, 0.5);
                transform: scale(1) translateZ(0);
            }
            100% { 
                text-shadow: 0 0 30px rgba(244, 227, 212, 0.8), 0 0 40px rgba(220, 156, 59, 0.3);
                transform: scale(1.02) translateZ(0);
            }
        }

        @keyframes elegantSpin {
            0% { transform: rotate(0deg) translateZ(0); }
            100% { transform: rotate(360deg) translateZ(0); }
        }

        @keyframes dotPulse {
            0%, 100% { 
                transform: scale(1) translateZ(0); 
                opacity: 0.3; 
            }
            50% { 
                transform: scale(1.3) translateZ(0); 
                opacity: 1; 
                box-shadow: 0 0 15px rgba(220, 156, 59, 0.8);
            }
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(0) scale(0) translateZ(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(-20px) scale(1) translateZ(0);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-250px) scale(1) translateZ(0);
                opacity: 0;
            }
        }



        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2002; /* 載入層：錯誤訊息 */
        }

        /* 🌟 統一字體系統 */
        * {
            font-family: 'Noto Serif TC', 'Cormorant Garamond', 'Georgia', 'Times New Roman', 'Times', serif;
        }

        /* 英文專用字體（僅用於需要英文襯線字體的地方） */
        .english-font {
            font-family: 'Cormorant Garamond', 'Georgia', 'Times New Roman', 'Times', serif;
        }

        /* 💡 提示文字樣式 - 優雅簡潔 */
        .hint-text {
            position: fixed;
            bottom: 8vh;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .hint-text.show {
            opacity: 1;
        }

        .hint-content {
            font-size: 15px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.95);
            text-align: center;
            letter-spacing: 0.8px;
            line-height: 1.5;
            text-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.8),
                0 1px 3px rgba(0, 0, 0, 0.6);
            white-space: nowrap;
            position: relative;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: opacity 0.3s ease, filter 0.3s ease;
            justify-content: center;
        }

        /* 主視角提示文字 */
        .main-hint {
            opacity: 1;
            filter: blur(0px);
        }

        /* 局部視角提示文字 */
        .detail-hint {
            opacity: 0;
            filter: blur(5px);
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            display: flex;
            justify-content: center;
        }

        /* 過渡狀態 */
        .hint-content.transitioning {
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        /* 裝飾線 */
        .hint-content::before,
        .hint-content::after {
            content: '';
            flex-shrink: 0;
            width: 30px;
            height: 1px;
            background: rgba(255, 255, 255, 0.6);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        /* 📱 觸控裝置專用設定 - 確保橫屏直屏文字大小一致 */
        @media (hover: none) and (pointer: coarse) {
            .hint-text {
                bottom: 10vh;
            }
            
            .hint-content {
                font-size: clamp(12px, 2.5vw, 14px) !important; /* 響應式文字大小 */
                gap: clamp(8px, 1.5vw, 16px) !important;
                white-space: nowrap;
                max-width: 90vw;
                overflow: hidden;
                text-overflow: ellipsis;
                justify-content: center;
            }

            .hint-content::before,
            .hint-content::after {
                width: clamp(16px, 2vw, 24px) !important;
            }

            /* 確保局部視角提示文字在觸控裝置上正確對齊 */
            .detail-hint {
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: 100% !important;
                display: flex !important;
                justify-content: center !important;
            }
        }

        /* 📱 橫向觀看提示樣式 */
        .landscape-hint {
            display: none; /* 預設隱藏 */
        }

        /* 📱 行動裝置直屏時顯示橫向觀看提示 - 統一邏輯支援手機和平板 */
        @media screen and (max-width: 1024px) and (orientation: portrait) {
            .landscape-hint {
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
                gap: 15px !important;
            }
            
            /* 隱藏原本的提示文字 */
            .hint-text:not(.landscape-hint) {
                display: none !important;
            }
        }

        /* 📱 觸控裝置直屏時顯示橫向觀看提示 - 確保iPad等平板也能正確顯示 */
        @media (hover: none) and (pointer: coarse) and (orientation: portrait) {
            .landscape-hint {
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
                gap: 15px !important;
            }
            
            /* 隱藏原本的提示文字 */
            .hint-text:not(.landscape-hint) {
                display: none !important;
            }
        }

        /* 📱 確保橫屏時隱藏橫向觀看提示 */
        @media screen and (max-width: 1024px) and (orientation: landscape) {
            .landscape-hint {
                display: none !important;
            }
            
            /* 確保正常提示文字在橫屏時顯示 */
            .hint-text:not(.landscape-hint) {
                display: flex !important;
            }
        }

        /* 📱 觸控裝置橫屏時隱藏橫向觀看提示 */
        @media (hover: none) and (pointer: coarse) and (orientation: landscape) {
            .landscape-hint {
                display: none !important;
            }
            
            /* 確保正常提示文字在觸控裝置橫屏時顯示 */
            .hint-text:not(.landscape-hint) {
                display: flex !important;
            }
        }

        /* 📱 手機旋轉圖示樣式 */
        .phone-rotate-icon {
            width: 40px;
            height: 54px;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: phoneRotate 2s ease-in-out infinite;
        }

        .phone-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.8)) drop-shadow(0 1px 3px rgba(0, 0, 0, 0.6));
        }

        .phone-body {
            fill: none;
            stroke: rgba(255, 255, 255, 0.95);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .phone-notch {
            fill: rgba(255, 255, 255, 0.95);
        }

        .rotate-arrow {
            fill: none;
            stroke: rgba(255, 255, 255, 0.95);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        /* 📱 手機旋轉動畫 */
        @keyframes phoneRotate {
            0%, 100% {
                transform: rotate(0deg);
            }
            50% {
                transform: rotate(-90deg);
            }
        }

        /* 📱 箭頭脈衝動畫 */
        @keyframes arrowPulse {
            0%, 100% {
                opacity: 0.7;
                stroke-width: 2;
            }
            50% {
                opacity: 1;
                stroke-width: 2.5;
            }
        }

        /* 💬 按鈕提示對話框樣式 */
        .button-tooltip {
            position: fixed;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transform: scale(0.3) translateY(-20px);
            transition: opacity 0.4s ease, transform 0.4s ease, left 0.15s ease, top 0.15s ease;
            transform-origin: top center;
        }

        .button-tooltip.show {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }

        .tooltip-arrow {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(244, 227, 212, 0.3);
        }

        .tooltip-content {
            background: rgba(244, 227, 212, 0.3);
            border-radius: 12px;
            padding: 8px 10px;
            text-align: center;
            width: fit-content;
            min-width: 44px;
            max-width: 66px;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transform-origin: top center;
        }

        .tooltip-title {
            font-size: 12px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 6px;
            line-height: 1.2;
            white-space: nowrap;
        }

        .tooltip-subtitle {
            font-size: 9px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.2;
            white-space: nowrap;
        }

        /* 滑鼠懸停效果 */
        .tooltip-content:hover {
            background: rgba(244, 227, 212, 0.6);
            transform: scale(1.02);
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .tooltip-content:hover ~ .tooltip-arrow {
            border-bottom-color: rgba(244, 227, 212, 0.6);
            transition: border-bottom-color 0.2s ease;
        }

        /* 🎮 陀螺儀授權按鈕樣式 - 極簡風格 */
        .gyro-permission {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 3001; /* 在返回按鈕之上，但在載入層之下 */
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            pointer-events: none; /* 修正：隱藏時不阻擋互動 */
        }

        .gyro-permission.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* 顯示時才可互動 */
        }

        .gyro-permission-content {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            max-width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .gyro-permission-icon {
            font-size: 24px;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 8px rgba(220, 156, 59, 0.6));
        }

        .gyro-permission-title {
            font-size: 16px;
            font-weight: 500;
            color: #f4e3d4;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(244, 227, 212, 0.3);
        }

        .gyro-permission-desc {
            font-size: 12px;
            color: rgba(244, 227, 212, 0.7);
            line-height: 1.4;
            margin-bottom: 16px;
        }

        .gyro-permission-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .gyro-permission-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #f4e3d4;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            width: fit-content;
            min-width: 60px;
            white-space: nowrap;
        }

        .gyro-permission-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(220, 156, 59, 0.4);
        }

        .gyro-permission-btn.primary {
            background: rgba(220, 156, 59, 0.2);
            border-color: rgba(220, 156, 59, 0.5);
        }

        .gyro-permission-btn.primary:hover {
            background: rgba(220, 156, 59, 0.3);
            border-color: rgba(220, 156, 59, 0.7);
            box-shadow: 0 0 20px rgba(220, 156, 59, 0.6);
        }

        /* 📱 觸控裝置對話框文字固定大小 - 確保橫屏直屏一致 */
        @media (hover: none) and (pointer: coarse) {
            .tooltip-title {
                font-size: 10px !important; /* 固定標題大小 */
            }
            
            .tooltip-subtitle {
                font-size: 8px !important; /* 固定副標題大小 */
            }
            
            .tooltip-content {
                min-width: 40px !important;
                max-width: 60px !important;
                padding: 6px 8px !important;
            }
        }

        /* 📱 觸控裝置陀螺儀授權對話框適配 */
        @media (hover: none) and (pointer: coarse) {
            .gyro-permission {
                bottom: 20px;
                right: 20px;
                /* 移除 left: 20px，保持右下角定位 */
            }
            
            .gyro-permission-content {
                max-width: 280px; /* 保持原本的寬度限制 */
                padding: 16px;
            }
            
            .gyro-permission-buttons {
                flex-direction: column;
                gap: 6px;
                align-items: center;
            }
            
            .gyro-permission-btn {
                padding: 10px 16px;
                font-size: 14px;
                width: fit-content;
                min-width: 60px;
                white-space: nowrap;
            }
        }

        #error-message {
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            max-width: 80%;
            display: none;
        }



        /* 層級 1: 內容層 (z-index: 1000+) */
        #canvas {
            display: block;
            z-index: 1000; /* 內容層：最下層 */
            width: 100vw;
            height: 100vh;
            /* 📱 高解析螢幕支援：確保canvas在高解析螢幕上清晰 */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        #loading-canvas {
            display: block;
            z-index: 2000; /* 載入層 */
            width: 100vw;
            height: 100vh;
            /* 📱 高解析螢幕支援：確保載入canvas在高解析螢幕上清晰 */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* 純觸控裝置：禁用hover效果（僅限於沒有滑鼠的裝置） */
        @media (hover: none) and (pointer: coarse) and (max-width: 1024px) {
            /* 觸控裝置：調整過渡動畫時間，讓點擊效果更明顯 */
            #back-button, #fullscreen-button, #reset-view-button, #language-switch-button {
                transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            }
            
            #back-button svg, #fullscreen-button svg, #reset-view-button svg, #language-switch-button svg {
                transition: transform 0.15s ease, filter 0.2s ease;
            }
            
            /* 觸控裝置：禁用語言按鈕hover效果 */
            #language-switch-button:hover {
                background: rgba(255, 255, 255, 0.08);
                border-color: rgba(255, 255, 255, 0.2);
                transform: none;
                box-shadow: 
                    0 4px 16px rgba(0, 0, 0, 0.1),
                    0 1px 4px rgba(0, 0, 0, 0.05);
            }
            
            #language-switch-button:hover svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
                transform: none;
            }
            

            
            /* 觸控裝置：加強active狀態的視覺回饋，更明顯的效果 */
            #back-button:active, #fullscreen-button:active, #reset-view-button:active, #language-switch-button:active {
                background: rgba(255, 255, 255, 0.35);
                border-color: rgba(244, 227, 212, 0.7);
                transform: translateY(1px) scale(0.85);
                box-shadow: 
                    0 1px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 3px rgba(244, 227, 212, 0.3),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.1s ease;
            }
            
            #back-button:active svg, #fullscreen-button:active svg, #reset-view-button:active svg, #language-switch-button:active svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
                transform: scale(0.85);
                transition: all 0.1s ease;
            }
        }

        /* 📱 小螢幕觸控裝置：額外的觸控優化 */
        @media (hover: none) and (pointer: coarse) and (max-width: 480px) {
            #back-button, #fullscreen-button, #reset-view-button, #language-switch-button {
                transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            }
            
            #back-button svg, #fullscreen-button svg, #reset-view-button svg, #language-switch-button svg {
                transition: transform 0.15s ease, filter 0.2s ease;
            }
            
            #back-button:active, #fullscreen-button:active, #reset-view-button:active, #language-switch-button:active {
                background: rgba(255, 255, 255, 0.35);
                border-color: rgba(244, 227, 212, 0.7);
                transform: translateY(1px) scale(0.85);
                box-shadow: 
                    0 1px 4px rgba(0, 0, 0, 0.3),
                    0 0 0 3px rgba(244, 227, 212, 0.3),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.1s ease;
            }
            
            #back-button:active svg, #fullscreen-button:active svg, #reset-view-button:active svg, #language-switch-button:active svg {
                stroke: #f4e3d4;
                filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
                transform: scale(0.85);
                transition: all 0.1s ease;
            }
        }

        /* JavaScript檢測的觸控裝置優化 */
        .touch-device #back-button,
        .touch-device #fullscreen-button,
        .touch-device #reset-view-button,
        .touch-device #language-switch-button {
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
        }
        
        .touch-device #back-button svg,
        .touch-device #fullscreen-button svg,
        .touch-device #reset-view-button svg,
        .touch-device #language-switch-button svg {
            transition: transform 0.15s ease, filter 0.2s ease;
        }
        
        .touch-device #back-button:hover,
        .touch-device #fullscreen-button:hover,
        .touch-device #reset-view-button:hover,
        .touch-device #language-switch-button:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: none;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.1),
                0 1px 4px rgba(0, 0, 0, 0.05);
        }
        
        .touch-device #back-button:hover svg,
        .touch-device #fullscreen-button:hover svg,
        .touch-device #reset-view-button:hover svg,
        .touch-device #language-switch-button:hover svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 8px rgba(244, 227, 212, 0.3));
            transform: none;
        }
        
        .touch-device #back-button:active,
        .touch-device #fullscreen-button:active,
        .touch-device #reset-view-button:active,
        .touch-device #language-switch-button:active {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(244, 227, 212, 0.7);
            transform: translateY(1px) scale(0.85);
            box-shadow: 
                0 1px 4px rgba(0, 0, 0, 0.3),
                0 0 0 3px rgba(244, 227, 212, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.1s ease;
        }
        
        .touch-device #back-button:active svg,
        .touch-device #fullscreen-button:active svg,
        .touch-device #reset-view-button:active svg,
        .touch-device #language-switch-button:active svg {
            stroke: #f4e3d4;
            filter: drop-shadow(0 0 20px rgba(244, 227, 212, 1.0));
            transform: scale(0.85);
            transition: all 0.1s ease;
        }





        /* 📱 觸控裝置按鈕統一設定 - 確保橫屏直屏一致 */
        @media (hover: none) and (pointer: coarse) {
            #back-button {
                width: 40px;
                height: 40px;
                top: 20px;
                left: 20px;
            }
            
            #back-button svg {
                width: 18px;
                height: 18px;
            }
            
            #fullscreen-button {
                width: 40px;
                height: 40px;
                top: 20px;
                right: 20px;
            }
            
            #fullscreen-button svg {
                width: 18px;
                height: 18px;
            }
            
            #reset-view-button {
                width: 40px;
                height: 40px;
                top: 20px;
                right: 86px;
            }
            
            #reset-view-button svg {
                width: 18px;
                height: 18px;
            }
            
            #language-switch-button {
                width: 40px;
                height: 40px;
                top: 20px;
                right: 20px; /* 預設在全螢幕按鈕位置 */
            }
            
            #language-switch-button svg {
                width: 18px;
                height: 18px;
            }
            
            /* 當重置視角按鈕顯示時，語言按鈕向左移動 */
            .touch-device #language-switch-button {
                right: 152px; /* 在重置視角按鈕左邊 */
            }
            
            #language-menu {
                top: 70px; /* 調整選單位置 */
                right: 20px; /* 預設對齊語言按鈕 */
            }
            
            /* 當重置視角按鈕顯示時，語言選單向左移動 */
            .touch-device #language-menu {
                right: 152px;
            }
        }



        @media (max-width: 768px) {
            .loading-container {
                padding: 20px;
            }
            
            .elegant-spinner {
                width: 60px;
                height: 60px;
                margin: 0 auto 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading-cover">
            <canvas id="loading-canvas"></canvas>
        </div>
        
        <div id="loading">
            <div class="loading-container">
                <div class="loading-particles" id="particles"></div>
                <div class="elegant-spinner">
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                </div>
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>
        
        <div id="error-message">
            <h3>⚠️ <span data-i18n="errors.texture_load_failed">Failed to load image resources. Please check your internet connection and refresh the page.</span></h3>
            <p data-i18n="errors.cors_message">Please use a local server to open this webpage to avoid CORS issues</p>
            <br>
            <p><strong data-i18n="errors.suggested_solutions">Suggested Solutions:</strong></p>
            <p>1. <span data-i18n="errors.python_solution">Use Python:</span> <code>python -m http.server 8000</code></p>
            <p>2. <span data-i18n="errors.nodejs_solution">Use Node.js:</span> <code>npx http-server</code></p>
            <p>3. <span data-i18n="errors.vscode_solution">Use VS Code Live Server extension</span></p>
        </div>
        
        <button id="back-button" onclick="handleBackButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
        </button>

        <!-- 全螢幕按鈕 - 所有裝置可用 -->
        <button id="fullscreen-button" onclick="handleFullscreenButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
        </button>

        <!-- 重置視角按鈕 -->
        <button id="reset-view-button" onclick="handleResetViewButton()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <!-- 外圈 -->
                <circle cx="12" cy="12" r="8"/>
                <!-- 上下左右四個短線 -->
                <line x1="12" y1="1" x2="12" y2="6.5"/>
                <line x1="12" y1="17.5" x2="12" y2="23"/>
                <line x1="1" y1="12" x2="6.5" y2="12"/>
                <line x1="17.5" y1="12" x2="23" y2="12"/>
                <!-- 中心實心點 -->
                <circle cx="12" cy="12" r="1" fill="currentColor"/>
            </svg>
        </button>

        <!-- 語言切換按鈕 -->
        <button id="language-switch-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="2" y1="12" x2="22" y2="12"/>
                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
            </svg>
        </button>

        <!-- 語言選單 -->
        <div id="language-menu">
            <button class="language-option" data-lang="zh">
                <span>繁體中文</span>
            </button>
            <button class="language-option" data-lang="en">
                <span>English</span>
            </button>
            <button class="language-option" data-lang="ja">
                <span>日本語</span>
            </button>
        </div>

        <!-- 按鈕提示對話框 -->
        <div id="fullscreen-tooltip" class="button-tooltip">
            <div class="tooltip-content">
                <div class="tooltip-title" data-i18n="ui.fullscreen">Fullscreen</div>
                <div class="tooltip-subtitle" data-i18n="ui.click_to_close">Click to close</div>
            </div>
            <div class="tooltip-arrow"></div>
        </div>

        <div id="reset-view-tooltip" class="button-tooltip">
            <div class="tooltip-content">
                <div class="tooltip-title" data-i18n="ui.reset_view">Reset View</div>
                <div class="tooltip-subtitle" data-i18n="ui.click_to_close">Click to close</div>
            </div>
            <div class="tooltip-arrow"></div>
        </div>

        <!-- 🎮 iOS陀螺儀授權按鈕 - 極簡風格 -->
        <div id="gyro-permission" class="gyro-permission">
            <div class="gyro-permission-content">
                <div class="gyro-permission-icon">🎮</div>
                <div class="gyro-permission-title" data-i18n="gyro.title">Gyroscope Permission</div>
                <div class="gyro-permission-desc" data-i18n="gyro.description">This website uses device orientation to enhance the interactive experience. Please allow access to provide a more immersive experience.</div>
                <div class="gyro-permission-buttons">
                    <button id="enable-gyro-btn" class="gyro-permission-btn primary" data-i18n="gyro.allow">Allow</button>
                </div>
            </div>
        </div>
        
        <canvas id="canvas"></canvas>
        
        <!-- 提示文字 -->
        <div id="hint-text" class="hint-text">
            <!-- 主視角提示文字 -->
            <span class="hint-content main-hint" data-i18n="interaction.main_view_desktop">Move your mouse to rotate the view</span>
            <!-- 局部視角提示文字 -->
            <span class="hint-content detail-hint" data-i18n="interaction.detail_view">Click anywhere to return to main view</span>
        </div>
        
        <!-- 橫向觀看提示文字 -->
        <div id="landscape-hint" class="hint-text landscape-hint">
            <!-- 手機旋轉圖示 -->
            <div class="phone-rotate-icon">
                <svg viewBox="0 0 60 100" class="phone-svg">
                    <!-- 手機外框 -->
                    <rect x="12" y="20" width="36" height="60" rx="6" ry="6" class="phone-body"/>
                    <!-- 劉海 -->
                    <rect x="25" y="24" width="10" height="3" rx="1.5" ry="1.5" class="phone-notch"/>
                    <!-- 左上角箭頭 -->
                    <path d="M 56 29 L 56 20 Q 56 11 47 11 L 38 11 M 43 6 L 38 11 L 43 16" class="rotate-arrow"/>
                    <!-- 右下角箭頭 -->
                    <path d="M 4 71 L 4 80 Q 4 89 13 89 L 22 89 M 17 94 L 22 89 L 17 84" class="rotate-arrow"/>
                </svg>
            </div>
            <span class="hint-content" data-i18n="interaction.landscape_hint">請橫向觀看以獲得更好的體驗</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../js/i18n.js"></script>
    <script>
        class ParallaxViewer {
            constructor() {
                // 🎭 三層級架構系統
                this.uiLayer = null;           // 最上層：UI 控制元素
                this.loadingLayer = null;      // 中間層：封面圖與載入動畫
                this.contentLayer = null;      // 最下層：主要內容圖層組
                
                // Three.js 場景系統
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.loadingScene = null;
                this.loadingCamera = null;
                this.loadingRenderer = null;
                
                // 圖層管理
                this.layers = [];              // 主要內容圖層 (7_BG~1_RabbitFornt)
                this.mainLayerGroup = null;    // 主要圖層組容器
                this.dotsGroup = null;         // 互動點點容器
                this.detailGroup1 = null;      // 局部圖容器1
                this.detailGroup2 = null;      // 局部圖容器2
                this.detailGroup3 = null;      // 局部圖容器3
                this.detailLayers = [];        // 局部圖層陣列
                
                // 🎯 視角狀態管理
                this.viewState = 'main';       // 'main' | 'detail'
                this.currentDetailDot = null;  // 當前放大的點點
                this.isTransitioning = false;  // 是否正在過渡動畫中
                
                // 🎯 相機變換參數
                this.originalCameraPosition = { x: 0, y: 0, z: 5 };
                // targetCameraPosition 將在需要時動態計算，不再使用固定值
                this.originalScenePosition = { x: 0, y: 0, z: 0 };
                this.targetScenePosition = { x: 0, y: 0, z: 0 };
                
                // 🕹️ 局部視角控制參數
                this.DETAIL_VIEW_INTENSITY = 0.16;    // 局部視角移動強度 (建議範圍: 0.05-0.3)
                this.DETAIL_VIEW_BOUNDARY = 0.26;      // 邊界超出範圍 (相對於圖片大小)
                this.detailViewMouse = { x: 0, y: 0 }; // 局部視角的滑鼠位置
                this.detailViewOffset = { x: 0, y: 0 }; // 局部視角的偏移量
                
                // 🌟 局部圖羽化效果參數
                this.FEATHER_MAIN_VIEW = 5.0;          // 主視角羽化強度 (建議範圍: 0.5-1.0)
                this.FEATHER_DETAIL_VIEW = 0.1;        // 局部視角羽化強度 (建議範圍: 0.0-0.3)
                this.FEATHER_TRANSITION_RANGE = 0.5;   // 羽化影響範圍 (建議範圍: 0.2-0.5)
                
                // 🌫️ 過渡模糊效果參數
                this.TRANSITION_BLUR_STRENGTH = 3;      // 過渡模糊強度 (0-20，建議值：5-15)
                
                // 🔍 局部視角放大設定
                this.DETAIL_ZOOM_SCALE = 4.5;           // 局部視角放大倍率 (建議範圍: 2.0-10.0，預設5.0=500%)
                this.interactiveDots = [];     // 互動點點陣列
                this.raycaster = null;         // 點擊檢測器
                this.mouseVector = null;       // 滑鼠向量
                this.mouse = { x: 0, y: 0 };
                this.targetMouse = { x: 0, y: 0 }; // 目標滑鼠位置
                this.currentMouse = { x: 0, y: 0 }; // 當前插值後的滑鼠位置
                this.mouseInsidePage = true; // 滑鼠是否在頁面內
                this.mouseJustReentered = false; // 滑鼠是否剛重新進入頁面
                this.mouseVelocity = { x: 0, y: 0 }; // 滑鼠移動速度
                this.inertiaTarget = { x: 0, y: 0 }; // 慣性目標位置
                this.isInertiaActive = false; // 是否正在執行慣性緩衝
                this.orientation = { x: 0, y: 0 };
                // 🎛️ 螢幕方向自動轉換機制
                this.currentOrientation = this.getScreenOrientation();
                this.initialOrientation = this.currentOrientation; // 儲存初始方向
                this.baseX = null;           // 統一的X軸基準值
                this.baseY = null;           // 統一的Y軸基準值
                this.smoothedDelta = { x: 0, y: 0 }; // 平滑後的差值
                this.SMOOTH_ALPHA = 0.15;    // 低通濾波係數
                
                // 🎮 混合控制系統
                this.currentControlMode = 'gyro';     // 'gyro' | 'pointer'
                this.gyroActive = false;              // 陀螺儀是否已啟用
                this.lastPointerTime = 0;             // 最後滑鼠活動時間
                this.currentOffsetX = 0;              // 當前X軸偏移
                this.currentOffsetY = 0;              // 當前Y軸偏移
                this.controlTransitionProgress = 0;   // 控制模式切換進度
                this.requiresPermission = false;      // 是否需要iOS授權
                this.isMobile = this.detectMobile();
                this.loadingComplete = false;
                this.loadedImages = 0;
                this.totalImages = 0;
                this.errorCount = 0;
                this.loadingCoverLoaded = false;
                this.coverFadeOutComplete = false;
                this.parallaxTransitionProgress = 0; // 0 = 中心位置, 1 = 滑鼠位置
                
                // 🎛️ 統一視差強度控制 - 調整這些數值來改變整體視差效果
                this.PARALLAX_INTENSITY = 0.27; // 主要控制參數：控制滑鼠/傾斜輸入的影響程度 (建議範圍: 0.05-0.3)
                this.DEPTH_SENSITIVITY = 0.5;  // 深度圖敏感度：控制深度差異的視差幅度 (建議範圍: 0.1-0.5)
                
                // 📱 行動裝置陀螺儀控制
                this.GYRO_SENSITIVITY = 5.0;    // 陀螺儀靈敏度：控制裝置傾斜的敏感程度 (建議範圍: 0.5-2.0)
                this.GYRO_INVERT_X = true;       // 是否反轉X軸 (左右傾斜)：true=裝置左傾時畫面右移
                
                // 🖼️ 統一圖片大小控制
                this.IMAGE_SCALE = 1.02;        // 圖片縮放比例：控制封面圖和主圖的大小 (建議範圍: 0.5-1.5)
                
                // 🫁 呼吸動畫控制
                this.BREATH_SPEED = 0.003;      // 呼吸速度係數：數值越大呼吸越快 (建議範圍: 0.001-0.005)
                
                // 🎯 距離感應互動控制
                this.DISTANCE_INTERACTION_ENABLED = !this.isMobile;  // 桌機版啟用，行動版關閉
                this.MAX_DISTANCE = 0.3;                   // 最大感應距離（相對於主圖寬度）
                this.MIN_SCALE_FACTOR = 0.6;               // 最遠時的最小縮放（60%）
                this.MIN_OPACITY_FACTOR = 0.5;             // 最遠時的最小透明度（50%）
                this.DISTANCE_LERP_SPEED = 0.5;            // 距離動畫過渡速度
                
                // 🔄 重置視角功能
                this.isResetting = false;                  // 是否正在重置視角
                this.isOrientationTransitioning = false;   // 是否正在進行螢幕方向過渡
                this.lastRawX = 0;                         // 最新的原始X值
                this.lastRawY = 0;                         // 最新的原始Y值

                // 🌍 國際化系統
                this.i18n = null;                          // i18n實例

                // 💡 提示文字系統
                this.hintTextElement = null;               // 提示文字元素
                this.landscapeHintElement = null;          // 橫向觀看提示元素
                this.currentHintType = null;               // 當前提示類型

                // 💬 按鈕提示系統
                this.buttonTooltips = {};                  // 按鈕提示元素
                this.tooltipVisible = {};                  // 提示顯示狀態

                /*
                 * 📖 參數說明：
                 * 
                 * PARALLAX_INTENSITY (parallaxOffset 的乘數)：
                 * - 控制滑鼠移動或裝置傾斜對視差的影響程度
                 * - 數值越大，滑鼠移動時視差效果越明顯
                 * - 影響整體視差的"靈敏度"
                 * 
                 * DEPTH_SENSITIVITY (parallaxStrength)：
                 * - 控制深度圖中不同灰階值之間的視差差異
                 * - 數值越大，深度圖的白色和黑色區域視差差異越大
                 * - 影響視差的"深度感"
                 * 
                 * GYRO_SENSITIVITY：
                 * - 控制行動裝置陀螺儀的敏感程度
                 * - 數值越大，裝置傾斜時視差效果越明顯
                 * - 僅影響行動裝置的傾斜控制
                 * 
                 * GYRO_INVERT_X：
                 * - 控制是否反轉左右傾斜的方向
                 * - true：裝置左傾時畫面向右移動（更直觀）
                 * - false：裝置左傾時畫面向左移動
                 * 
                 * 🎯 調整建議：
                 * - 想要更敏感的滑鼠控制 → 增加 PARALLAX_INTENSITY
                 * - 想要更敏感的陀螺儀控制 → 增加 GYRO_SENSITIVITY
                 * - 想要更強烈的深度效果 → 增加 DEPTH_SENSITIVITY  
                 * - 想要更細膩的效果 → 同時降低所有數值
                 */
                
                // 圖層資訊 - 按照從後到前的順序（7最後面，1最前面）
                this.layerInfo = [
                    { name: '0_7_BG' },        // 最底層背景
                    { name: '0_6_RabbitBack' }, // 後方兔子
                    { name: '0_5_Volume' },     // 體積霧
                    { name: '0_4_RabbitMain' }, // 主要兔子
                    { name: '0_3_Text' },       // 文字
                    { name: '0_2_Dust' },       // 塵埃（現在在文字之上）
                    { name: '0_1_RabbitFornt' } // 最前層兔子
                ];
                
                // 🔍 局部圖配置資料 - 與點點對應
                this.detailLayerInfo = [
                    { name: '1_0_All', dotId: 'dot1', group: 'detailGroup1' },
                    { name: '2_0_All', dotId: 'dot2', group: 'detailGroup2' },
                    { name: '3_0_All', dotId: 'dot3', group: 'detailGroup3' }
                ];
                
                this.init();
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       window.innerWidth <= 768;
            }

            // 📱 檢測是否為行動裝置直屏（更可靠的檢測）
            isPortraitMobile() {
                // 方法1：使用User Agent檢測
                const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // 方法2：使用螢幕尺寸檢測（最大寬度1024px且直屏）
                const isSmallScreen = window.innerWidth <= 1024 && window.innerHeight > window.innerWidth;
                
                // 方法3：使用觸控功能檢測
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                
                // 綜合判斷：滿足任一條件且為直屏
                return (isMobileUA || isSmallScreen || (isTouchDevice && window.innerWidth <= 1024)) && 
                       window.innerHeight > window.innerWidth;
            }

            // 🎛️ 獲取當前螢幕方向
            getScreenOrientation() {
                // 優先使用 Screen Orientation API
                if (screen.orientation && screen.orientation.type) {
                    return screen.orientation.type.split('-')[0] + '-' + screen.orientation.type.split('-')[1];
                }
                
                // 回退到角度判斷
                const angle = screen.orientation ? screen.orientation.angle : window.orientation;
                switch (angle) {
                    case 0: return 'portrait-primary';
                    case 90: return 'landscape-primary';
                    case -90:
                    case 270: return 'landscape-secondary';
                    case 180: return 'portrait-secondary';
                    default: return 'portrait-primary';
                }
            }

            // 🎛️ 根據螢幕方向轉換陀螺儀數值
            transformGyroData(alpha, beta, gamma) {
                let x, y;
                
                // 陀螺儀軸向說明：
                // alpha: 水平旋轉（0-360度，通常不用於視差）
                // beta: 前後傾斜（-180到180度，前傾為正，後傾為負）
                // gamma: 左右傾斜（-90到90度，右傾為正，左傾為負）
                
                switch (this.currentOrientation) {
                    case 'portrait-primary':
                        // 直立正向：gamma控制左右，beta控制上下
                        x = gamma;  // 左右傾 → X軸（左右移動）
                        y = beta;   // 前後傾 → Y軸（上下移動）
                        break;
                        
                    case 'portrait-secondary':
                        // 直立倒置：需要反轉軸向
                        x = -gamma; // 左右傾反轉 → X軸
                        y = -beta;  // 前後傾反轉 → Y軸
                        break;
                        
                    case 'landscape-primary':
                        // 橫向正向：beta控制左右，gamma控制上下（但方向需要調整）
                        x = beta;   // 前後傾 → X軸（左右移動）
                        y = -gamma; // 左右傾反轉 → Y軸（上下移動）
                        break;
                        
                    case 'landscape-secondary':
                        // 橫向倒置：需要反轉軸向
                        x = -beta;  // 前後傾反轉 → X軸
                        y = gamma;  // 左右傾 → Y軸
                        break;
                        
                    default:
                        // 預設使用直立正向的映射
                        x = gamma;
                        y = beta;
                }
                
                // 🔧 移除初始橫向補償，因為已經在switch中處理了
                // 這個補償會導致重複的軸向轉換
                
                return { x, y };
            }

            // 🎮 檢測是否需要iOS授權
            checkPermissionRequired() {
                this.requiresPermission = typeof DeviceOrientationEvent !== 'undefined' && 
                                        typeof DeviceOrientationEvent.requestPermission === 'function';
                
                // 檢查是否已經授權過
                if (this.requiresPermission) {
                    const hasGranted = localStorage.getItem('gyroPermissionGranted');
                    if (hasGranted === 'true') {
                        console.log('📱 陀螺儀已授權，直接啟用');
                        return false; // 不需要顯示授權介面
                    }
                }
                
                return this.requiresPermission;
            }

            // 🎮 啟動陀螺儀控制
            async startGyroControl() {
                // 檢查是否需要授權
                if (this.checkPermissionRequired()) {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            console.log('❌ 陀螺儀授權被拒絕，使用滑鼠模式');
                            this.currentControlMode = 'pointer';
                            return false;
                        }
                        console.log('✅ 陀螺儀授權成功');
                        // 儲存授權狀態到本地
                        localStorage.setItem('gyroPermissionGranted', 'true');
                    } catch (error) {
                        console.error('❌ 陀螺儀授權失敗:', error);
                        this.currentControlMode = 'pointer';
                        return false;
                    }
                }

                // 註冊陀螺儀事件
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.gyroUpdate.bind(this));
                    this.gyroActive = true;
                    console.log('🎮 陀螺儀控制已啟用');
                    return true;
                }
                
                return false;
            }

            // 🎮 啟動滑鼠控制
            startPointerControl() {
                if (this.currentControlMode !== 'pointer') {
                    this.currentControlMode = 'pointer';
                    console.log('🖱️ 切換到滑鼠控制模式');
                }
                this.lastPointerTime = Date.now();
            }

            // 🎮 陀螺儀更新
            gyroUpdate(event) {
                if (this.currentControlMode !== 'gyro') return;
                
                // 4. gyroUpdate()：
                if (this.isResetting || this.isOrientationTransitioning) return;   // 動畫期間完全忽略 gyro
                
                // 獲取原始陀螺儀數值
                const alpha = event.alpha || 0;
                const beta = event.beta || 0;
                const gamma = event.gamma || 0;

                // 根據螢幕方向轉換為統一的X/Y軸
                const { x, y } = this.transformGyroData(alpha, beta, gamma);

                // 第一次進來時建立基準值
                if (this.baseX === null) {
                    this.baseX = x;
                    this.baseY = y;
                    console.log('🎛️ 建立統一基準值:', {
                        orientation: this.currentOrientation,
                        baseX: this.baseX.toFixed(2),
                        baseY: this.baseY.toFixed(2)
                    });
                    return;
                }

                // 計算差值
                let deltaX = (x - this.baseX) / 45;
                let deltaY = (y - this.baseY) / 45;

                // 應用靈敏度參數
                deltaX *= this.GYRO_SENSITIVITY;
                deltaY *= this.GYRO_SENSITIVITY;

                // 限制範圍
                deltaX = THREE.MathUtils.clamp(deltaX, -1, 1);
                deltaY = THREE.MathUtils.clamp(deltaY, -1, 1);

                // 應用左右反轉設定
                if (this.GYRO_INVERT_X) {
                    deltaX = -deltaX;
                }

                // 低通濾波平滑處理
                this.smoothedDelta.x = this.smoothedDelta.x * (1 - this.SMOOTH_ALPHA) + deltaX * this.SMOOTH_ALPHA;
                this.smoothedDelta.y = this.smoothedDelta.y * (1 - this.SMOOTH_ALPHA) + deltaY * this.SMOOTH_ALPHA;

                // 更新當前偏移值
                this.currentOffsetX = this.smoothedDelta.x;
                this.currentOffsetY = this.smoothedDelta.y;
                
                // 🔍 調試資訊：每100次輸出一次，避免過多日誌
                if (!this.debugCounter) this.debugCounter = 0;
                this.debugCounter++;
                if (this.debugCounter % 100 === 0) {
                    console.log('🎛️ 陀螺儀調試:', {
                        orientation: this.currentOrientation,
                        raw: { alpha: alpha.toFixed(1), beta: beta.toFixed(1), gamma: gamma.toFixed(1) },
                        transformed: { x: x.toFixed(1), y: y.toFixed(1) },
                        delta: { deltaX: deltaX.toFixed(3), deltaY: deltaY.toFixed(3) },
                        smoothed: { x: this.smoothedDelta.x.toFixed(3), y: this.smoothedDelta.y.toFixed(3) }
                    });
                }
                
                // 🔄 儲存最新的原始X/Y值
                this.lastRawX = x;
                this.lastRawY = y;
            }

            // 🎮 滑鼠更新
            pointerUpdate(x, y) {
                if (this.currentControlMode !== 'pointer') return;
                if (this.isResetting || this.isOrientationTransitioning) return; // 🔄 重置期間不處理滑鼠輸入

                // 使用原本的滑鼠位置計算公式：產生 -1 到 +1 的範圍
                const newX = (x / window.innerWidth) * 2 - 1;
                const newY = -(y / window.innerHeight) * 2 + 1; // Y軸反轉

                // 更新目標滑鼠位置（用於插值系統）
                this.targetMouse.x = newX;
                this.targetMouse.y = newY;
                
                // 🔧 修正：不要直接更新currentOffsetX/Y，讓updateMousePosition處理插值
                // this.currentOffsetX = newX;
                // this.currentOffsetY = newY;
            }

            // 🎮 控制模式監控
            monitorControlMode() {
                // 🔄 重置期間禁止強制切換模式
                if (this.isResetting || this.isOrientationTransitioning) return;
                
                const now = Date.now();
                
                // 如果是指針模式且超過300ms無活動，切回陀螺儀
                if (this.currentControlMode === 'pointer' && 
                    now - this.lastPointerTime > 300 && 
                    this.gyroActive) {
                    this.currentControlMode = 'gyro';
                    console.log('🔄 自動切換回陀螺儀控制');
                }
                
                // 📱 行動裝置按鈕顯示邏輯
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // 全螢幕按鈕在所有裝置都顯示
                document.getElementById('fullscreen-button').style.display = 'flex';
                
                // 重置視角按鈕在行動裝置上顯示（直式和橫向都顯示）
                if (isMobile) {
                    document.getElementById('reset-view-button').style.display = 'flex';
                } else {
                    document.getElementById('reset-view-button').style.display = 'none';
                }
            }

            // 統一的圖片尺寸計算函數
            calculateImageSize(texture = null) {
                // 如果有傳入 texture，使用其原始比例；否則使用預設比例
                let aspectRatio;
                if (texture && texture.image) {
                    aspectRatio = texture.image.width / texture.image.height;
                    // console.log(`使用圖片原始比例: ${texture.image.width}x${texture.image.height} (比例: ${aspectRatio.toFixed(3)})`);
                } else {
                    aspectRatio = 1920 / 1080; // 新的預設比例
                    // console.log(`使用預設比例: 1920x1080 (比例: ${aspectRatio.toFixed(3)})`);
                }
                
                const distance = 5;
                const fov = 75 * Math.PI / 180;
                const worldHeight = 2 * Math.tan(fov / 2) * distance;
                const worldWidth = worldHeight * (window.innerWidth / window.innerHeight);
                
                // 計算視窗長寬比
                const windowAspectRatio = window.innerWidth / window.innerHeight;
                
                let width, height;
                
                // 自動比較視窗長寬比與圖片長寬比，決定以寬度或高度為主
                if (windowAspectRatio >= aspectRatio) {
                    // 視窗比圖片寬（或相等），以寬度為主
                    width = worldWidth * this.IMAGE_SCALE;
                    height = width / aspectRatio;
                } else {
                    // 視窗比圖片窄，以高度為主
                    height = worldHeight * this.IMAGE_SCALE;
                    width = height * aspectRatio;
                }
                
                return { width, height };
            }

            setupLoadingScene() {
                // 建立載入場景
                this.loadingScene = new THREE.Scene();
                
                // 建立載入相機
                this.loadingCamera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.loadingCamera.position.z = 5;
                
                // 建立載入渲染器
                this.loadingRenderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('loading-canvas'),
                    antialias: true,
                    alpha: true
                });
                
                // 📱 高解析螢幕支援：設定像素比例
                const maxRatio = 2; // 兼顧效能的上限
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.loadingRenderer.setPixelRatio(pixelRatio);
                
                this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // 📱 確保載入canvas元素在DOM中的顯示尺寸正確
                const loadingCanvas = document.getElementById('loading-canvas');
                if (loadingCanvas) {
                    loadingCanvas.style.width = window.innerWidth + 'px';
                    loadingCanvas.style.height = window.innerHeight + 'px';
                }
                this.loadingRenderer.setClearColor(0x000000, 1);
            }

            loadLoadingCover() {
                console.log('開始載入封面圖片...');
                const loader = new THREE.TextureLoader();
                loader.load(
                    '../images/Loading.png',
                    (texture) => {
                        console.log('封面圖片載入成功，開始淡入動畫');
                        this.createLoadingMesh(texture);
                        this.loadingCoverLoaded = true;
                        
                        // 封面圖載入完成後才開始淡入動畫
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            // 淡入動畫完成後開始載入其他圖片
                            setTimeout(() => {
                                console.log('封面圖淡入完成，開始載入其他圖片');
                                this.loadLayers();
                            }, 500); // 等待0.5秒淡入完成
                        }, 50); // 短暫延遲確保渲染完成
                    },
                    undefined,
                    (error) => {
                        console.warn('封面圖片載入失敗，使用黑色背景並開始載入其他圖片');
                        this.loadingCoverLoaded = true;
                        
                        // 即使載入失敗也要開始淡入和載入其他圖片
                        setTimeout(() => {
                            const loadingCover = document.getElementById('loading-cover');
                            loadingCover.classList.add('fade-in');
                            
                            setTimeout(() => {
                                this.loadLayers();
                            }, 500);
                        }, 50);
                    }
                );
            }

            createLoadingMesh(texture) {
                // 使用統一的尺寸計算函數，傳入 texture 以獲取原始比例
                const { width, height } = this.calculateImageSize(texture);

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                // 存儲 texture 引用以便 resize 時重新計算
                mesh.userData.texture = texture;
                this.loadingScene.add(mesh);
            }

            init() {
                // 🌍 初始化i18n系統
                initI18n().then(i18n => {
                    this.i18n = i18n;
                    // i18n載入完成後再初始化其他內容
                    this.setupLoadingScene();
                    this.setupScene();
                    this.setupEventListeners();
                    this.createLoadingParticles(); // 創建載入粒子效果
                    this.randomizeSpinnerRings(); // 設定隨機旋轉效果

                    // 🎭 設定層級引用
                    this.loadingLayer = this.loadingScene; // 載入層：Three.js 場景
                    this.uiLayer = document.getElementById('back-button'); // UI層：DOM 元素

                    // 🎮 初始化混合控制系統
                    this.initControlSystem();

                    // 🔄 重置視角按鈕事件監聽器
                    document.getElementById('reset-view-button').addEventListener('click', this.resetView.bind(this));

                    // 💡 初始化提示文字系統
                    this.initHintText();

                    // 💬 初始化按鈕提示系統
                    this.initButtonTooltips();

                    this.loadLoadingCover(); // 優先載入封面圖
                    this.animate();
                });
            }

            // 💡 初始化提示文字系統
            initHintText() {
                this.hintTextElement = document.getElementById('hint-text');
                this.landscapeHintElement = document.getElementById('landscape-hint');
                
                if (this.hintTextElement) {
                    // 初始化文字內容
                    this.initHintTextContent();
                    
                    // 載入完成後顯示主視角提示
                    setTimeout(() => {
                        this.showMainHint();
                    }, 2000); // 2秒後顯示提示
                }
            }

            // 💡 初始化提示文字內容
            initHintTextContent() {
                if (!this.i18n) return;

                const mainHint = this.hintTextElement.querySelector('.main-hint');
                const detailHint = this.hintTextElement.querySelector('.detail-hint');

                if (mainHint) {
                    // 根據裝置類型設定主視角文字
                    const mainTextKey = this.isMobile ? 'interaction.main_view_mobile' : 'interaction.main_view_desktop';
                    mainHint.textContent = this.i18n.t(mainTextKey);
                    mainHint.setAttribute('data-i18n', mainTextKey);
                    mainHint.setAttribute('lang', this.i18n.getCurrentLanguage());
                }

                if (detailHint) {
                    detailHint.textContent = this.i18n.t('interaction.detail_view');
                    detailHint.setAttribute('data-i18n', 'interaction.detail_view');
                    detailHint.setAttribute('lang', this.i18n.getCurrentLanguage());
                }

                // 初始化橫向觀看提示文字
                if (this.landscapeHintElement) {
                    const landscapeHint = this.landscapeHintElement.querySelector('.hint-content');
                    if (landscapeHint) {
                        landscapeHint.textContent = this.i18n.t('interaction.landscape_hint');
                        landscapeHint.setAttribute('data-i18n', 'interaction.landscape_hint');
                        landscapeHint.setAttribute('lang', this.i18n.getCurrentLanguage());
                    }
                }
            }

            // 💡 顯示主視角提示
            showMainHint() {
                if (!this.hintTextElement) return;
                
                this.currentHintType = 'main';
                
                // 檢查是否為行動裝置直屏（使用更可靠的檢測）
                if (this.isPortraitMobile()) {
                    // 行動裝置直屏：顯示橫向觀看提示
                    if (this.landscapeHintElement) {
                        this.landscapeHintElement.classList.add('show');
                    }
                    this.hintTextElement.classList.remove('show');
                } else {
                    // 桌面裝置或行動裝置橫屏：顯示正常提示
                    this.hintTextElement.classList.add('show');
                    if (this.landscapeHintElement) {
                        this.landscapeHintElement.classList.remove('show');
                    }
                    
                    // 確保主視角文字顯示，局部視角文字隱藏
                    const mainHint = this.hintTextElement.querySelector('.main-hint');
                    const detailHint = this.hintTextElement.querySelector('.detail-hint');
                    
                    if (mainHint) {
                        mainHint.style.opacity = '1';
                        mainHint.style.filter = 'blur(0px)';
                    }
                    if (detailHint) {
                        detailHint.style.opacity = '0';
                        detailHint.style.filter = 'blur(5px)';
                    }
                }
            }

            // 💡 顯示局部視角提示
            showDetailHint() {
                if (!this.hintTextElement) return;
                
                this.currentHintType = 'detail';
                
                // 檢查是否為行動裝置直屏（使用更可靠的檢測）
                if (this.isPortraitMobile()) {
                    // 行動裝置直屏：顯示橫向觀看提示
                    if (this.landscapeHintElement) {
                        this.landscapeHintElement.classList.add('show');
                    }
                    this.hintTextElement.classList.remove('show');
                } else {
                    // 桌面裝置或行動裝置橫屏：顯示正常提示
                    this.hintTextElement.classList.add('show');
                    if (this.landscapeHintElement) {
                        this.landscapeHintElement.classList.remove('show');
                    }
                    
                    // 確保局部視角文字顯示，主視角文字隱藏
                    const mainHint = this.hintTextElement.querySelector('.main-hint');
                    const detailHint = this.hintTextElement.querySelector('.detail-hint');
                    
                    if (mainHint) {
                        mainHint.style.opacity = '0';
                        mainHint.style.filter = 'blur(5px)';
                    }
                    if (detailHint) {
                        detailHint.style.opacity = '1';
                        detailHint.style.filter = 'blur(0px)';
                    }
                }
            }

            // 💡 主視角過渡到局部視角
            transitionToDetailHint(progress) {
                if (!this.hintTextElement) return;
                
                const mainHint = this.hintTextElement.querySelector('.main-hint');
                const detailHint = this.hintTextElement.querySelector('.detail-hint');
                
                if (!mainHint || !detailHint) return;

                if (progress <= 0.25) {
                    // 0-25%: 主視角文字淡出並模糊
                    const opacity = 1 - (progress / 0.25);
                    const blur = (progress / 0.25) * 5;
                    mainHint.style.opacity = opacity;
                    mainHint.style.filter = `blur(${blur}px)`;
                } else if (progress <= 0.75) {
                    // 25-75%: 主視角文字完全隱藏，局部視角文字淡入
                    mainHint.style.opacity = '0';
                    mainHint.style.filter = 'blur(5px)';
                    
                    const detailProgress = (progress - 0.25) / 0.5; // 0-1
                    const opacity = detailProgress;
                    const blur = 5 - (detailProgress * 5);
                    detailHint.style.opacity = opacity;
                    detailHint.style.filter = `blur(${blur}px)`;
                } else {
                    // 75-100%: 局部視角文字完全顯示
                    mainHint.style.opacity = '0';
                    mainHint.style.filter = 'blur(5px)';
                    detailHint.style.opacity = '1';
                    detailHint.style.filter = 'blur(0px)';
                }
            }

            // 💡 局部視角過渡到主視角
            transitionToMainHint(progress) {
                if (!this.hintTextElement) return;
                
                const mainHint = this.hintTextElement.querySelector('.main-hint');
                const detailHint = this.hintTextElement.querySelector('.detail-hint');
                
                if (!mainHint || !detailHint) return;

                if (progress <= 0.25) {
                    // 0-25%: 局部視角文字淡出並模糊
                    const opacity = 1 - (progress / 0.25);
                    const blur = (progress / 0.25) * 5;
                    detailHint.style.opacity = opacity;
                    detailHint.style.filter = `blur(${blur}px)`;
                } else if (progress <= 0.75) {
                    // 25-75%: 局部視角文字完全隱藏，主視角文字淡入
                    detailHint.style.opacity = '0';
                    detailHint.style.filter = 'blur(5px)';
                    
                    const mainProgress = (progress - 0.25) / 0.5; // 0-1
                    const opacity = mainProgress;
                    const blur = 5 - (mainProgress * 5);
                    mainHint.style.opacity = opacity;
                    mainHint.style.filter = `blur(${blur}px)`;
                } else {
                    // 75-100%: 主視角文字完全顯示
                    detailHint.style.opacity = '0';
                    detailHint.style.filter = 'blur(5px)';
                    mainHint.style.opacity = '1';
                    mainHint.style.filter = 'blur(0px)';
                }
            }

            // 💡 隱藏提示文字
            hideHintText() {
                if (this.hintTextElement) {
                    this.hintTextElement.classList.remove('show');
                }
                if (this.landscapeHintElement) {
                    this.landscapeHintElement.classList.remove('show');
                }
            }

            // 📱 更新提示顯示（根據螢幕方向）
            updateHintDisplay() {
                if (!this.hintTextElement) return;
                
                // 檢查是否為行動裝置直屏（使用更可靠的檢測）
                if (this.isPortraitMobile()) {
                    // 行動裝置直屏：顯示橫向觀看提示
                    if (this.landscapeHintElement) {
                        this.landscapeHintElement.classList.add('show');
                    }
                    this.hintTextElement.classList.remove('show');
                } else {
                    // 桌面裝置或行動裝置橫屏：顯示正常提示
                    this.hintTextElement.classList.add('show');
                    if (this.landscapeHintElement) {
                        this.landscapeHintElement.classList.remove('show');
                    }
                }
            }

            // 💬 初始化按鈕提示系統
            initButtonTooltips() {
                this.buttonTooltips = {
                    fullscreen: document.getElementById('fullscreen-tooltip'),
                    resetView: document.getElementById('reset-view-tooltip')
                };

                this.tooltipVisible = {
                    fullscreen: false,
                    resetView: false
                };

                // 初始化提示文字內容
                this.initTooltipContent();

                // 添加點擊事件監聽器
                this.setupTooltipEventListeners();

                // 載入完成後顯示提示
                setTimeout(() => {
                    this.showButtonTooltips();
                }, 2500); // 2.5秒後顯示提示
            }

            // 💬 初始化提示文字內容
            initTooltipContent() {
                if (!this.i18n) return;

                const fullscreenTooltip = this.buttonTooltips.fullscreen;
                const resetViewTooltip = this.buttonTooltips.resetView;

                if (fullscreenTooltip) {
                    const title = fullscreenTooltip.querySelector('.tooltip-title');
                    const subtitle = fullscreenTooltip.querySelector('.tooltip-subtitle');
                    
                    if (title) {
                        title.textContent = this.i18n.t('ui.fullscreen');
                        title.setAttribute('lang', this.i18n.getCurrentLanguage());
                    }
                    if (subtitle) {
                        subtitle.textContent = this.i18n.t('ui.click_to_close');
                        subtitle.setAttribute('lang', this.i18n.getCurrentLanguage());
                    }
                }

                if (resetViewTooltip) {
                    const title = resetViewTooltip.querySelector('.tooltip-title');
                    const subtitle = resetViewTooltip.querySelector('.tooltip-subtitle');
                    
                    if (title) {
                        title.textContent = this.i18n.t('ui.reset_view');
                        title.setAttribute('lang', this.i18n.getCurrentLanguage());
                    }
                    if (subtitle) {
                        subtitle.textContent = this.i18n.t('ui.click_to_close');
                        subtitle.setAttribute('lang', this.i18n.getCurrentLanguage());
                    }
                }
            }

            // 💬 設定提示事件監聽器
            setupTooltipEventListeners() {
                // 全螢幕按鈕提示
                if (this.buttonTooltips.fullscreen) {
                    this.buttonTooltips.fullscreen.addEventListener('click', () => {
                        this.hideButtonTooltip('fullscreen');
                    });
                }
                const fullscreenBtn = document.getElementById('fullscreen-button');
                if (fullscreenBtn) {
                    fullscreenBtn.addEventListener('click', () => {
                        this.hideButtonTooltip('fullscreen');
                    });
                }

                // 重置視角按鈕提示
                if (this.buttonTooltips.resetView) {
                    this.buttonTooltips.resetView.addEventListener('click', () => {
                        this.hideButtonTooltip('resetView');
                    });
                }
                const resetViewBtn = document.getElementById('reset-view-button');
                if (resetViewBtn) {
                    resetViewBtn.addEventListener('click', () => {
                        this.hideButtonTooltip('resetView');
                    });
                }
            }

            // 💬 顯示按鈕提示
            showButtonTooltips() {
                // 顯示全螢幕按鈕提示
                this.showButtonTooltip('fullscreen');

                // 只在行動裝置上顯示重置視角按鈕提示
                if (this.isMobile) {
                    this.showButtonTooltip('resetView');
                }
            }

            // 💬 顯示單個按鈕提示
            showButtonTooltip(tooltipType) {
                const tooltip = this.buttonTooltips[tooltipType];
                if (!tooltip || this.tooltipVisible[tooltipType]) return;

                // 定位提示對話框
                this.positionTooltip(tooltipType);
                
                // 顯示提示
                tooltip.classList.add('show');
                this.tooltipVisible[tooltipType] = true;
            }

            // 💬 隱藏按鈕提示
            hideButtonTooltip(tooltipType) {
                const tooltip = this.buttonTooltips[tooltipType];
                if (!tooltip || !this.tooltipVisible[tooltipType]) return;

                tooltip.classList.remove('show');
                this.tooltipVisible[tooltipType] = false;
            }

            // 💬 定位提示對話框
            positionTooltip(tooltipType) {
                const tooltip = this.buttonTooltips[tooltipType];
                if (!tooltip) return;

                let button;
                switch (tooltipType) {
                    case 'fullscreen':
                        button = document.getElementById('fullscreen-button');
                        break;
                    case 'resetView':
                        button = document.getElementById('reset-view-button');
                        break;
                    default:
                        return;
                }

                if (!button) return;

                const buttonRect = button.getBoundingClientRect();
                const tooltipContent = tooltip.querySelector('.tooltip-content');

                // 讓對話框自適應文字寬度，但限制最大寬度
                tooltipContent.style.width = 'fit-content';
                
                // 獲取實際的對話框寬度
                const tooltipWidth = tooltipContent.offsetWidth;
                const maxWidth = buttonRect.width * 1.5; // 最多1.5個按鈕寬度
                const finalWidth = Math.min(tooltipWidth, maxWidth);
                
                // 如果文字太長，設定最大寬度並顯示省略號
                if (tooltipWidth > maxWidth) {
                    tooltipContent.style.width = maxWidth + 'px';
                    tooltipContent.style.overflow = 'hidden';
                    tooltipContent.style.textOverflow = 'ellipsis';
                }

                // 計算位置：按鈕下方居中
                const left = buttonRect.left + (buttonRect.width / 2) - (finalWidth / 2);
                const top = buttonRect.bottom + 10; // 按鈕下方10px

                // 確保提示不會超出視窗邊界 - 使用 finalWidth 而不是 tooltipWidth
                const maxLeft = window.innerWidth - finalWidth - 10;
                const adjustedLeft = Math.max(10, Math.min(left, maxLeft));

                tooltip.style.left = adjustedLeft + 'px';
                tooltip.style.top = top + 'px';
            }

            // 💬 更新所有提示位置（用於視窗縮放）
            updateTooltipPositions() {
                Object.keys(this.tooltipVisible).forEach(tooltipType => {
                    if (this.tooltipVisible[tooltipType]) {
                        this.positionTooltip(tooltipType);
                    }
                });
            }

            // 🎮 初始化控制系統
            async initControlSystem() {
                if (this.isMobile) {
                    // 行動裝置：檢查是否需要iOS授權
                    if (this.checkPermissionRequired()) {
                        console.log('📱 檢測到iOS裝置，需要陀螺儀授權');
                        // 延遲顯示，避免擋住載入動畫
                        setTimeout(() => {
                            const gyroPermission = document.getElementById('gyro-permission');
                            gyroPermission.classList.add('show');
                        }, 2000); // 2秒後顯示
                    } else {
                        // Android或其他裝置：直接啟用陀螺儀
                        console.log('📱 直接啟用陀螺儀控制');
                        await this.startGyroControl();
                    }
                } else {
                    // 桌面裝置：使用滑鼠控制
                    console.log('🖥️ 桌面裝置，使用滑鼠控制');
                    this.currentControlMode = 'pointer';
                }
            }

            createLoadingParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;

                // 定義載入動畫的顏色調色板
                const colorPalette = [
                    {
                        bg: '#dc9c3b',
                        rgba: '220, 156, 59'
                    },
                    {
                        bg: '#d1936b', 
                        rgba: '209, 147, 107'
                    },
                    {
                        bg: '#f4e3d4',
                        rgba: '244, 227, 212'
                    }
                ];

                // 創建 10 個粒子
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // 隨機選擇顏色
                    const colorIndex = Math.floor(Math.random() * colorPalette.length);
                    const selectedColor = colorPalette[colorIndex];
                    
                    // 隨機大小 (1-2px)
                    const size = Math.random() * 1.6 + 0.8;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // 設定背景顏色
                    particle.style.background = selectedColor.bg;
                    
                    // 設定基礎發光效果
                    particle.style.boxShadow = `
                        0 0 6px rgba(${selectedColor.rgba}, 0.8),
                        0 0 12px rgba(${selectedColor.rgba}, 0.6),
                        0 0 18px rgba(${selectedColor.rgba}, 0.4),
                        0 0 24px rgba(${selectedColor.rgba}, 0.2)
                    `;
                    
                    // 隨機水平位置 (10%-90%)，避免貼邊
                    particle.style.left = (Math.random() * 80 + 10) + '%';
                    
                    // 隨機飄浮動畫延遲和持續時間
                    const floatDelay = Math.random() * 1.5;
                    const floatDuration = Math.random() * 3 + 2.5;
                    
                    // 隨機發光動畫延遲
                    const glowDelay = Math.random() * 0.5;
                    
                    // 創建唯一的發光動畫名稱
                    const glowAnimationName = `particleGlow${i}`;
                    
                    // 動態創建發光動畫的CSS規則
                    const glowKeyframes = `
                        @keyframes ${glowAnimationName} {
                            0% {
                                box-shadow: 
                                    0 0 6px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 12px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 18px rgba(${selectedColor.rgba}, 0.4),
                                    0 0 24px rgba(${selectedColor.rgba}, 0.2);
                                filter: brightness(1.2);
                            }
                            100% {
                                box-shadow: 
                                    0 0 10px rgba(${selectedColor.rgba}, 1),
                                    0 0 20px rgba(${selectedColor.rgba}, 0.8),
                                    0 0 30px rgba(${selectedColor.rgba}, 0.6),
                                    0 0 40px rgba(${selectedColor.rgba}, 0.3);
                                filter: brightness(1.5);
                            }
                        }
                    `;
                    
                    // 將動畫規則添加到頁面
                    const style = document.createElement('style');
                    style.textContent = glowKeyframes;
                    document.head.appendChild(style);
                    
                    // 設定複合動畫：飄浮 + 個別發光
                    particle.style.animation = `
                        particleFloat ${floatDuration}s linear infinite ${floatDelay}s,
                        ${glowAnimationName} 2s ease-in-out infinite alternate ${glowDelay}s
                    `;
                    
                    particlesContainer.appendChild(particle);
                }
            }

            randomizeSpinnerRings() {
                const spinnerRings = document.querySelectorAll('.spinner-ring');
                
                spinnerRings.forEach((ring, index) => {
                    // 隨機旋轉速度 (1.5s - 4s)
                    const duration = Math.random() * 2 + 1.5;
                    
                    // 隨機起始角度 (0° - 360°)
                    const startAngle = Math.random() * 360;
                    
                    // 隨機方向 (順時針或逆時針)
                    const direction = Math.random() > 0.5 ? 'normal' : 'reverse';
                    
                    // 創建唯一的旋轉動畫名稱
                    const spinAnimationName = `spinnerSpin${index}`;
                    
                    // 動態創建旋轉動畫的CSS規則
                    const spinKeyframes = `
                        @keyframes ${spinAnimationName} {
                            0% { transform: rotate(${startAngle}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                            100% { transform: rotate(${startAngle + 360}deg) ${index === 1 ? 'scale(0.8)' : index === 2 ? 'scale(0.6)' : ''}; }
                        }
                    `;
                    
                    // 將動畫規則添加到頁面
                    const style = document.createElement('style');
                    style.textContent = spinKeyframes;
                    document.head.appendChild(style);
                    
                    // 設定動畫
                    ring.style.animation = `${spinAnimationName} ${duration}s linear infinite`;
                    ring.style.animationDirection = direction;
                });
            }

            // 🔄 重置視角功能
            resetView() {
                // 1. 不要在 resetView() 設 parallaxFreeze = true；改為只凍結輸入：
                this.isResetting = true;  // 保留
                // 不設 this.parallaxFreeze
                
                // 取目前 smoothedDelta 當作 offset 起點
                const startX = this.smoothedDelta.x;
                const startY = this.smoothedDelta.y;
                const duration = 400; // ms
                const startTime = performance.now();
                
                const animate = (now) => {
                    const t = Math.min(1, (now - startTime) / duration);
                    const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // easeInOutQuad
                    const offsetX = THREE.MathUtils.lerp(startX, 0, ease);
                    const offsetY = THREE.MathUtils.lerp(startY, 0, ease);

                    // 🔧 修正：根據當前視角狀態選擇適當的視差處理方式
                    if (this.viewState === 'detail' && !this.isTransitioning) {
                        // 🕹️ 局部圖視角：應用局部視角控制
                        this.updateDetailViewControl(offsetX, offsetY);
                    } else {
                        // 🖼️ 主視角或過渡期間：應用主視差效果
                        this.applyMainParallax(offsetX, offsetY);
                    }

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 1. 在 resetView() 動畫結束區段 **不要**重新賦值 baseX / baseY，
                        // 而是清空並等待下一筆 gyro 事件自動重建基準：
                        this.currentOffsetX = 0;
                        this.currentOffsetY = 0;
                        this.smoothedDelta = { x: 0, y: 0 };
                        this.baseX = null;        // 讓下一筆 gyro 決定新基準
                        this.baseY = null;
                        this.isResetting = false;
                        console.log('🔄 視角重置完成');
                    }
                };
                
                requestAnimationFrame(animate);
            }

            // 🔄 螢幕方向變化平滑過渡功能
            smoothOrientationTransition() {
                // 如果正在重置或過渡中，不執行方向過渡
                if (this.isResetting || this.isTransitioning) return;
                
                // 設定方向過渡標誌
                this.isOrientationTransitioning = true;
                
                // 取目前 smoothedDelta 當作 offset 起點
                const startX = this.smoothedDelta.x;
                const startY = this.smoothedDelta.y;
                const duration = 300; // ms，比重置視角稍短
                const startTime = performance.now();
                
                const animate = (now) => {
                    const t = Math.min(1, (now - startTime) / duration);
                    const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t; // easeInOutQuad
                    const offsetX = THREE.MathUtils.lerp(startX, 0, ease);
                    const offsetY = THREE.MathUtils.lerp(startY, 0, ease);

                    // 🔧 根據當前視角狀態選擇適當的視差處理方式
                    if (this.viewState === 'detail' && !this.isTransitioning) {
                        // 🕹️ 局部圖視角：應用局部視角控制
                        this.updateDetailViewControl(offsetX, offsetY);
                    } else {
                        // 🖼️ 主視角或過渡期間：應用主視差效果
                        this.applyMainParallax(offsetX, offsetY);
                    }

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 動畫完成後，清空基準值並等待下一筆陀螺儀事件重建基準
                        this.currentOffsetX = 0;
                        this.currentOffsetY = 0;
                        this.smoothedDelta = { x: 0, y: 0 };
                        this.baseX = null;        // 讓下一筆 gyro 決定新基準
                        this.baseY = null;
                        this.isOrientationTransitioning = false;
                        console.log('🔄 螢幕方向變化過渡完成');
                    }
                };
                
                requestAnimationFrame(animate);
            }

            // 更新所有圖層的尺寸
            updateAllLayerSizes() {
                // 更新載入場景中的網格
                if (this.loadingScene) {
                    this.loadingScene.children.forEach(mesh => {
                        if (mesh.userData.texture) {
                            const { width, height } = this.calculateImageSize(mesh.userData.texture);
                            mesh.geometry.dispose(); // 釋放舊的幾何體
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        }
                    });
                }

                // 更新主場景中的圖層
                this.layers.forEach(layerGroup => {
                    if (layerGroup.userData.mainTexture) {
                        const { width, height } = this.calculateImageSize(layerGroup.userData.mainTexture);
                        
                        layerGroup.children.forEach(mesh => {
                            mesh.geometry.dispose(); // 釋放舊的幾何體
                            mesh.geometry = new THREE.PlaneGeometry(width, height);
                        });
                    }
                });

                // 🔴 更新互動點點的位置和縮放
                this.updateInteractiveDotsLayout();
                
                // 🔍 更新局部圖層的位置和縮放
                this.updateDetailLayersLayout();
            }

            setupScene() {
                // 建立場景
                this.scene = new THREE.Scene();
                
                // 建立相機
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 5;
                
                // 建立渲染器
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                
                // 📱 高解析螢幕支援：設定像素比例
                const maxRatio = 2; // 兼顧效能的上限
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.renderer.setPixelRatio(pixelRatio);
                
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // 📱 確保canvas元素在DOM中的顯示尺寸正確
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.width = window.innerWidth + 'px';
                    canvas.style.height = window.innerHeight + 'px';
                }
                this.renderer.setClearColor(0x000000, 1);
                
                // 啟用深度測試以確保正確的圖層順序
                this.renderer.sortObjects = true;
                
                // 🎭 創建主要圖層組容器 (7_BG~1_RabbitFornt)
                this.mainLayerGroup = new THREE.Group();
                this.mainLayerGroup.name = 'MainContentLayers';
                this.scene.add(this.mainLayerGroup);
                
                // 🔴 創建互動點點容器
                this.dotsGroup = new THREE.Group();
                this.dotsGroup.name = 'InteractiveDots';
                this.scene.add(this.dotsGroup);
                
                // 🔍 創建局部圖容器
                this.detailGroup1 = new THREE.Group();
                this.detailGroup1.name = 'DetailLayer1';
                this.detailGroup1.renderOrder = 0.08;
                this.scene.add(this.detailGroup1);
                
                this.detailGroup2 = new THREE.Group();
                this.detailGroup2.name = 'DetailLayer2';
                this.detailGroup2.renderOrder = 0.07;
                this.scene.add(this.detailGroup2);
                
                this.detailGroup3 = new THREE.Group();
                this.detailGroup3.name = 'DetailLayer3';
                this.detailGroup3.renderOrder = 0.06;
                this.scene.add(this.detailGroup3);
                
                // 設定圖層組引用
                this.contentLayer = this.mainLayerGroup;
                console.log('✅ 多層級架構初始化完成');
                console.log('📱 UI層: z-index 3000+ (返回按鈕等)');
                console.log('🎬 載入層: z-index 2000+ (封面圖與載入動畫)');
                console.log('🖼️ 內容層: z-index 1000+ (主要圖層組)');
                console.log('🔴 互動點點: renderOrder 1 (最上層)');
                console.log('🔍 局部圖層: z軸 0.06~0.08 (dot1:0.06, dot2:0.07, dot3:0.08), depthWrite:false');
                console.log('🖼️ 主要圖層: renderOrder 0 (最下層)');
            }

            setupEventListeners() {
                // 🎮 混合控制系統事件監聽器
                
                // 1. 螢幕方向變化監聽（所有裝置）
                const handleOrientationChange = () => {
                    const newOrientation = this.getScreenOrientation();
                    if (newOrientation !== this.currentOrientation) {
                        console.log(`🔄 螢幕方向變化: ${this.currentOrientation} → ${newOrientation}`);
                        this.currentOrientation = newOrientation;
                        
                        // 🔧 修正：使用平滑過渡而非直接重設基準值
                        this.smoothOrientationTransition();
                        
                        // 📱 修正：螢幕方向變化時強制重新計算容器大小
                        // 短延遲執行，確保DOM更新完成但避免過長延遲
                        setTimeout(() => {
                            console.log('🔄 方向變化後重新計算容器大小');
                            
                            // 💬 更新提示對話框位置
                            this.updateTooltipPositions();
                            
                            // 📱 重新檢查提示文字顯示（處理橫向觀看提示）
                            this.updateHintDisplay();
                            
                            // 強制觸發resize事件處理邏輯
                            this.camera.aspect = window.innerWidth / window.innerHeight;
                            this.camera.updateProjectionMatrix();
                            
                            // 📱 高解析螢幕支援：重新設定像素比例和大小
                            const maxRatio = 2;
                            const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                            this.renderer.setPixelRatio(pixelRatio);
                            this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                            
                            // 📱 確保canvas元素在DOM中的顯示尺寸正確
                            const canvas = document.getElementById('canvas');
                            if (canvas) {
                                canvas.style.width = window.innerWidth + 'px';
                                canvas.style.height = window.innerHeight + 'px';
                            }
                            
                            // 同時調整載入場景
                            if (this.loadingCamera && this.loadingRenderer) {
                                this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                                this.loadingCamera.updateProjectionMatrix();
                                this.loadingRenderer.setPixelRatio(pixelRatio);
                                this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                                
                                // 📱 確保載入canvas元素在DOM中的顯示尺寸正確
                                const loadingCanvas = document.getElementById('loading-canvas');
                                if (loadingCanvas) {
                                    loadingCanvas.style.width = window.innerWidth + 'px';
                                    loadingCanvas.style.height = window.innerHeight + 'px';
                                }
                            }
                            
                            // 重新計算所有圖層尺寸
                            this.updateAllLayerSizes();
                        }, 50); // 50ms延遲，平衡響應速度和穩定性
                    }
                };

                // 監聽方向變化事件
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', handleOrientationChange);
                } else {
                    window.addEventListener('orientationchange', handleOrientationChange);
                }

                // 2. 滑鼠/觸控事件（所有裝置）
                document.addEventListener('pointermove', (event) => {
                    // 只有真實滑鼠移動才切換到pointer模式
                    if (event.pointerType === 'mouse' || (!event.pointerType && event.type === 'mousemove')) {
                        this.startPointerControl();
                        
                        // 更新滑鼠位置
                        const newX = (event.clientX / window.innerWidth) * 2 - 1;
                        const newY = -(event.clientY / window.innerHeight) * 2 + 1;
                        
                        // 計算滑鼠移動速度（用於慣性效果）
                        this.mouseVelocity.x = newX - this.targetMouse.x;
                        this.mouseVelocity.y = newY - this.targetMouse.y;
                        
                        this.targetMouse.x = newX;
                        this.targetMouse.y = newY;
                        this.mouseInsidePage = true;
                        this.isInertiaActive = false;
                        
                        // 更新pointer偏移
                        this.pointerUpdate(event.clientX, event.clientY);
                    }
                });

                // 3. 滑鼠離開/進入事件（桌面版慣性效果）
                if (!this.isMobile) {
                    document.addEventListener('mouseleave', () => {
                        this.mouseInsidePage = false;
                        this.mouseJustReentered = false;
                        
                        // 啟動慣性緩衝效果
                        const inertiaMultiplier = 1.5;
                        this.inertiaTarget.x = this.currentMouse.x + this.mouseVelocity.x * inertiaMultiplier;
                        this.inertiaTarget.y = this.currentMouse.y + this.mouseVelocity.y * inertiaMultiplier;
                        this.isInertiaActive = true;
                        
                        console.log('滑鼠離開頁面，啟動慣性緩衝效果');
                    });
                    
                    document.addEventListener('mouseenter', () => {
                        if (!this.mouseInsidePage) {
                            this.mouseInsidePage = true;
                            this.mouseJustReentered = true;
                            console.log('滑鼠重新進入頁面，開始平滑過渡到新位置');
                        }
                    });
                }

                // 4. 陀螺儀事件（行動裝置）
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.gyroUpdate.bind(this));
                }

                // 5. 陀螺儀授權按鈕事件
                const enableGyroBtn = document.getElementById('enable-gyro-btn');
                
                if (enableGyroBtn) {
                    enableGyroBtn.addEventListener('click', async () => {
                        const success = await this.startGyroControl();
                        // 無論成功與否都隱藏介面
                        const gyroPermission = document.getElementById('gyro-permission');
                        gyroPermission.classList.remove('show');
                        setTimeout(() => {
                            gyroPermission.style.display = 'none';
                        }, 500); // 等待淡出動畫完成
                        
                        if (!success) {
                            // 如果授權失敗，切換到滑鼠模式
                            this.currentControlMode = 'pointer';
                            console.log('陀螺儀授權失敗，使用滑鼠模式');
                        }
                    });
                }

                // 視窗大小調整
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    
                    // 📱 高解析螢幕支援：重新設定像素比例和大小
                    const maxRatio = 2;
                    const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                    this.renderer.setPixelRatio(pixelRatio);
                    this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                    
                    // 📱 確保canvas元素在DOM中的顯示尺寸正確
                    const canvas = document.getElementById('canvas');
                    if (canvas) {
                        canvas.style.width = window.innerWidth + 'px';
                        canvas.style.height = window.innerHeight + 'px';
                    }
                    
                    // 同時調整載入場景
                    if (this.loadingCamera && this.loadingRenderer) {
                        this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                        this.loadingCamera.updateProjectionMatrix();
                        this.loadingRenderer.setPixelRatio(pixelRatio);
                        this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // 📱 確保載入canvas元素在DOM中的顯示尺寸正確
                        const loadingCanvas = document.getElementById('loading-canvas');
                        if (loadingCanvas) {
                            loadingCanvas.style.width = window.innerWidth + 'px';
                            loadingCanvas.style.height = window.innerHeight + 'px';
                        }
                    }

                    // 自動重新計算並調整所有圖層的 PlaneGeometry
                    this.updateAllLayerSizes();
                    
                    // 📱 更新按鈕顯示狀態（螢幕方向變化時）
                    this.monitorControlMode();
                    
                    // 💬 更新提示對話框位置
                    this.updateTooltipPositions();
                });
            }

            loadLayers() {
                // 只計算主圖，因為深度圖和發光圖可能不存在（封面圖不計入）
                this.totalImages = this.layerInfo.length;
                console.log(`開始載入 ${this.totalImages} 張主要圖片`);
                
                this.layerInfo.forEach((layerData, index) => {
                    this.loadLayer(layerData, index);
                });
            }

            loadLayer(layerData, index) {
                const loader = new THREE.TextureLoader();
                const layerGroup = new THREE.Group();
                
                // 載入主圖
                console.log(`正在載入: ${layerData.name}.png`);
                loader.load(
                    `../images/${layerData.name}.png`,
                    (mainTexture) => {
                        console.log(`成功載入主圖: ${layerData.name}.png`);
                        // 載入深度圖
                        loader.load(
                            `../images/${layerData.name}_depth.png`,
                            (depthTexture) => {
                                // 載入發光圖
                                loader.load(
                                    `../images/${layerData.name}_glow.png`,
                                    (glowTexture) => {
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index);
                                        this.onImageLoaded();
                                    },
                                    undefined,
                                    () => {
                                        // 發光圖載入失敗，只使用主圖和深度圖
                                        this.createLayerMesh(layerGroup, mainTexture, depthTexture, null, layerData, index);
                                        this.onImageLoaded();
                                    }
                                );
                            },
                            undefined,
                            (error) => {
                                console.warn(`深度圖載入失敗: ${layerData.name}_depth.png`);
                                this.createLayerMesh(layerGroup, mainTexture, null, null, layerData, index);
                                this.onImageLoaded();
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`主圖載入失敗: ${layerData.name}.png`, error);
                        this.onImageLoaded(); // 修正：載入失敗也要計數
                    }
                );
            }

            createLayerMesh(layerGroup, mainTexture, depthTexture, glowTexture, layerData, index) {
                // 使用統一的尺寸計算函數，傳入 mainTexture 以獲取原始比例
                const { width, height } = this.calculateImageSize(mainTexture);

                // 如果有深度圖，使用自定義 Shader 來實現基於深度圖的視差
                if (depthTexture) {
                    const vertexShader = `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;
                    
                    const fragmentShader = `
                        uniform sampler2D mainTexture;
                        uniform sampler2D depthTexture;
                        uniform vec2 parallaxOffset;
                        uniform float parallaxStrength;
                        varying vec2 vUv;
                        
                        void main() {
                            // 讀取深度圖的灰階值
                            float depth = texture2D(depthTexture, vUv).r;
                            
                            // 根據深度值計算視差偏移 - 修正計算方式
                            vec2 offset = parallaxOffset * (depth - 0.625) * parallaxStrength;
                            vec2 parallaxUV = vUv + offset;
                            
                            // 檢查是否超出邊界
                            if (parallaxUV.x < 0.0 || parallaxUV.x > 1.0 || parallaxUV.y < 0.0 || parallaxUV.y > 1.0) {
                                // 超出邊界時，使用原始UV取樣
                                parallaxUV = vUv;
                            }
                            
                            // 取樣主紋理
                            vec4 color = texture2D(mainTexture, parallaxUV);
                            gl_FragColor = color;
                        }
                    `;

                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                    // 建立發光圖層（如果存在）- 必須在主圖層之前加入
                    if (glowTexture) {
                        console.log(`載入發光圖層: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                mainTexture: { value: glowTexture },
                                depthTexture: { value: depthTexture },
                                parallaxOffset: { value: new THREE.Vector2(0, 0) },
                                parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                            },
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // 重要：避免深度衝突
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // 稍微往後放，在主圖下層
                        layerGroup.add(glowMesh);
                    }

                    // 建立主圖層
                    const mainMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            mainTexture: { value: mainTexture },
                            depthTexture: { value: depthTexture },
                            parallaxOffset: { value: new THREE.Vector2(0, 0) },
                            parallaxStrength: { value: this.DEPTH_SENSITIVITY }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                } else {
                    // 沒有深度圖，使用基本材質
                    const geometry = new THREE.PlaneGeometry(width, height);
                    
                                                                if (glowTexture) {
                        console.log(`載入發光圖層（無深度圖）: ${layerData.name}_glow.png`);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            map: glowTexture,
                            transparent: true,
                            blending: THREE.CustomBlending,
                            blendEquation: THREE.AddEquation,
                            blendSrc: THREE.OneMinusDstColorFactor,
                            blendDst: THREE.OneFactor,
                            depthWrite: false // 避免深度衝突
                        });
                        const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                        glowMesh.position.z = -0.001; // 在主圖下層
                        layerGroup.add(glowMesh);
                    }

                    const mainMaterial = new THREE.MeshBasicMaterial({
                        map: mainTexture,
                        transparent: true
                    });
                    const mainMesh = new THREE.Mesh(geometry, mainMaterial);
                    layerGroup.add(mainMesh);
                }

                // 根據圖層編號設定Z位置 - 編號越小越在前面
                const layerNumber = parseInt(layerData.name.split('_')[1]); // 取 Main_7_BG 中的 "7"
                layerGroup.position.z = (7 - layerNumber) * 0.01; // 1號最前面(z=0.06)，7號最後面(z=0)
                layerGroup.userData = {
                    depthTexture: depthTexture,
                    hasDepth: !!depthTexture,
                    mainTexture: mainTexture // 存儲主紋理引用以便 resize 時重新計算
                };

                this.layers.push(layerGroup);
                this.mainLayerGroup.add(layerGroup); // 添加到主要圖層組容器
            }

            onImageLoaded() {
                this.loadedImages++;
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // 🌫️ 確保初始狀態沒有模糊效果
                    this.resetTransitionBlur();
                    
                    // 🔴 載入完成後創建互動點點
                    this.createInteractiveDots();
                    
                    // 🔍 載入局部圖層
                    this.loadDetailLayers();
                    
                    // 📱 確保所有圖層尺寸正確（解決手機初始載入大小異常問題）
                    this.updateAllLayerSizes();
                    
                    // 載入完成後，開始淡出封面
                    setTimeout(() => {
                        this.startFadeOut();
                    }, 1000); // 延遲1秒開始淡出
                }
            }

            startFadeOut() {
                const cover = document.getElementById('loading-cover');
                console.log('開始封面淡出動畫');
                
                // 移除淡入 class
                cover.classList.remove('fade-in');
                
                // 使用兩次 requestAnimationFrame 確保流暢淡出
                requestAnimationFrame(() => {       // 讓第一幀呈現 opacity:1
                    requestAnimationFrame(() => {     // 第二幀再加動畫 class
                        cover.classList.add('fade-out');
                    });
                });
                
                // 監聽動畫結束事件
                cover.addEventListener('animationend', () => {
                    cover.style.display = 'none';
                    this.coverFadeOutComplete = true;
                    console.log('封面淡出完成');
                }, { once: true });
                
                // 封面開始淡出後0.5秒，開始載入中動畫淡出和視差過渡
                setTimeout(() => {
                    console.log('開始載入中淡出和視差過渡動畫');
                    this.startLoadingFadeOutAndParallaxTransition();
                }, 100); // 封面開始淡出後0.5秒觸發
                
                // 🔴 封面開始淡出後1秒，互動點點淡入
                setTimeout(() => {
                    console.log('🔴 開始互動點點淡入動畫');
                    this.fadeInInteractiveDots();
                }, 1000); // 封面開始淡出後1秒觸發
            }

            onImageError() {
                this.errorCount++;
                this.loadedImages++;
                
                // 如果錯誤太多，顯示錯誤訊息
                if (this.errorCount >= 3) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error-message').style.display = 'block';
                }
                
                if (this.loadedImages >= this.totalImages) {
                    this.loadingComplete = true;
                    
                    // 🌫️ 確保初始狀態沒有模糊效果
                    this.resetTransitionBlur();
                    
                    // 📱 確保所有圖層尺寸正確（解決手機初始載入大小異常問題）
                    this.updateAllLayerSizes();
                    
                    document.getElementById('loading').style.display = 'none';
                }
            }

            startLoadingFadeOutAndParallaxTransition() {
                // 分別處理載入中動畫淡出和視差過渡
                const loadingFadeDuration = 1000; // 載入中淡出：1秒
                const parallaxTransitionDuration = 1500; // 視差過渡：1.5秒
                
                // 開始載入中動畫的淡出
                const loadingElement = document.getElementById('loading');
                loadingElement.classList.add('fade-out');
                
                // 1秒後完全隱藏載入中元素
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, loadingFadeDuration);
                
                // 同時開始視差過渡動畫（1.5秒）
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / parallaxTransitionDuration, 1);
                    
                    // 自定義緩動函數：70%緩進 + 30%緩出
                    let easedProgress;
                    if (progress <= 0.7) {
                        // 前70%使用緩進 (ease-in)
                        const t = progress / 0.7; // 將0-0.7映射到0-1
                        easedProgress = Math.pow(t, 3) * 0.7; // cubic ease-in，結果映射到0-0.7
                    } else {
                        // 後30%使用緩出 (ease-out)
                        const t = (progress - 0.7) / 0.3; // 將0.7-1映射到0-1
                        easedProgress = 0.7 + (1 - Math.pow(1 - t, 3)) * 0.3; // cubic ease-out，結果映射到0.7-1
                    }
                    
                    this.parallaxTransitionProgress = easedProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.parallaxTransitionProgress = 1; // 確保完全過渡到滑鼠位置
                    }
                };
                
                animate();
            }

            updateMousePosition() {
                if (this.isMobile) return; // 行動裝置不需要滑鼠插值
                
                if (this.mouseInsidePage) {
                    // 滑鼠在頁面內的正常跟隨邏輯
                    const deltaX = this.targetMouse.x - this.currentMouse.x;
                    const deltaY = this.targetMouse.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    let dynamicLerpFactor;
                    
                    if (this.mouseJustReentered) {
                        // 滑鼠剛重新進入頁面：使用慢速過渡（60%緩入，40%緩出）
                        const maxLerpFactor = 0.12;
                        const minLerpFactor = 0.02;
                        dynamicLerpFactor = Math.max(minLerpFactor, maxLerpFactor / (1 + distance * 3.5));
                        
                        // 當距離足夠小時，切換到正常跟隨模式
                        if (distance < 0.1) {
                            this.mouseJustReentered = false;
                            console.log('過渡完成，切換到正常跟隨模式');
                        }
                    } else {
                        // 滑鼠正常在頁面內移動：使用快速跟隨
                        dynamicLerpFactor = 0.25; // 快速響應的固定係數
                    }
                    
                    this.currentMouse.x += deltaX * dynamicLerpFactor;
                    this.currentMouse.y += deltaY * dynamicLerpFactor;
                    
                } else if (this.isInertiaActive) {
                    // 滑鼠離開頁面時的慣性緩衝邏輯
                    const deltaX = this.inertiaTarget.x - this.currentMouse.x;
                    const deltaY = this.inertiaTarget.y - this.currentMouse.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // 慣性緩衝的優雅減速係數（基於距離的動態減速）
                    const baseInertiaFactor = 0.025; // 基礎減速係數（更慢）
                    const distanceBoost = Math.min(distance * 0.8, 0.06); // 距離越遠，減速越慢
                    const inertiaLerpFactor = baseInertiaFactor + distanceBoost;
                    
                    this.currentMouse.x += deltaX * inertiaLerpFactor;
                    this.currentMouse.y += deltaY * inertiaLerpFactor;
                    
                    // 更寬鬆的停止條件，讓動畫更優雅地結束
                    if (distance < 0.005) {
                        this.isInertiaActive = false;
                        console.log('慣性緩衝完成');
                    }
                }
                // 其他情況：滑鼠離開頁面且無慣性時，currentMouse 保持不變
                
                // 更新 mouse 為當前插值後的位置
                this.mouse.x = this.currentMouse.x;
                this.mouse.y = this.currentMouse.y;
                
                // 🔧 修正：同時更新currentOffsetX/Y以供混合控制系統使用
                this.currentOffsetX = this.currentMouse.x;
                this.currentOffsetY = this.currentMouse.y;
            }

            updateParallax() {
                if (!this.loadingComplete) return;
                
                // 重置期間不更新視差，讓動畫迴圈處理
                if (this.isResetting || this.isOrientationTransitioning) return;

                // 更新滑鼠位置插值
                this.updateMousePosition();

                // 🎮 統一輸入源：使用currentOffsetX/Y，確保行動裝置和滑鼠的邏輯一致
                const inputX = this.currentOffsetX * this.parallaxTransitionProgress;
                const inputY = this.currentOffsetY * this.parallaxTransitionProgress;
                
                // 🔧 修正：在過渡期間和不同視角下都要處理滑鼠輸入
                if (this.viewState === 'detail' && !this.isTransitioning) {
                    // 🕹️ 純局部視角：只應用局部視角控制
                    this.updateDetailViewControl(inputX, inputY);
                } else if (this.viewState === 'main' && !this.isTransitioning) {
                    // 🖼️ 純主視角：只應用主視差效果
                    this.applyMainParallax(inputX, inputY);
                } else if (this.isTransitioning) {
                    // 🔄 過渡期間：同時應用兩種效果，但權重不同
                    // 這個邏輯會在動畫函數中處理
                    return;
                }
            }

            // 🌫️ 過渡模糊效果控制方法
            applyTransitionBlur(progress) {
                // 🔧 三段式非對稱模糊曲線：
                // 進度 0.0 → 模糊 0%
                // 進度 0.33 → 模糊 100%
                // 進度 0.66 → 模糊 25%
                // 進度 1.0 → 模糊 0%
                
                let blurFactor;
                
                if (progress <= 0.33) {
                    // 前33%：從0%緩進到100% (使用ease-in曲線)
                    const t = progress / 0.33; // 映射到0-1
                    blurFactor = t * t; // quadratic ease-in
                } else if (progress <= 0.66) {
                    // 33%-66%：從100%快速下降到25% (線性)
                    const t = (progress - 0.33) / 0.33; // 映射到0-1
                    blurFactor = 1.0 - (t * 0.75); // 從1.0下降到0.25
                } else {
                    // 66%-100%：從25%緩出到0% (使用ease-out曲線)
                    const t = (progress - 0.66) / 0.34; // 映射到0-1 (0.34 = 1.0 - 0.66)
                    const easeOutT = 1 - Math.pow(1 - t, 2); // quadratic ease-out
                    blurFactor = 0.25 * (1 - easeOutT); // 從0.25下降到0
                }
                
                const blurIntensity = blurFactor * this.TRANSITION_BLUR_STRENGTH;
                
                // 應用模糊到canvas元素
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = `blur(${blurIntensity}px)`;
                }
                
                // 可選：添加調試資訊
                console.log(`🌫️ 過渡模糊: progress=${progress.toFixed(3)}, factor=${(blurFactor*100).toFixed(1)}%, blur=${blurIntensity.toFixed(2)}px`);
            }
            
            // 🌫️ 重置模糊效果
            resetTransitionBlur() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.filter = 'none';
                }
            }
            
            // 🔍 動態設定局部視角放大倍率
            setDetailZoomScale(scale) {
                if (scale < 1.0) {
                    console.warn('⚠️ 放大倍率不能小於1.0，已設定為1.0');
                    scale = 1.0;
                } else if (scale > 20.0) {
                    console.warn('⚠️ 放大倍率不能大於20.0，已設定為20.0');
                    scale = 20.0;
                }
                
                this.DETAIL_ZOOM_SCALE = scale;
                console.log(`🔍 局部視角放大倍率已設定為: ${scale}x (${(scale*100).toFixed(0)}%)`);
            }
            
            // 🔍 動態獲取目標相機位置
            getTargetCameraPosition() {
                return {
                    x: 0,
                    y: 0,
                    z: this.originalCameraPosition.z / this.DETAIL_ZOOM_SCALE
                };
            }

            // 🔧 新增：獨立的主視差應用方法
            applyMainParallax(inputX, inputY) {
                
                this.layers.forEach((layer) => {
                    const userData = layer.userData;
                    
                    if (userData.hasDepth) {
                        // 對於有深度圖的圖層，更新 Shader 的 parallaxOffset 參數
                        layer.children.forEach((mesh) => {
                            if (mesh.material && mesh.material.uniforms) {
                                mesh.material.uniforms.parallaxOffset.value.set(
                                    inputX * this.PARALLAX_INTENSITY, 
                                    inputY * this.PARALLAX_INTENSITY
                                );
                            }
                        });
                    }
                    // 沒有深度圖的圖層保持靜止，位置不變
                });

                // 🔴 更新互動點點的視差效果
                this.updateInteractiveDotsParallax(inputX, inputY);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 🎮 控制模式監控
                this.monitorControlMode();
                
                // 如果載入封面還在顯示，渲染載入場景
                if (!this.loadingComplete && this.loadingCoverLoaded && this.loadingRenderer) {
                    this.loadingRenderer.render(this.loadingScene, this.loadingCamera);
                }
                
                // 渲染主場景
                if (this.loadingComplete) {
                    this.updateParallax();
                }
                this.renderer.render(this.scene, this.camera);
            }

            // 🔍 ================== 局部圖系統 ==================

            zoomToDetailView(clickedDot) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                this.viewState = 'detail';
                this.currentDetailDot = clickedDot;
                
                // 停止提示動畫（局部視角時不需要提示）
                this.stopHintAnimationCycle();
                
                // 🕹️ 重置局部視角控制
                this.resetDetailViewControl();
                
                // 找到對應的局部圖
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === clickedDot.config.id
                );
                
                if (!detailLayer) {
                    console.error(`🔍 找不到對應的局部圖: ${clickedDot.config.id}`);
                    this.isTransitioning = false;
                    return;
                }
                
                console.log(`🎯 開始放大動畫到 ${clickedDot.config.id}，放大倍率: ${this.DETAIL_ZOOM_SCALE}x (${(this.DETAIL_ZOOM_SCALE*100).toFixed(0)}%)`);
                
                // 計算目標位置 - 將局部圖的中心移動到畫面中心
                const detailMesh = detailLayer.mesh;
                const targetSceneX = -detailMesh.position.x;  // 反向移動場景
                const targetSceneY = -detailMesh.position.y;
                
                // 設定動畫參數
                const duration = 1500; // 1.5秒
                const startTime = Date.now();
                
                // 記錄起始狀態
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // 目標狀態 - 根據設定的放大倍率計算相機位置
                // 放大倍率 = 初始距離 / 目標距離，所以目標距離 = 初始距離 / 放大倍率
                const targetCameraZ = startCameraZ / this.DETAIL_ZOOM_SCALE; // 可配置放大倍率
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 緩動函數：ease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // 🔧 過渡期間的滑鼠控制：同時應用主視差和局部視角控制
                    // 統一使用currentOffsetX/Y，確保行動裝置和滑鼠的邏輯一致
                    const rawInputX = this.currentOffsetX;
                    const rawInputY = this.currentOffsetY;
                    
                    // 主視差權重：從1過渡到0
                    const mainParallaxWeight = 1.0 - easeProgress;
                    // 局部視角權重：從0過渡到1  
                    const detailViewWeight = easeProgress;
                    
                    // 計算混合的場景位置
                    let finalSceneX = startSceneX + (targetSceneX - startSceneX) * easeProgress;
                    let finalSceneY = startSceneY + (targetSceneY - startSceneY) * easeProgress;
                    
                    // 應用主視差效果（權重遞減）
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // 應用局部視角控制（權重遞增）
                    if (detailViewWeight > 0) {
                        const detailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        const detailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY * detailViewWeight;
                        
                        // 應用邊界限制
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedOffsetX = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetX));
                        const limitedOffsetY = Math.max(-maxOffset, Math.min(maxOffset, detailOffsetY));
                        
                        // 疊加局部視角偏移
                        finalSceneX += limitedOffsetX;
                        finalSceneY += limitedOffsetY;
                    }
                    
                    // 更新相機位置 (放大效果)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // 更新場景位置 (移動到局部圖中心 + 滑鼠偏移)
                    this.scene.position.x = finalSceneX;
                    this.scene.position.y = finalSceneY;
                    
                    // 🌟 局部圖淡入 - 在放大過程中逐漸顯示，同時調整羽化強度
                    if (detailMesh.material.uniforms) {
                        // 透明度過渡：使用稍快的速度但不要太快
                        const targetOpacity = Math.min(1.0, easeProgress * 1.1);
                        detailMesh.material.uniforms.opacity.value = targetOpacity;
                        
                        // 🔧 修正羽化過渡：使用線性進度而非緩動進度，確保平滑過渡
                        const linearProgress = progress; // 使用線性進度而非easeProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_MAIN_VIEW - (linearProgress * featherRange);
                        detailMesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // 可選：添加調試資訊
                        // console.log(`🌟 羽化過渡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // 🔴 點點淡出效果 - 放大時
                    this.updateDotsTransitionOpacity('zoomIn', progress);
                    
                    // 🌫️ 應用過渡模糊效果
                    this.applyTransitionBlur(progress);
                    
                    // 💡 提示文字過渡動畫
                    this.transitionToDetailHint(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 動畫完成
                        this.camera.position.z = targetCameraZ;
                        // 🔧 最終位置需要包含當前的局部視角偏移
                        const finalDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const finalDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        const finalLimitedOffsetX = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetX));
                        const finalLimitedOffsetY = Math.max(-this.DETAIL_VIEW_BOUNDARY, Math.min(this.DETAIL_VIEW_BOUNDARY, finalDetailOffsetY));
                        
                        this.scene.position.x = targetSceneX + finalLimitedOffsetX;
                        this.scene.position.y = targetSceneY + finalLimitedOffsetY;
                        
                        // 🌟 設定最終狀態：完全不透明，羽化最弱
                        if (detailMesh.material.uniforms) {
                            detailMesh.material.uniforms.opacity.value = 1.0;
                            detailMesh.material.uniforms.featherStrength.value = this.FEATHER_DETAIL_VIEW;  // 局部視角羽化最弱
                        }
                        
                        // 🌫️ 重置模糊效果
                        this.resetTransitionBlur();
                        
                        // 🔴 重置點點透明度為0%（局部視角時完全隱藏）
                        this.resetDotsTransitionOpacity(0.0);
                        
                        this.isTransitioning = false;
                        
                        console.log(`🎯 放大動畫完成，進入局部視角: ${clickedDot.config.id}`);
                    }
                };
                
                animate();
            }

            returnToMainView() {
                if (this.isTransitioning || this.viewState === 'main') return;
                
                this.isTransitioning = true;
                
                // 🕹️ 重置局部視角控制
                this.resetDetailViewControl();
                
                console.log('🔄 開始返回主視角動畫');
                
                // 找到當前的局部圖
                const detailLayer = this.detailLayers.find(layer => 
                    layer.detailInfo.dotId === this.currentDetailDot.config.id
                );
                
                // 設定動畫參數
                const duration = 1500; // 1.5秒
                const startTime = Date.now();
                
                // 記錄起始狀態
                const startCameraZ = this.camera.position.z;
                const startSceneX = this.scene.position.x;
                const startSceneY = this.scene.position.y;
                
                // 🔧 分離起始位置的基礎位置和滑鼠偏移
                const detailMesh = detailLayer.mesh;
                const baseSceneX = -detailMesh.position.x;  // 局部圖中心對應的基礎場景位置
                const baseSceneY = -detailMesh.position.y;
                const startOffsetX = startSceneX - baseSceneX;  // 起始時的滑鼠偏移
                const startOffsetY = startSceneY - baseSceneY;
                
                // 目標狀態 (回到原始位置) - 使用初始相機位置
                const targetCameraZ = 5; // 固定回到初始位置
                const targetSceneX = 0;
                const targetSceneY = 0;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 緩動函數：ease-in-out
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // 🔧 過渡期間的滑鼠控制：同時應用局部視角和主視差控制
                    // 統一使用currentOffsetX/Y，確保行動裝置和滑鼠的邏輯一致
                    const rawInputX = this.currentOffsetX;
                    const rawInputY = this.currentOffsetY;
                    
                    // 局部視角權重：從1過渡到0
                    const detailViewWeight = 1.0 - easeProgress;
                    // 主視差權重：從0過渡到1
                    const mainParallaxWeight = easeProgress;
                    
                    // 🔧 修正：計算基礎場景位置的過渡
                    const baseTransitionX = baseSceneX + (targetSceneX - baseSceneX) * easeProgress;
                    const baseTransitionY = baseSceneY + (targetSceneY - baseSceneY) * easeProgress;
                    
                    // 計算混合的滑鼠偏移
                    let finalOffsetX = 0;
                    let finalOffsetY = 0;
                    
                    // 應用局部視角控制（權重遞減）
                    if (detailViewWeight > 0) {
                        const currentDetailOffsetX = -rawInputX * this.DETAIL_VIEW_INTENSITY;
                        const currentDetailOffsetY = -rawInputY * this.DETAIL_VIEW_INTENSITY;
                        
                        // 應用邊界限制
                        const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                        const limitedCurrentOffsetX = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetX));
                        const limitedCurrentOffsetY = Math.max(-maxOffset, Math.min(maxOffset, currentDetailOffsetY));
                        
                        // 🔧 修正：從起始偏移平滑過渡到0（回到主視角中心）
                        // 起始偏移隨著權重減少而減少，最終變為0
                        const transitionOffsetX = startOffsetX * detailViewWeight;
                        const transitionOffsetY = startOffsetY * detailViewWeight;
                        
                        // 當前滑鼠偏移也隨著權重減少而減少
                        const currentOffsetX = limitedCurrentOffsetX * detailViewWeight;
                        const currentOffsetY = limitedCurrentOffsetY * detailViewWeight;
                        
                        // 混合兩種偏移，但都會隨著權重減少
                        finalOffsetX = transitionOffsetX * 0.3 + currentOffsetX * 0.7;
                        finalOffsetY = transitionOffsetY * 0.3 + currentOffsetY * 0.7;
                    } else {
                        // 🔧 權重為0時，偏移也應該為0（完全回到主視角）
                        finalOffsetX = 0;
                        finalOffsetY = 0;
                    }
                    
                    // 🔧 修正：場景基礎位置平滑過渡到(0,0)
                    const sceneBaseX = baseTransitionX + finalOffsetX;
                    const sceneBaseY = baseTransitionY + finalOffsetY;
                    
                    // 更新相機位置 (縮小效果)
                    this.camera.position.z = startCameraZ + (targetCameraZ - startCameraZ) * easeProgress;
                    
                    // 🔧 設定場景基礎位置
                    this.scene.position.x = sceneBaseX;
                    this.scene.position.y = sceneBaseY;
                    
                    // 🔧 在場景基礎位置之上應用主視差效果（權重遞增）
                    if (mainParallaxWeight > 0) {
                        const mainInputX = rawInputX * this.parallaxTransitionProgress * mainParallaxWeight;
                        const mainInputY = rawInputY * this.parallaxTransitionProgress * mainParallaxWeight;
                        this.applyMainParallax(mainInputX, mainInputY);
                    }
                    
                    // 🌟 局部圖淡出 - 同時調整羽化強度
                    if (detailLayer && detailLayer.mesh.material.uniforms) {
                        detailLayer.mesh.material.uniforms.opacity.value = 1.0 - easeProgress;
                        
                        // 🔧 修正羽化過渡：使用線性進度確保平滑過渡
                        const linearProgress = progress; // 使用線性進度而非easeProgress
                        const featherRange = this.FEATHER_MAIN_VIEW - this.FEATHER_DETAIL_VIEW;
                        const currentFeatherStrength = this.FEATHER_DETAIL_VIEW + (linearProgress * featherRange);
                        detailLayer.mesh.material.uniforms.featherStrength.value = currentFeatherStrength;
                        
                        // 可選：添加調試資訊
                        // console.log(`🌟 羽化過渡: progress=${linearProgress.toFixed(3)}, feather=${currentFeatherStrength.toFixed(3)}`);
                    }
                    
                    // 🔴 點點淡入效果 - 縮小時
                    this.updateDotsTransitionOpacity('zoomOut', progress);
                    
                    // 🌫️ 應用過渡模糊效果
                    this.applyTransitionBlur(progress);
                    
                    // 💡 提示文字過渡動畫
                    this.transitionToMainHint(progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // 動畫完成
                        this.camera.position.z = targetCameraZ;
                        
                        // 🔧 場景位置已經在動畫過程中平滑過渡到目標位置(0,0)
                        // 不需要再次設定，避免突跳
                        // this.scene.position.x = targetSceneX;
                        // this.scene.position.y = targetSceneY;
                        
                        // 🔧 確保最終狀態：場景位置為(0,0)，主視差效果疊加
                        this.scene.position.x = 0;
                        this.scene.position.y = 0;
                        const finalMainInputX = rawInputX * this.parallaxTransitionProgress;
                        const finalMainInputY = rawInputY * this.parallaxTransitionProgress;
                        this.applyMainParallax(finalMainInputX, finalMainInputY);
                        
                        // 🌟 重置局部圖狀態：透明度為0，羽化強度最強
                        if (detailLayer && detailLayer.mesh.material.uniforms) {
                            detailLayer.mesh.material.uniforms.opacity.value = 0.0;
                            detailLayer.mesh.material.uniforms.featherStrength.value = this.FEATHER_MAIN_VIEW;  // 主視角羽化最強
                        }
                        
                        // 🌫️ 重置模糊效果
                        this.resetTransitionBlur();
                        
                        // 🔴 重置點點透明度為100%（主視角時完全顯示）
                        this.resetDotsTransitionOpacity(1.0);
                        
                        // 重置狀態
                        this.viewState = 'main';
                        this.currentDetailDot = null;
                        this.isTransitioning = false;
                        
                        // 重新啟動提示動畫（如果還有未點擊的點點）
                        const unclickedDots = this.interactiveDots.filter(dotData => !dotData.hasBeenClicked);
                        if (unclickedDots.length > 0) {
                            setTimeout(() => {
                                this.startHintAnimationCycle();
                            }, 500);
                        }
                        
                        console.log('🔄 返回主視角動畫完成');
                    }
                };
                
                animate();
            }

            loadDetailLayers() {
                console.log('🔍 開始載入局部圖層');
                
                this.detailLayerInfo.forEach((detailInfo, index) => {
                    this.loadDetailLayer(detailInfo, index);
                });
            }

            loadDetailLayer(detailInfo, index) {
                const loader = new THREE.TextureLoader();
                
                console.log(`🔍 正在載入局部圖: ${detailInfo.name}.png`);
                loader.load(
                    `../images/${detailInfo.name}.png`,
                    (texture) => {
                        console.log(`🔍 成功載入局部圖: ${detailInfo.name}.png`);
                        this.createDetailLayerMesh(texture, detailInfo, index);
                    },
                    undefined,
                    (error) => {
                        console.error(`🔍 局部圖載入失敗: ${detailInfo.name}.png`, error);
                    }
                );
            }

            createDetailLayerMesh(texture, detailInfo, index) {
                // 🔧 修正：使用主圖層的尺寸作為基準，而不是局部圖自己的尺寸
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) {
                    console.error('🔍 無法獲取主圖層尺寸，局部圖建立失敗');
                    return;
                }
                
                const { width: mainWidth, height: mainHeight } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 🔧 建立與主圖層相同大小的幾何體，稍後用縮放控制實際大小
                const geometry = new THREE.PlaneGeometry(mainWidth, mainHeight);
                
                // 🌟 建立具有邊緣羽化效果的自定義Shader材質
                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                const fragmentShader = `
                    uniform sampler2D mainTexture;
                    uniform float opacity;
                    uniform float featherStrength;  // 羽化強度 (0.0-1.0)
                    uniform float featherRange;     // 羽化影響範圍 (0.0-1.0)
                    varying vec2 vUv;
                    
                    void main() {
                        // 取樣主紋理
                        vec4 color = texture2D(mainTexture, vUv);
                        
                        // 計算到邊緣的距離
                        vec2 center = vec2(0.5, 0.5);
                        vec2 edgeDistance = abs(vUv - center) * 2.0;  // 轉換為0-1範圍
                        float maxEdgeDistance = max(edgeDistance.x, edgeDistance.y);
                        
                        // 羽化計算：從邊緣開始淡化
                        float actualFeatherRange = featherStrength * featherRange;  // 實際羽化範圍
                        float featherStart = 1.0 - actualFeatherRange;              // 羽化開始位置
                        float featherEnd = 1.0;                                     // 羽化結束位置（邊緣）
                        
                        float edgeAlpha = 1.0;
                        if (maxEdgeDistance > featherStart && actualFeatherRange > 0.0) {
                            // 在羽化區域內，計算透明度漸變
                            float featherProgress = (maxEdgeDistance - featherStart) / (featherEnd - featherStart);
                            // 使用更平滑的曲線
                            edgeAlpha = 1.0 - smoothstep(0.0, 1.0, featherProgress * featherProgress);
                        }
                        
                        // 最終透明度 = 材質透明度 × 邊緣透明度
                        color.a *= opacity * edgeAlpha;
                        
                        gl_FragColor = color;
                    }
                `;
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        mainTexture: { value: texture },
                        opacity: { value: 0.0 },  // 初始透明度為0
                        featherStrength: { value: this.FEATHER_MAIN_VIEW },  // 初始羽化強度：主視角時最強
                        featherRange: { value: this.FEATHER_TRANSITION_RANGE }  // 羽化影響範圍
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                    depthWrite: false  // 🔧 關鍵修正：避免透明物件寫入深度緩衝區造成遮擋
                });
                
                // 建立網格
                const mesh = new THREE.Mesh(geometry, material);
                
                // 🔧 修正：使用點點配置直接計算位置，確保坐標系統完全一致
                const correspondingDot = this.interactiveDots.find(dot => 
                    dot.config.id === detailInfo.dotId
                );
                
                if (correspondingDot) {
                    // 🔧 修正：與點點相同的坐標計算邏輯
                    const x = (correspondingDot.config.x - 0.5) * mainWidth;
                    const y = (0.5 - correspondingDot.config.y) * mainHeight; // Y軸翻轉
                    
                    mesh.position.x = x;
                    mesh.position.y = y;
                    // 🔧 Z軸位置：現在有了depthWrite: false，順序不再重要
                    mesh.position.z = 0.06 + index * 0.01; // Z軸位置 0.06~0.08 (index 0,1,2 對應 0.06,0.07,0.08)
                    
                    console.log(`🔍 局部圖 ${detailInfo.name} 位置設定為與點點 ${detailInfo.dotId} 相同的計算結果:`, 
                               `(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
                } else {
                    console.warn(`🔍 找不到對應的點點: ${detailInfo.dotId}`);
                    mesh.position.z = 0.06 + index * 0.01;
                }
                
                // 設定初始縮放25%
                mesh.scale.setScalar(0.25);
                
                // 儲存相關資訊
                mesh.userData = {
                    isDetailLayer: true,
                    detailInfo: detailInfo,
                    originalTexture: texture,  // 局部圖本身的紋理
                    mainTexture: firstLayer.userData.mainTexture,  // 🔧 新增：主圖層紋理引用，用於尺寸計算
                    baseScale: 0.25,
                    dotId: detailInfo.dotId
                };
                
                // 添加到對應的圖層組
                const targetGroup = this[detailInfo.group];
                if (targetGroup) {
                    targetGroup.add(mesh);
                    console.log(`🔍 局部圖 ${detailInfo.name} 已添加到 ${detailInfo.group}`);
                } else {
                    console.error(`🔍 找不到目標圖層組: ${detailInfo.group}`);
                }
                
                // 添加到局部圖層陣列
                this.detailLayers.push({
                    mesh: mesh,
                    group: targetGroup,
                    detailInfo: detailInfo,
                    isVisible: true,
                    basePosition: {
                        x: mesh.position.x,
                        y: mesh.position.y,
                        z: mesh.position.z
                    }
                });
            }

            updateDetailLayersLayout() {
                // 當視窗大小改變時，更新局部圖層位置和尺寸
                if (!this.detailLayers.length || !this.interactiveDots.length) return;
                
                // 獲取主圖的尺寸用於計算
                const firstLayer = this.layers[0];
                if (!firstLayer || !firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                this.detailLayers.forEach(detailLayer => {
                    const correspondingDot = this.interactiveDots.find(dot => 
                        dot.config.id === detailLayer.detailInfo.dotId
                    );
                    
                    if (correspondingDot) {
                        // 🔧 修正：使用與點點相同的坐標計算邏輯，確保完全一致
                        const x = (correspondingDot.config.x - 0.5) * width;
                        const y = (0.5 - correspondingDot.config.y) * height; // Y軸翻轉
                        
                        detailLayer.mesh.position.x = x;
                        detailLayer.mesh.position.y = y;
                        
                        // 🔧 修正：更新幾何體尺寸以匹配主圖層
                        detailLayer.mesh.geometry.dispose(); // 釋放舊的幾何體
                        detailLayer.mesh.geometry = new THREE.PlaneGeometry(width, height);
                        
                        // 更新基礎位置記錄
                        detailLayer.basePosition.x = x;
                        detailLayer.basePosition.y = y;
                        
                        console.log(`🔍 更新局部圖 ${detailLayer.detailInfo.name} 位置到 (${x.toFixed(2)}, ${y.toFixed(2)})，尺寸: ${width.toFixed(1)}x${height.toFixed(1)}`);
                    }
                });
            }

            // 🔴 ================== 互動點點系統 ==================

            createInteractiveDots() {
                console.log('🔴 開始創建互動點點');
                
                // 點點配置資料 - 位置以百分比表示 (0-1)
                const dotsConfig = [
                    { id: 'dot1', x: 0.6385, y: 0.394, depth: 0.56 },
                    { id: 'dot2', x: 0.486, y: 0.647, depth: 0.57 },
                    { id: 'dot3', x: 0.71, y: 0.628, depth: 0.65 }
                ];

                // 初始化提示動畫相關變數
                this.dotHints = []; // 提示圓形陣列
                this.hintAnimationState = {
                    isActive: false,
                    currentCycle: 0,
                    lastCycleTime: 0,
                    cycleInterval: 3000, // 循環間隔 3 秒
                    hasClickedAny: false // 是否有任何點點被點擊過
                };

                // 為每個點創建網格和提示
                dotsConfig.forEach((config, index) => {
                    const dot = this.createDotMesh(config);
                    const hint = this.createDotHint(config);
                    
                    this.interactiveDots.push({
                        mesh: dot,
                        hint: hint, // 添加提示引用
                        config: config,
                        originalPosition: { x: config.x, y: config.y },
                        basePosition: { x: 0, y: 0 }, // 基礎位置（不含視差）
                        isHovered: false,
                        hoverMultiplier: 1.0,         // hover透明度乘數
                        isPressed: false,             // 是否被按下
                        pressedScale: 1.0,            // 按下狀態的縮放
                        // 距離互動相關
                        mouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // 滑鼠距離係數 (0=最近, 1=最遠/超出範圍)
                        targetMouseDistance: this.DISTANCE_INTERACTION_ENABLED ? 1.0 : 0.0,  // 目標距離係數
                        distanceScale: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_SCALE_FACTOR : 1.0,      // 基於距離的縮放係數
                        distanceOpacity: this.DISTANCE_INTERACTION_ENABLED ? this.MIN_OPACITY_FACTOR : 1.0,   // 基於距離的透明度係數
                        // 🌫️ 過渡動畫相關
                        transitionOpacity: 1.0,  // 過渡動畫透明度乘數 (放大縮小時的淡出淡入)
                        // 提示相關
                        hasBeenClicked: false,    // 是否已被點擊過
                        hintAnimation: {
                            isActive: false,
                            startTime: 0,
                            scale: 1.0,
                            opacity: 0.0
                        }
                    });
                    
                    this.dotsGroup.add(dot);
                    this.dotsGroup.add(hint); // 將提示添加到場景中
                    this.dotHints.push(hint);
                });

                // 設定點點容器的渲染順序
                this.dotsGroup.renderOrder = 1; // 比主圖層組(0)高，比載入層低
                
                // 確保提示圓形在點點下層但可見
                this.dotHints.forEach(hint => {
                    hint.renderOrder = 0; // 在點點下層
                    hint.material.depthWrite = false; // 避免深度寫入問題
                });
                
                // 初始化點點布局
                this.updateInteractiveDotsLayout();
                
                // 設定點擊事件
                this.setupDotInteractions();
                

                
                console.log(`✅ 成功創建 ${this.interactiveDots.length} 個互動點點和提示`);
            }

            createDotMesh(config) {
                // 創建具有陰影效果的互動點點材質
                const canvas = document.createElement('canvas');
                const size = 128; // 增加畫布大小以容納更大的陰影
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                const outerRadius = size * 0.2; // 調整點點大小比例
                const innerRadius = size * 0.1;  
                const shadowRadius = size * 0.32;  // 陰影範圍
                
                // 清除畫布
                ctx.clearRect(0, 0, size, size);
                
                // 繪製大範圍擴散陰影 - 從中心向外模糊
                const shadowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, shadowRadius);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');     // 中心較深
                shadowGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.25)');  // 漸變
                shadowGradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');   // 更淡
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');       // 邊緣透明
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, shadowRadius, 0, Math.PI * 2);
                ctx.fillStyle = shadowGradient;
                ctx.fill();
                
                // 設定點點本身的陰影效果
                ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 2;
                
                // 繪製外圈 - 半透明邊框
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 重置陰影
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // 繪製內圈 - 實心中心
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                
                // 內圈漸變填充
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                innerGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)');
                
                ctx.fillStyle = innerGradient;
                ctx.fill();
                
                // 添加精細的白色光暈效果
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius + 3, 0, Math.PI * 2);
                const glowGradient = ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, outerRadius + 3);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // 創建紋理
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // 創建材質
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,  // 初始為透明，等待淡入
                    blending: THREE.NormalBlending
                });
                
                // 計算點點大小 - 使用與主圖相同的縮放邏輯
                let dotSize;
                if (this.layers.length > 0 && this.layers[0].userData.mainTexture) {
                    // 獲取主圖的尺寸
                    const { width, height } = this.calculateImageSize(this.layers[0].userData.mainTexture);
                    // 點點大小設為主圖較小邊的 1/35，保持與主圖的視覺比例
                    dotSize = Math.min(width, height) * 0.05;
                } else {
                    // 如果主圖還沒載入，使用預設大小
                    dotSize = 0.32;
                }
                
                // 創建幾何體 - 使用計算出的大小
                const geometry = new THREE.PlaneGeometry(dotSize, dotSize);
                
                // 創建網格
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    isDot: true,
                    dotId: config.id,
                    depthValue: config.depth,
                    baseOpacity: 0.85, // 稍高的基礎透明度確保可見性
                    isVisible: false,
                    baseSize: dotSize // 存儲基礎大小以便後續調整
                };
                
                return mesh;
            }

            // 創建點點提示圓形
            createDotHint(config) {
                // 創建白色半透明漸層圓形提示
                const canvas = document.createElement('canvas');
                const size = 256; // 較大的畫布以容納漸層效果
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                const radius = size * 0.4; // 提示圓形大小
                
                // 清除畫布
                ctx.clearRect(0, 0, size, size);
                
                // 創建從中心向外漸變的白色半透明圓形
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');   // 中心 0.6 透明度
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)'); // 漸變
                gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)'); // 更淡
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');   // 邊緣 0.2 透明度
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // 創建紋理
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // 創建材質
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0,  // 初始為透明
                    blending: THREE.NormalBlending,
                    depthWrite: false,  // 避免深度寫入問題
                    depthTest: true     // 啟用深度測試
                });
                
                // 計算提示大小 - 比點點大一些
                let hintSize;
                if (this.layers.length > 0 && this.layers[0].userData.mainTexture) {
                    const { width, height } = this.calculateImageSize(this.layers[0].userData.mainTexture);
                    hintSize = Math.min(width, height) * 0.08; // 比點點大 1.6 倍
                } else {
                    hintSize = 0.5;
                }
                
                // 創建幾何體
                const geometry = new THREE.PlaneGeometry(hintSize, hintSize);
                
                // 創建網格
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    isDotHint: true,
                    dotId: config.id,
                    baseSize: hintSize,
                    isAnimating: false
                };
                
                // 確保初始狀態完全透明且縮放為0
                mesh.material.opacity = 0;
                mesh.scale.set(0, 0, 1);
                
                return mesh;
            }

            updateInteractiveDotsLayout() {
                if (!this.layers.length || !this.interactiveDots.length) return;
                
                // 獲取主圖的尺寸（使用第一個圖層的主紋理）
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 更新每個點的基礎位置和大小
                this.interactiveDots.forEach(dotData => {
                    const { config } = dotData;
                    
                    // 計算在主圖範圍內的位置
                    // relativeX/Y 從 0~1 轉換為 -width/2 ~ +width/2 的座標
                    const x = (config.x - 0.5) * width;
                    const y = (0.5 - config.y) * height; // Y軸翻轉
                    
                    dotData.basePosition.x = x;
                    dotData.basePosition.y = y;
                    dotData.mesh.position.x = x;
                    dotData.mesh.position.y = y;
                    dotData.mesh.position.z = 0.1; // 確保在主圖層之上
                    
                    // 更新提示位置（與點點相同位置，但在點點下層）
                    if (dotData.hint) {
                        dotData.hint.position.x = x;
                        dotData.hint.position.y = y;
                        dotData.hint.position.z = 0.09; // 在主圖層之上，點點下層
                        
                        // 確保提示圓形保持初始狀態（透明且縮放為0）
                        dotData.hint.material.opacity = 0;
                        dotData.hint.scale.set(0, 0, 1);
                    }
                    
                    // 重新計算點點大小
                    const dotSize = Math.min(width, height) * 0.028;
                    dotData.mesh.userData.baseSize = dotSize;
                    
                    // 更新幾何體大小
                    dotData.mesh.geometry.dispose();
                    dotData.mesh.geometry = new THREE.PlaneGeometry(dotSize, dotSize);
                    
                    // 更新提示大小
                    if (dotData.hint) {
                        const hintSize = Math.min(width, height) * 0.045; // 比點點大 1.6 倍
                        dotData.hint.userData.baseSize = hintSize;
                        dotData.hint.geometry.dispose();
                        dotData.hint.geometry = new THREE.PlaneGeometry(hintSize, hintSize);
                    }
                });
                
                console.log('🔴 互動點點和提示布局已更新');
            }

            updateInteractiveDotsParallax(inputX, inputY) {
                if (!this.interactiveDots.length) return;
                
                this.interactiveDots.forEach(dotData => {
                    const { mesh, hint, basePosition, config } = dotData;
                    
                    // 根據點的深度值計算視差偏移
                    const depthOffset = (config.depth - 0.625); // 與 shader 中相同的基準點
                    const parallaxX = inputX * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    const parallaxY = inputY * this.PARALLAX_INTENSITY * depthOffset * this.DEPTH_SENSITIVITY;
                    
                    // 應用視差偏移到基礎位置
                    mesh.position.x = basePosition.x + parallaxX;
                    mesh.position.y = basePosition.y + parallaxY;
                    
                    // 同時更新提示的視差效果
                    if (hint) {
                        hint.position.x = basePosition.x + parallaxX;
                        hint.position.y = basePosition.y + parallaxY;
                    }
                });
            }

            setupDotInteractions() {
                // 建立raycaster用於點擊檢測
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // 滑鼠按下事件
                this.renderer.domElement.addEventListener('pointerdown', (event) => {
                    this.handleDotPointerDown(event);
                });
                
                // 滑鼠放開事件
                this.renderer.domElement.addEventListener('pointerup', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // 滑鼠離開時也要放開（避免拖拽離開後卡住）
                this.renderer.domElement.addEventListener('pointerleave', (event) => {
                    this.handleDotPointerUp(event);
                });
                
                // 桌機版：滑鼠hover效果和距離互動
                if (!this.isMobile) {
                    this.renderer.domElement.addEventListener('pointermove', (event) => {
                        this.handleDotHover(event);
                        // 同時更新距離互動
                        if (this.DISTANCE_INTERACTION_ENABLED) {
                            this.updateDistanceInteraction(event);
                        }
                    });
                    
                    // 設定滑鼠樣式
                    this.renderer.domElement.style.cursor = 'default';
                } else {
                    // 行動版：距離互動已在建構函數中關閉，無需額外事件監聽器
                    console.log('行動版：距離感應互動已關閉');
                }
                // 注意：行動版的動畫現在統一在 fadeInInteractiveDots 完成後啟動
            }

            handleDotPointerDown(event) {
                // 如果正在過渡動畫中，忽略點擊
                if (this.isTransitioning) return;
                
                // 轉換滑鼠座標
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // 設定raycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                if (this.viewState === 'main') {
                    // 主視角：檢查點點點擊
                    const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                    let intersects = this.raycaster.intersectObjects(dotMeshes);
                    
                    // 如果是行動裝置且沒有精確命中，使用擴展的碰撞檢測
                    if (this.isMobile && intersects.length === 0) {
                        intersects = this.checkExtendedDotCollision(event.clientX, event.clientY);
                    }
                    
                    if (intersects.length > 0) {
                        const pressedDot = intersects[0].object;
                        const dotData = this.interactiveDots.find(d => d.mesh === pressedDot);
                        
                        // 🔧 修正：檢查點點是否真的可見和可點擊
                        if (dotData && dotData.transitionOpacity > 0.1) {
                            const dotId = pressedDot.userData.dotId;
                            console.log(`🔴 ${dotId} pressed down`);
                            
                            // 設定按下狀態
                            dotData.isPressed = true;
                            this.animateDotPress(dotData, true);
                        }
                    }
                } else if (this.viewState === 'detail') {
                    // 局部視角：點擊任意位置返回主視角
                    console.log('🔄 點擊畫面返回主視角');
                    this.returnToMainView();
                }
            }

            handleDotPointerUp(event) {
                // 如果正在過渡動畫中，忽略點擊
                if (this.isTransitioning) return;
                
                if (this.viewState === 'main') {
                    // 主視角：檢查是否有點點被按下並觸發放大
                    let clickedDot = null;
                    this.interactiveDots.forEach(dotData => {
                        if (dotData.isPressed) {
                            // 🔧 修正：檢查點點是否真的可見和可點擊
                            if (dotData.transitionOpacity > 0.1) {
                                console.log(`🔴 ${dotData.mesh.userData.dotId} released`);
                                clickedDot = dotData;
                            }
                            dotData.isPressed = false;
                            this.animateDotPress(dotData, false);
                        }
                    });
                    
                    // 如果有點點被點擊，放大到局部視角
                    if (clickedDot) {
                        console.log(`🎯 放大到局部視角: ${clickedDot.config.id}`);
                        
                        // 標記點點為已點擊
                        this.markDotAsClicked(clickedDot.config.id);
                        
                        this.zoomToDetailView(clickedDot);
                    }
                }
            }

            // 檢查擴展的點點碰撞（行動裝置專用）
            checkExtendedDotCollision(clientX, clientY) {
                if (!this.layers.length) return [];
                
                // 獲取主圖的尺寸
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return [];
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 計算螢幕中心點
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // 計算點點在螢幕上的實際位置
                const dotScreenPositions = this.interactiveDots.map(dotData => {
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    return {
                        dotData: dotData,
                        screenX: dotScreenX,
                        screenY: dotScreenY
                    };
                });
                
                // 計算擴展的碰撞範圍（點點大小的2倍）
                const baseDotSize = Math.min(width, height) * 0.05; // 使用與createDotMesh相同的計算
                const extendedRadius = baseDotSize * (window.innerWidth / (width * this.IMAGE_SCALE)) * 2; // 2倍大小
                
                // 檢查觸控點是否在任何點點的擴展範圍內
                for (let i = 0; i < dotScreenPositions.length; i++) {
                    const pos = dotScreenPositions[i];
                    const deltaX = clientX - pos.screenX;
                    const deltaY = clientY - pos.screenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance <= extendedRadius) {
                        // 返回模擬的intersect結果
                        return [{
                            object: pos.dotData.mesh,
                            distance: distance
                        }];
                    }
                }
                
                return [];
            }

            handleDotHover(event) {
                if (this.isMobile) return;
                
                // 🔧 修正：在局部視角時不處理點點hover
                if (this.viewState === 'detail') {
                    this.renderer.domElement.style.cursor = 'default';
                    return;
                }
                
                // 轉換滑鼠座標
                this.mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // 設定raycaster
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                
                // 檢查與點點的交集
                const dotMeshes = this.interactiveDots.map(dotData => dotData.mesh);
                const intersects = this.raycaster.intersectObjects(dotMeshes);
                
                let currentHoveredDot = null;
                
                if (intersects.length > 0) {
                    // 🔧 修正：檢查點點是否真的可見和可點擊
                    const intersectedDot = intersects[0].object;
                    const dotData = this.interactiveDots.find(d => d.mesh === intersectedDot);
                    
                    // 只有在主視角且點點透明度大於0時才允許hover
                    if (dotData && dotData.transitionOpacity > 0.1) {
                        currentHoveredDot = intersectedDot;
                    }
                }
                
                // 更新hover狀態 - 只處理狀態改變的點
                this.interactiveDots.forEach(dotData => {
                    const shouldBeHovered = dotData.mesh === currentHoveredDot;
                    
                    if (shouldBeHovered && !dotData.isHovered) {
                        // 開始hover
                        dotData.isHovered = true;
                        this.animateDotHover(dotData.mesh, true);
                    } else if (!shouldBeHovered && dotData.isHovered) {
                        // 結束hover
                        dotData.isHovered = false;
                        this.animateDotHover(dotData.mesh, false);
                    }
                });
                
                // 更新滑鼠樣式
                this.renderer.domElement.style.cursor = currentHoveredDot ? 'pointer' : 'default';
            }

            animateDotPress(dotData, isPressed) {
                // 按下/放開動畫
                const duration = isPressed ? 80 : 200; // 按下快，放開慢
                const targetScale = isPressed ? 0.8 : 1.0; // 按下縮小30%
                const targetOpacityBoost = isPressed ? 1.6 : 1.0; // 按下時更亮
                
                const startScale = dotData.pressedScale;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 緩動函數：按下時快速，放開時彈性
                    const easeProgress = isPressed ? 
                        Math.pow(progress, 1.5) : // 按下：ease-in 快速
                        1 - Math.pow(1 - progress, 1.8); // 放開：ease-out 彈性
                    
                    // 更新縮放係數
                    dotData.pressedScale = startScale + (targetScale - startScale) * easeProgress;
                    
                    // 更新透明度（按下時變亮）
                    const targetMultiplier = dotData.isHovered ? 1.4 * targetOpacityBoost : targetOpacityBoost;
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            animateDotHover(dotMesh, isHovering) {
                // 找到對應的點資料
                const dotData = this.interactiveDots.find(d => d.mesh === dotMesh);
                if (!dotData) return;
                
                // 避免重複動畫
                if (dotMesh.userData.isAnimating) return;
                dotMesh.userData.isAnimating = true;
                
                // 設定目標透明度乘數
                const targetOpacityMultiplier = isHovering ? 1.4 : 1.0;
                const duration = 200;
                const startOpacityMultiplier = dotData.hoverMultiplier;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 使用更快的緩動函數，讓hover反應更即時
                    const easeProgress = 1 - Math.pow(1 - progress, 2); // ease-out quad
                    
                    // 更新透明度乘數
                    dotData.hoverMultiplier = startOpacityMultiplier + (targetOpacityMultiplier - startOpacityMultiplier) * easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        dotMesh.userData.isAnimating = false;
                    }
                };
                animate();
            }

            // 💡 ================== 點點提示動畫系統 ==================

            // 開始提示動畫循環
            startHintAnimationCycle() {
                if (this.hintAnimationState.isActive) return;
                
                this.hintAnimationState.isActive = true;
                this.hintAnimationState.currentCycle = 0;
                this.hintAnimationState.lastCycleTime = Date.now();
                
                console.log('💡 開始點點提示動畫循環');
                this.scheduleNextHintCycle();
            }

            // 停止提示動畫循環
            stopHintAnimationCycle() {
                this.hintAnimationState.isActive = false;
                
                // 停止所有正在進行的提示動畫
                this.interactiveDots.forEach(dotData => {
                    if (dotData.hintAnimation.isActive) {
                        dotData.hintAnimation.isActive = false;
                        dotData.hint.material.opacity = 0;
                    }
                });
                
                console.log('💡 停止點點提示動畫循環');
            }

            // 安排下一個提示循環
            scheduleNextHintCycle() {
                if (!this.hintAnimationState.isActive) return;
                
                const now = Date.now();
                this.hintAnimationState.lastCycleTime = now;
                this.hintAnimationState.currentCycle++;
                
                // 開始播放提示序列
                this.playHintSequence();
            }

            // 播放提示序列
            playHintSequence() {
                if (!this.hintAnimationState.isActive) return;
                
                // 獲取未點擊的點點
                const unclickedDots = this.interactiveDots.filter(dotData => !dotData.hasBeenClicked);
                
                if (unclickedDots.length === 0) {
                    // 所有點點都被點擊過，停止動畫
                    this.stopHintAnimationCycle();
                    return;
                }
                
                // 播放第一次序列
                this.playHintSequenceOnce(unclickedDots);
                
                // 延遲1000ms後播放第二次序列
                setTimeout(() => {
                    if (this.hintAnimationState.isActive) {
                        this.playHintSequenceOnce(unclickedDots);
                        
                        // 播放完兩次序列後，等待3000ms再開始下一個循環
                        setTimeout(() => {
                            if (this.hintAnimationState.isActive) {
                                this.scheduleNextHintCycle();
                            }
                        }, 3000); // 3秒間隔
                    }
                }, 1000);
            }

            // 播放單次提示序列
            playHintSequenceOnce(unclickedDots) {
                // 根據未點擊點點數量決定播放順序
                if (unclickedDots.length === 3) {
                    // 三個點點都沒點過：1->2->3
                    this.playHintForDot(unclickedDots[0], 0);
                    this.playHintForDot(unclickedDots[1], 100);
                    this.playHintForDot(unclickedDots[2], 200);
                } else if (unclickedDots.length === 2) {
                    // 兩個點點沒點過：1->2
                    this.playHintForDot(unclickedDots[0], 0);
                    this.playHintForDot(unclickedDots[1], 100);
                } else if (unclickedDots.length === 1) {
                    // 一個點點沒點過：1
                    this.playHintForDot(unclickedDots[0], 0);
                }
            }

            // 為單個點點播放提示動畫
            playHintForDot(dotData, delay) {
                setTimeout(() => {
                    if (!this.hintAnimationState.isActive || dotData.hasBeenClicked) return;
                    
                    this.animateDotHint(dotData);
                }, delay);
            }

            // 點點提示動畫
            animateDotHint(dotData) {
                if (!dotData.hint || dotData.hintAnimation.isActive) return;
                
                console.log(`💡 開始播放點點 ${dotData.config.id} 的提示動畫`);
                
                dotData.hintAnimation.isActive = true;
                dotData.hintAnimation.startTime = Date.now();
                dotData.hintAnimation.scale = 0.0; // 從0開始
                dotData.hintAnimation.opacity = 0.0;
                
                // 重置提示狀態 - 從0開始
                dotData.hint.material.opacity = 0;
                dotData.hint.scale.set(0, 0, 1); // 從大小為0開始
                
                const animate = () => {
                    if (!dotData.hintAnimation.isActive) return;
                    
                    const elapsed = Date.now() - dotData.hintAnimation.startTime;
                    const progress = Math.min(elapsed / 500, 1); // 500ms 動畫
                    
                    if (progress < 1) {
                        // 動畫進行中：從0開始放大並淡入，然後淡出
                        if (progress < 0.5) {
                            // 前半段：從0開始放大並淡入
                            const firstHalfProgress = progress * 2;
                            dotData.hintAnimation.scale = firstHalfProgress * 1.5; // 從0放大到1.5倍
                            dotData.hintAnimation.opacity = firstHalfProgress * 0.8; // 從0淡入到0.8
                        } else {
                            // 後半段：繼續放大並淡出
                            const secondHalfProgress = (progress - 0.5) * 2;
                            dotData.hintAnimation.scale = 1.5 + secondHalfProgress * 0.3; // 從1.5繼續放大到1.8倍
                            dotData.hintAnimation.opacity = 0.8 * (1 - secondHalfProgress); // 從0.8淡出到0
                        }
                        
                        // 應用動畫效果
                        dotData.hint.scale.set(
                            dotData.hintAnimation.scale,
                            dotData.hintAnimation.scale,
                            1
                        );
                        dotData.hint.material.opacity = dotData.hintAnimation.opacity;
                        
                        requestAnimationFrame(animate);
                    } else {
                        // 動畫結束 - 回到初始狀態
                        dotData.hintAnimation.isActive = false;
                        dotData.hint.material.opacity = 0;
                        dotData.hint.scale.set(0, 0, 1); // 回到大小為0
                        console.log(`💡 點點 ${dotData.config.id} 的提示動畫結束`);
                    }
                };
                
                animate();
            }

            // 標記點點為已點擊
            markDotAsClicked(dotId) {
                const dotData = this.interactiveDots.find(d => d.config.id === dotId);
                if (dotData && !dotData.hasBeenClicked) {
                    dotData.hasBeenClicked = true;
                    console.log(`💡 點點 ${dotId} 已標記為已點擊`);
                    
                    // 檢查是否所有點點都被點擊過
                    const allClicked = this.interactiveDots.every(d => d.hasBeenClicked);
                    if (allClicked) {
                        this.stopHintAnimationCycle();
                        console.log('💡 所有點點都已點擊，停止提示動畫');
                    }
                }
            }

            // 🎯 ================== 距離感應互動系統 ==================

            updateDistanceInteraction(event) {
                if (!this.loadingComplete || !this.layers.length) return;
                
                // 獲取滑鼠在畫面中的位置
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                // 獲取主圖的尺寸和位置信息
                const firstLayer = this.layers[0];
                if (!firstLayer.userData.mainTexture) return;
                
                const { width, height } = this.calculateImageSize(firstLayer.userData.mainTexture);
                
                // 計算螢幕中心點
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                // 計算最大感應距離（基於主圖寬度）
                const maxDistancePixels = width * this.MAX_DISTANCE * (window.innerWidth / (width * this.IMAGE_SCALE));
                
                this.interactiveDots.forEach(dotData => {
                    // 計算點點在螢幕上的實際位置
                    const dotScreenX = centerX + dotData.mesh.position.x * (window.innerWidth / (width * this.IMAGE_SCALE));
                    const dotScreenY = centerY - dotData.mesh.position.y * (window.innerHeight / (height * this.IMAGE_SCALE));
                    
                    // 計算滑鼠與點點的距離
                    const deltaX = mouseX - dotScreenX;
                    const deltaY = mouseY - dotScreenY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // 計算距離係數 (0 = 最近, 1 = 最遠/超出範圍)
                    let distanceFactor = Math.min(distance / maxDistancePixels, 1.0);
                    
                    // 使用緩動曲線讓距離變化更自然
                    distanceFactor = this.easeOutQuad(distanceFactor);
                    
                    // 設定目標距離係數
                    dotData.targetMouseDistance = distanceFactor;
                });
            }

            updateDistanceInteractionAnimation() {
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // 距離互動啟用：平滑過渡到目標距離係數
                        const delta = dotData.targetMouseDistance - dotData.mouseDistance;
                        dotData.mouseDistance += delta * this.DISTANCE_LERP_SPEED;
                        
                        // 計算基於距離的縮放和透明度
                        // 使用反轉的距離係數：距離近時係數大，距離遠時係數小
                        const proximityFactor = 1.0 - dotData.mouseDistance;
                        
                        // 縮放係數：從最小縮放到1.0
                        dotData.distanceScale = this.MIN_SCALE_FACTOR + (1.0 - this.MIN_SCALE_FACTOR) * proximityFactor;
                        
                        // 透明度係數：從最小透明度到1.0
                        dotData.distanceOpacity = this.MIN_OPACITY_FACTOR + (1.0 - this.MIN_OPACITY_FACTOR) * proximityFactor;
                    } else {
                        // 距離互動關閉：保持正常大小和透明度
                        dotData.mouseDistance = 0.0;
                        dotData.targetMouseDistance = 0.0;
                        dotData.distanceScale = 1.0;
                        dotData.distanceOpacity = 1.0;
                    }
                });
            }

            resetDistanceInteraction() {
                // 重置所有點點的距離係數
                this.interactiveDots.forEach(dotData => {
                    if (this.DISTANCE_INTERACTION_ENABLED) {
                        // 距離互動啟用：重置到最遠狀態
                        dotData.targetMouseDistance = 1.0;
                    } else {
                        // 距離互動關閉：重置到正常狀態
                        dotData.targetMouseDistance = 0.0;
                    }
                });
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            // 🎯 ================== 距離感應互動系統結束 ==================

            fadeInInteractiveDots() {
                // 互動點點的淡入動畫
                const fadeInDuration = 1500; // 1.5秒淡入
                const startTime = Date.now();
                
                this.interactiveDots.forEach((dotData, index) => {
                    const delay = index * 300; // 每個點錯開0.3秒
                    
                    setTimeout(() => {
                        dotData.mesh.userData.isVisible = true;
                        // 為每個點設定獨立的動畫開始時間
                        dotData.mesh.userData.animationStartTime = Date.now();
                        
                        const animate = () => {
                            const elapsed = Date.now() - startTime - delay;
                            const progress = Math.max(0, Math.min(elapsed / fadeInDuration, 1));
                            
                            if (progress > 0) {
                                // 緩動函數：ease-out
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                
                                // 在淡入過程中就開始計算呼吸動畫，確保絲滑銜接
                                const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                                const phase = index * Math.PI * 0.8;
                                const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                                
                                // 🎯 更新距離互動動畫（淡入期間也需要）
                                this.updateDistanceInteractionAnimation();
                                
                                // 淡入期間：透明度 = 淡入進度 × 基礎透明度 × 呼吸係數 × hover乘數 × 距離透明度 × 過渡透明度
                                const targetOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                                const opacity = targetOpacity * easeProgress;
                                dotData.mesh.material.opacity = opacity;
                                
                                // 確保提示在點點淡入期間保持透明且縮放為0
                                if (dotData.hint) {
                                    dotData.hint.material.opacity = 0;
                                    dotData.hint.scale.set(0, 0, 1);
                                }
                                
                                // 大小呼吸效果，在淡入期間也同步開始，並考慮所有縮放效果
                                const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                                // 組合所有縮放效果：呼吸 × hover × 按下 × 距離
                                const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                                const finalScale = hoverScale * dotData.pressedScale * dotData.distanceScale;
                                const scaleFactor = finalScale * easeProgress + (1 - easeProgress);
                                dotData.mesh.scale.setScalar(scaleFactor);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else {
                                // 淡入完成，切換到純呼吸動畫
                                this.startBreathingAnimation(dotData, index);
                                
                                // 檢查是否是最後一個點點淡入完成
                                if (index === this.interactiveDots.length - 1) {
                                    console.log('🔴 所有點點淡入完成，準備啟動提示動畫');
                                    // 延遲500ms後開始提示動畫循環
                                    setTimeout(() => {
                                        console.log('💡 延遲結束，開始啟動提示動畫循環');
                                        this.startHintAnimationCycle();
                                    }, 500);
                                }
                            }
                        };
                        animate();
                    }, delay);
                });
            }

            startBreathingAnimation(dotData, index) {
                // 桌機版和行動版的統一呼吸動畫，使用每個點獨立的時間基準
                const breathAnimate = () => {
                    if (!dotData.mesh.userData.isVisible) return;
                    
                    // 🎯 更新距離互動動畫
                    this.updateDistanceInteractionAnimation();
                    
                    // 使用每個點獨立的動畫開始時間，確保絲滑銜接
                    const breathTime = (Date.now() - dotData.mesh.userData.animationStartTime) * this.BREATH_SPEED;
                    const phase = index * Math.PI * 0.8; // 每個點有不同的相位
                    
                    // 透明度呼吸效果：基礎呼吸 × hover乘數 × 距離透明度 × 過渡透明度
                    const breathFactor = 0.9 + 0.1 * (Math.sin(breathTime + phase) * 0.5 + 0.5);
                    const currentOpacity = dotData.mesh.userData.baseOpacity * breathFactor * dotData.hoverMultiplier * dotData.distanceOpacity * dotData.transitionOpacity;
                    dotData.mesh.material.opacity = currentOpacity;
                    
                    // 大小呼吸效果：組合呼吸、hover、按下和距離效果
                    const breathScale = 0.95 + 0.1 * (Math.sin(breathTime * 1.1 + phase) * 0.5 + 0.5);
                    const hoverScale = dotData.isHovered ? Math.max(breathScale, 1.1) : breathScale;
                    const scaleFactor = hoverScale * dotData.pressedScale * dotData.distanceScale;
                    dotData.mesh.scale.setScalar(scaleFactor);
                    
                    requestAnimationFrame(breathAnimate);
                };
                breathAnimate();
            }

            // 🔴 ================== 互動點點系統結束 ==================

            // 🔍 ================== 局部圖系統 ==================

            // 🕹️ 局部視角控制方法
            updateDetailViewControl(inputX, inputY) {
                
                // 更新局部視角的滑鼠位置
                this.detailViewMouse.x = inputX;
                this.detailViewMouse.y = inputY;
                
                // 計算邊界超出效果的偏移量 - 相反方向
                const offsetX = -inputX * this.DETAIL_VIEW_INTENSITY;  // X軸相反
                const offsetY = -inputY * this.DETAIL_VIEW_INTENSITY;  // Y軸相反
                
                // 應用邊界限制
                const maxOffset = this.DETAIL_VIEW_BOUNDARY;
                this.detailViewOffset.x = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
                this.detailViewOffset.y = Math.max(-maxOffset, Math.min(maxOffset, offsetY));
                
                // 更新場景位置以實現邊界超出效果
                if (this.currentDetailDot) {
                    const detailLayer = this.detailLayers.find(layer => 
                        layer.detailInfo.dotId === this.currentDetailDot.config.id
                    );
                    
                    if (detailLayer) {
                        const detailMesh = detailLayer.mesh;
                        
                        // 計算基礎場景位置（局部圖中心對齊畫面中心）
                        const baseSceneX = -detailMesh.position.x;
                        const baseSceneY = -detailMesh.position.y;
                        
                        // 應用邊界超出偏移
                        this.scene.position.x = baseSceneX + this.detailViewOffset.x;
                        this.scene.position.y = baseSceneY + this.detailViewOffset.y;
                        
                        // 可選：添加調試資訊
                        // console.log(`🕹️ 局部視角控制: offset(${this.detailViewOffset.x.toFixed(3)}, ${this.detailViewOffset.y.toFixed(3)})`);
                    }
                }
            }

            resetDetailViewControl() {
                // 重置局部視角控制
                this.detailViewMouse.x = 0;
                this.detailViewMouse.y = 0;
                this.detailViewOffset.x = 0;
                this.detailViewOffset.y = 0;
            }

            // 🔴 ================== 點點過渡透明度控制系統 ==================

            updateDotsTransitionOpacity(animationType, progress) {
                // 更新點點在放大縮小過程中的透明度
                if (!this.interactiveDots.length) return;

                let transitionOpacity = 1.0;

                if (animationType === 'zoomIn') {
                    // 放大時淡出：進度 0.0→0.5 透明度 100%→0%，進度 0.5→1.0 透明度保持 0%
                    if (progress <= 0.5) {
                        transitionOpacity = 1.0 - (progress / 0.5); // 從1.0過渡到0.0
                    } else {
                        transitionOpacity = 0.0; // 保持透明
                    }
                } else if (animationType === 'zoomOut') {
                    // 縮小時淡入：進度 0.0→0.5 透明度保持 0%，進度 0.5→1.0 透明度 0%→100%
                    if (progress <= 0.5) {
                        transitionOpacity = 0.0; // 保持透明
                    } else {
                        transitionOpacity = (progress - 0.5) / 0.5; // 從0.0過渡到1.0
                    }
                }

                // 應用到所有點點
                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = transitionOpacity;
                });

                // 可選：添加調試資訊
                // console.log(`🔴 點點過渡透明度: ${animationType}, progress=${progress.toFixed(3)}, opacity=${transitionOpacity.toFixed(3)}`);
            }

            resetDotsTransitionOpacity(opacity) {
                // 重置所有點點的過渡透明度
                if (!this.interactiveDots.length) return;

                this.interactiveDots.forEach(dotData => {
                    dotData.transitionOpacity = opacity;
                });

                console.log(`🔴 重置點點透明度: ${(opacity * 100).toFixed(0)}%`);
            }

            // 🔴 ================== 點點過渡透明度控制系統結束 ==================

            // 🖥️ 全螢幕模式視窗大小處理
            handleFullscreenResize() {
                console.log('🖥️ 全螢幕模式視窗大小變化處理');
                
                // 強制重新計算相機比例
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                
                // 重新設定渲染器尺寸
                const maxRatio = 2;
                const pixelRatio = Math.min(window.devicePixelRatio || 1, maxRatio);
                this.renderer.setPixelRatio(pixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // 更新canvas元素顯示尺寸
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    canvas.style.width = window.innerWidth + 'px';
                    canvas.style.height = window.innerHeight + 'px';
                }
                
                // 同時更新載入場景
                if (this.loadingCamera && this.loadingRenderer) {
                    this.loadingCamera.aspect = window.innerWidth / window.innerHeight;
                    this.loadingCamera.updateProjectionMatrix();
                    this.loadingRenderer.setPixelRatio(pixelRatio);
                    this.loadingRenderer.setSize(window.innerWidth, window.innerHeight, false);
                    
                    const loadingCanvas = document.getElementById('loading-canvas');
                    if (loadingCanvas) {
                        loadingCanvas.style.width = window.innerWidth + 'px';
                        loadingCanvas.style.height = window.innerHeight + 'px';
                    }
                }
                
                // 重新計算所有圖層尺寸
                this.updateAllLayerSizes();
                
                // 更新按鈕顯示狀態
                this.monitorControlMode();
                
                // 更新提示對話框位置
                this.updateTooltipPositions();
                
                // 強制重新渲染
                this.renderer.render(this.scene, this.camera);
            }
        }

        // 全域變數用於存取ParallaxViewer實例
        let parallaxViewerInstance = null;
        window.parallaxViewerInstance = null;

        // 返回按鈕處理函數
        function handleBackButton() {
            if (parallaxViewerInstance) {
                if (parallaxViewerInstance.viewState === 'detail') {
                    // 局部視角：返回主視角
                    parallaxViewerInstance.returnToMainView();
                } else {
                    // 主視角：返回首頁
                    window.location.href = '#';
                }
            } else {
                // 預設行為
                window.location.href = '#';
            }
        }

        // 全螢幕按鈕處理函數
        function handleFullscreenButton() {
            if (!document.fullscreenElement) {
                // 進入全螢幕
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // 退出全螢幕
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // 重置視角按鈕處理函數
        function handleResetViewButton() {
            if (parallaxViewerInstance) {
                parallaxViewerInstance.resetView();
            }
        }

        // 語言切換功能
        function initLanguageSwitch() {
            const languageButton = document.getElementById('language-switch-button');
            const languageMenu = document.getElementById('language-menu');
            const languageOptions = document.querySelectorAll('.language-option');
            
            // 檢測當前語言
            const currentPath = window.location.pathname;
            let currentLang = 'zh'; // 預設中文
            
            if (currentPath.includes('/en/')) {
                currentLang = 'en';
            } else if (currentPath.includes('/ja/')) {
                currentLang = 'ja';
            } else if (currentPath.includes('/zh/')) {
                currentLang = 'zh';
            }
            
            // 設置當前語言選項的狀態
            languageOptions.forEach(option => {
                const lang = option.getAttribute('data-lang');
                if (lang === currentLang) {
                    option.classList.add('current');
                } else {
                    option.classList.remove('current');
                }
            });
            
            // 語言按鈕點擊事件
            languageButton.addEventListener('click', (e) => {
                e.stopPropagation();
                languageMenu.classList.toggle('show');
            });
            
            // 語言選項點擊事件
            languageOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const selectedLang = option.getAttribute('data-lang');
                    
                    // 如果點擊的是當前語言，不做任何操作
                    if (selectedLang === currentLang) {
                        languageMenu.classList.remove('show');
                        return;
                    }
                    
                    // 儲存語言偏好
                    localStorage.setItem('preferred_language', selectedLang);
                    
                    // 跳轉到對應語言頁面
                    switchToLanguage(selectedLang);
                });
            });
            
            // 點擊其他地方關閉選單
            document.addEventListener('click', (e) => {
                if (!languageButton.contains(e.target) && !languageMenu.contains(e.target)) {
                    languageMenu.classList.remove('show');
                }
            });
            
            // ESC鍵關閉選單
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    languageMenu.classList.remove('show');
                }
            });
        }
        
        // 切換語言
        function switchToLanguage(lang) {
            const languageMap = {
                'zh': '/zh/',
                'en': '/en/',
                'ja': '/ja/'
            };
            
            const targetUrl = languageMap[lang];
            if (targetUrl) {
                // 使用平滑過渡效果
                document.body.style.transition = 'opacity 0.3s ease';
                document.body.style.opacity = '0.7';
                
                setTimeout(() => {
                    window.location.href = targetUrl;
                }, 150);
            }
        }

        // 初始化應用程式
        document.addEventListener('DOMContentLoaded', () => {
            parallaxViewerInstance = new ParallaxViewer();
            window.parallaxViewerInstance = parallaxViewerInstance;
            
            // 語言切換功能
            initLanguageSwitch();
            
            // 全螢幕狀態監聽
            const fullscreenButton = document.getElementById('fullscreen-button');
            const fullscreenIcon = fullscreenButton.querySelector('svg');
            
            function updateFullscreenIcon() {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                    // 全螢幕狀態：顯示退出圖示
                    fullscreenIcon.innerHTML = '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>';
                } else {
                    // 非全螢幕狀態：顯示進入圖示
                    fullscreenIcon.innerHTML = '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>';
                }
            }
            
            // 監聽全螢幕狀態變化
            document.addEventListener('fullscreenchange', () => {
                updateFullscreenIcon();
                // 全螢幕狀態變化時強制重新計算尺寸
                setTimeout(() => {
                    if (parallaxViewerInstance) {
                        parallaxViewerInstance.handleFullscreenResize();
                    }
                }, 100);
            });
            document.addEventListener('webkitfullscreenchange', () => {
                updateFullscreenIcon();
                // 全螢幕狀態變化時強制重新計算尺寸
                setTimeout(() => {
                    if (parallaxViewerInstance) {
                        parallaxViewerInstance.handleFullscreenResize();
                    }
                }, 100);
            });
            document.addEventListener('msfullscreenchange', () => {
                updateFullscreenIcon();
                // 全螢幕狀態變化時強制重新計算尺寸
                setTimeout(() => {
                    if (parallaxViewerInstance) {
                        parallaxViewerInstance.handleFullscreenResize();
                    }
                }, 100);
            });
            
            // 初始化圖示
            updateFullscreenIcon();
            
            // 觸控裝置檢測和優化
            function detectTouchDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (isMobile) {
                    document.body.classList.add('touch-device');
                    console.log('📱 檢測到行動裝置，啟用觸控優化');
                } else {
                    document.body.classList.add('desktop-device');
                    console.log('🖥️ 檢測到桌面裝置');
                }
            }
            
            // 行動裝置按鈕顯示控制
            function controlMobileButtons() {
                const fullscreenButton = document.getElementById('fullscreen-button');
                const resetViewButton = document.getElementById('reset-view-button');
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // 全螢幕按鈕在所有裝置都顯示
                fullscreenButton.style.display = 'flex';
                
                // 重置視角按鈕在行動裝置上顯示（直式和橫向都顯示）
                if (isMobile) {
                    resetViewButton.style.display = 'flex';
                    console.log('📱 行動裝置：顯示重置視角按鈕');
                } else {
                    resetViewButton.style.display = 'none';
                    console.log('🖥️ 桌面裝置：隱藏重置視角按鈕');
                }
            }
            
            // 執行觸控裝置檢測
            detectTouchDevice();
            
            // 執行行動裝置按鈕控制
            controlMobileButtons();
            
            // 監聽視窗大小變化
            window.addEventListener('resize', controlMobileButtons);
        });

        // 開發模式：重置陀螺儀授權狀態（按兩下返回按鈕）
        let backButtonClickCount = 0;
        let backButtonClickTimer = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            const backButton = document.getElementById('back-button');
            if (backButton) {
                backButton.addEventListener('click', () => {
                    backButtonClickCount++;
                    
                    if (backButtonClickTimer) {
                        clearTimeout(backButtonClickTimer);
                    }
                    
                    backButtonClickTimer = setTimeout(() => {
                        if (backButtonClickCount === 2) {
                            // 雙擊重置授權狀態
                            localStorage.removeItem('gyroPermissionGranted');
                            console.log('🔄 陀螺儀授權狀態已重置');
                            location.reload(); // 重新載入頁面
                        }
                        backButtonClickCount = 0;
                    }, 300);
                });
            }
        });
    </script>
</body>
</html>